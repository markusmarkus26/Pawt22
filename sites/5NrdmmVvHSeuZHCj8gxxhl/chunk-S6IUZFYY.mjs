import {a as pn, b as wg, c as hr, d as R, e as de, f as Qt, g as Qu, h as Nt} from "./chunk-JR5VT52U.mjs";
import {a as Ku, b as Fe, c as P} from "./chunk-RIUMFBNJ.mjs";
var kt = {};
Ku(kt, {
    Children: () => mn,
    Component: () => we,
    Fragment: () => gn,
    Profiler: () => tR,
    PureComponent: () => nR,
    StrictMode: () => rR,
    Suspense: () => pr,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => iR,
    cloneElement: () => mr,
    createContext: () => ve,
    createElement: () => Ji,
    createFactory: () => oR,
    createRef: () => Og,
    default: () => x,
    forwardRef: () => Ie,
    isValidElement: () => Ot,
    lazy: () => sR,
    memo: () => qa,
    startTransition: () => Mt,
    unstable_act: () => aR,
    useCallback: () => K,
    useContext: () => D,
    useDebugValue: () => lR,
    useDeferredValue: () => cR,
    useEffect: () => $,
    useId: () => gi,
    useImperativeHandle: () => uR,
    useInsertionEffect: () => ct,
    useLayoutEffect: () => Ae,
    useMemo: () => se,
    useReducer: () => fR,
    useRef: () => V,
    useState: () => Oe,
    useSyncExternalStore: () => Mg,
    useTransition: () => dR,
    version: () => hR
});
var x = {}
  , os = Symbol.for("react.element")
  , $T = Symbol.for("react.portal")
  , NT = Symbol.for("react.fragment")
  , jT = Symbol.for("react.strict_mode")
  , HT = Symbol.for("react.profiler")
  , WT = Symbol.for("react.provider")
  , UT = Symbol.for("react.context")
  , GT = Symbol.for("react.forward_ref")
  , qT = Symbol.for("react.suspense")
  , XT = Symbol.for("react.memo")
  , YT = Symbol.for("react.lazy")
  , Sg = Symbol.iterator;
function KT(e) {
    return e === null || typeof e != "object" ? null : (e = Sg && e[Sg] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var Tg = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Rg = Object.assign
  , Eg = {};
function Zi(e, t, n) {
    this.props = e,
    this.context = t,
    this.refs = Eg,
    this.updater = n || Tg
}
Zi.prototype.isReactComponent = {};
Zi.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
}
;
Zi.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
;
function Fg() {}
Fg.prototype = Zi.prototype;
function Ju(e, t, n) {
    this.props = e,
    this.context = t,
    this.refs = Eg,
    this.updater = n || Tg
}
var ef = Ju.prototype = new Fg;
ef.constructor = Ju;
Rg(ef, Zi.prototype);
ef.isPureReactComponent = !0;
var kg = Array.isArray
  , Pg = Object.prototype.hasOwnProperty
  , tf = {
    current: null
}
  , _g = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Ig(e, t, n) {
    var r, i = {}, o = null, s = null;
    if (t != null)
        for (r in t.ref !== void 0 && (s = t.ref),
        t.key !== void 0 && (o = "" + t.key),
        t)
            Pg.call(t, r) && !_g.hasOwnProperty(r) && (i[r] = t[r]);
    var a = arguments.length - 2;
    if (a === 1)
        i.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        i.children = l
    }
    if (e && e.defaultProps)
        for (r in a = e.defaultProps,
        a)
            i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: os,
        type: e,
        key: o,
        ref: s,
        props: i,
        _owner: tf.current
    }
}
function QT(e, t) {
    return {
        $$typeof: os,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}
function nf(e) {
    return typeof e == "object" && e !== null && e.$$typeof === os
}
function ZT(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(n) {
        return t[n]
    })
}
var Cg = /\/+/g;
function Zu(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? ZT("" + e.key) : t.toString(36)
}
function Ua(e, t, n, r, i) {
    var o = typeof e;
    o !== "undefined" && o !== "boolean" || (e = null);
    var s = !1;
    if (e === null)
        s = !0;
    else
        switch (o) {
        case "string":
        case "number":
            s = !0;
            break;
        case "object":
            switch (e.$$typeof) {
            case os:
            case $T:
                s = !0
            }
        }
    if (s)
        return s = e,
        i = i(s),
        e = r === "" ? "." + Zu(s, 0) : r,
        kg(i) ? (n = "",
        e != null && (n = e.replace(Cg, "$&/") + "/"),
        Ua(i, t, n, "", function(c) {
            return c
        })) : i != null && (nf(i) && (i = QT(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(Cg, "$&/") + "/") + e)),
        t.push(i)),
        1;
    if (s = 0,
    r = r === "" ? "." : r + ":",
    kg(e))
        for (var a = 0; a < e.length; a++) {
            o = e[a];
            var l = r + Zu(o, a);
            s += Ua(o, t, n, l, i)
        }
    else if (l = KT(e),
    typeof l == "function")
        for (e = l.call(e),
        a = 0; !(o = e.next()).done; )
            o = o.value,
            l = r + Zu(o, a++),
            s += Ua(o, t, n, l, i);
    else if (o === "object")
        throw t = String(e),
        Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return s
}
function Wa(e, t, n) {
    if (e == null)
        return e;
    var r = []
      , i = 0;
    return Ua(e, r, "", "", function(o) {
        return t.call(n, o, i++)
    }),
    r
}
function JT(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(),
        t.then(function(n) {
            e._status !== 0 && e._status !== -1 || (e._status = 1,
            e._result = n)
        }, function(n) {
            e._status !== 0 && e._status !== -1 || (e._status = 2,
            e._result = n)
        }),
        e._status === -1 && (e._status = 0,
        e._result = t)
    }
    if (e._status === 1)
        return e._result.default;
    throw e._result
}
var It = {
    current: null
}
  , Ga = {
    transition: null
}
  , eR = {
    ReactCurrentDispatcher: It,
    ReactCurrentBatchConfig: Ga,
    ReactCurrentOwner: tf
};
x.Children = {
    map: Wa,
    forEach: function(e, t, n) {
        Wa(e, function() {
            t.apply(this, arguments)
        }, n)
    },
    count: function(e) {
        var t = 0;
        return Wa(e, function() {
            t++
        }),
        t
    },
    toArray: function(e) {
        return Wa(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!nf(e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
x.Component = Zi;
x.Fragment = NT;
x.Profiler = HT;
x.PureComponent = Ju;
x.StrictMode = jT;
x.Suspense = qT;
x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eR;
x.cloneElement = function(e, t, n) {
    if (e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var r = Rg({}, e.props)
      , i = e.key
      , o = e.ref
      , s = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (o = t.ref,
        s = tf.current),
        t.key !== void 0 && (i = "" + t.key),
        e.type && e.type.defaultProps)
            var a = e.type.defaultProps;
        for (l in t)
            Pg.call(t, l) && !_g.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        r.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: os,
        type: e.type,
        key: i,
        ref: o,
        props: r,
        _owner: s
    }
}
;
x.createContext = function(e) {
    return e = {
        $$typeof: UT,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    e.Provider = {
        $$typeof: WT,
        _context: e
    },
    e.Consumer = e
}
;
x.createElement = Ig;
x.createFactory = function(e) {
    var t = Ig.bind(null, e);
    return t.type = e,
    t
}
;
x.createRef = function() {
    return {
        current: null
    }
}
;
x.forwardRef = function(e) {
    return {
        $$typeof: GT,
        render: e
    }
}
;
x.isValidElement = nf;
x.lazy = function(e) {
    return {
        $$typeof: YT,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: JT
    }
}
;
x.memo = function(e, t) {
    return {
        $$typeof: XT,
        type: e,
        compare: t === void 0 ? null : t
    }
}
;
x.startTransition = function(e) {
    var t = Ga.transition;
    Ga.transition = {};
    try {
        e()
    } finally {
        Ga.transition = t
    }
}
;
x.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
x.useCallback = function(e, t) {
    return It.current.useCallback(e, t)
}
;
x.useContext = function(e) {
    return It.current.useContext(e)
}
;
x.useDebugValue = function() {}
;
x.useDeferredValue = function(e) {
    return It.current.useDeferredValue(e)
}
;
x.useEffect = function(e, t) {
    return It.current.useEffect(e, t)
}
;
x.useId = function() {
    return It.current.useId()
}
;
x.useImperativeHandle = function(e, t, n) {
    return It.current.useImperativeHandle(e, t, n)
}
;
x.useInsertionEffect = function(e, t) {
    return It.current.useInsertionEffect(e, t)
}
;
x.useLayoutEffect = function(e, t) {
    return It.current.useLayoutEffect(e, t)
}
;
x.useMemo = function(e, t) {
    return It.current.useMemo(e, t)
}
;
x.useReducer = function(e, t, n) {
    return It.current.useReducer(e, t, n)
}
;
x.useRef = function(e) {
    return It.current.useRef(e)
}
;
x.useState = function(e) {
    return It.current.useState(e)
}
;
x.useSyncExternalStore = function(e, t, n) {
    return It.current.useSyncExternalStore(e, t, n)
}
;
x.useTransition = function() {
    return It.current.useTransition()
}
;
x.version = "18.2.0";
var mn = x.Children
  , we = x.Component
  , gn = x.Fragment
  , tR = x.Profiler
  , nR = x.PureComponent
  , rR = x.StrictMode
  , pr = x.Suspense
  , iR = x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , mr = x.cloneElement
  , ve = x.createContext
  , Ji = x.createElement
  , oR = x.createFactory
  , Og = x.createRef
  , Ie = x.forwardRef
  , Ot = x.isValidElement
  , sR = x.lazy
  , qa = x.memo
  , Mt = x.startTransition
  , aR = x.unstable_act
  , K = x.useCallback
  , D = x.useContext
  , lR = x.useDebugValue
  , cR = x.useDeferredValue
  , $ = x.useEffect
  , gi = x.useId
  , uR = x.useImperativeHandle
  , ct = x.useInsertionEffect
  , Ae = x.useLayoutEffect
  , se = x.useMemo
  , fR = x.useReducer
  , V = x.useRef
  , Oe = x.useState
  , Mg = x.useSyncExternalStore
  , dR = x.useTransition
  , hR = x.version;
var pR = "default"in kt ? x : kt
  , eo = {}
  , mR = pR
  , gR = Symbol.for("react.element")
  , vR = Symbol.for("react.fragment")
  , yR = Object.prototype.hasOwnProperty
  , bR = mR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , xR = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Lg(e, t, n) {
    var r, i = {}, o = null, s = null;
    n !== void 0 && (o = "" + n),
    t.key !== void 0 && (o = "" + t.key),
    t.ref !== void 0 && (s = t.ref);
    for (r in t)
        yR.call(t, r) && !xR.hasOwnProperty(r) && (i[r] = t[r]);
    if (e && e.defaultProps)
        for (r in t = e.defaultProps,
        t)
            i[r] === void 0 && (i[r] = t[r]);
    return {
        $$typeof: gR,
        type: e,
        key: o,
        ref: s,
        props: i,
        _owner: bR.current
    }
}
eo.Fragment = vR;
eo.jsx = Lg;
eo.jsxs = Lg;
var it = eo.Fragment
  , k = eo.jsx
  , he = eo.jsxs;
var wR = pn({
    "../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        function t(n) {
            var r = {};
            return function(i) {
                return r[i] === void 0 && (r[i] = n(i)),
                r[i]
            }
        }
        e.default = t
    }
})
  , SR = pn({
    "../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        function t(o) {
            return o && typeof o == "object" && "default"in o ? o.default : o
        }
        var n = t(wR())
          , r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
          , i = n(function(o) {
            return r.test(o) || o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) < 91
        });
        e.default = i
    }
})
  , cl = {
    skipAnimations: !1,
    useManualTiming: !1
}
  , yt = e => e;
function kR(e) {
    let t = new Set
      , n = new Set
      , r = !1
      , i = !1
      , o = new WeakSet
      , s = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function a(c) {
        o.has(c) && (l.schedule(c),
        e()),
        c(s)
    }
    let l = {
        schedule: (c, u=!1, f=!1) => {
            let p = f && r ? t : n;
            return u && o.add(c),
            p.has(c) || p.add(c),
            c
        }
        ,
        cancel: c => {
            n.delete(c),
            o.delete(c)
        }
        ,
        process: c => {
            if (s = c,
            r) {
                i = !0;
                return
            }
            r = !0,
            [t,n] = [n, t],
            n.clear(),
            t.forEach(a),
            r = !1,
            i && (i = !1,
            l.process(c))
        }
    };
    return l
}
var ls = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , CR = 40;
function oy(e, t) {
    let n = !1
      , r = !0
      , i = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , o = () => n = !0
      , s = ls.reduce( (m, h) => (m[h] = kR(o),
    m), {})
      , {read: a, resolveKeyframes: l, update: c, preRender: u, render: f, postRender: d} = s
      , p = () => {
        let m = cl.useManualTiming ? i.timestamp : performance.now();
        n = !1,
        i.delta = r ? 1e3 / 60 : Math.max(Math.min(m - i.timestamp, CR), 1),
        i.timestamp = m,
        i.isProcessing = !0,
        a.process(i),
        l.process(i),
        c.process(i),
        u.process(i),
        f.process(i),
        d.process(i),
        i.isProcessing = !1,
        n && t && (r = !1,
        e(p))
    }
      , v = () => {
        n = !0,
        r = !0,
        i.isProcessing || e(p)
    }
    ;
    return {
        schedule: ls.reduce( (m, h) => {
            let y = s[h];
            return m[h] = (w, C=!1, S=!1) => (n || v(),
            y.schedule(w, C, S)),
            m
        }
        , {}),
        cancel: m => {
            for (let h = 0; h < ls.length; h++)
                s[ls[h]].cancel(m)
        }
        ,
        state: i,
        steps: s
    }
}
var {schedule: Z, cancel: Lt, state: Ue, steps: Qa} = oy(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yt, !0)
  , sy = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
  , TR = 1e-7
  , RR = 12;
function ER(e, t, n, r, i) {
    let o, s, a = 0;
    do
        s = t + (n - t) / 2,
        o = sy(s, r, i) - e,
        o > 0 ? n = s : t = s;
    while (Math.abs(o) > TR && ++a < RR);
    return s
}
function co(e, t, n, r) {
    if (e === t && n === r)
        return yt;
    let i = o => ER(o, 0, 1, e, n);
    return o => o === 0 || o === 1 ? o : sy(i(o), t, r)
}
var zf = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
  , Bf = e => t => 1 - e(1 - t)
  , $f = co(.33, 1.53, .69, .99)
  , ul = Bf($f)
  , Nf = zf(ul)
  , jf = e => (e *= 2) < 1 ? .5 * ul(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
  , fl = e => 1 - Math.sin(Math.acos(e))
  , Hf = Bf(fl)
  , Wf = zf(fl)
  , uo = yt
  , Zt = yt
  , vr = (e, t, n) => n > t ? t : n < e ? e : n
  , Ss = e => ({
    test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: t => `${t}${e}`
})
  , Dr = Ss("deg")
  , Wn = Ss("%")
  , Q = Ss("px")
  , FR = Ss("vh")
  , PR = Ss("vw")
  , Vg = {
    ...Wn,
    parse: e => Wn.parse(e) / 100,
    transform: e => Wn.transform(e * 100)
}
  , fo = {
    test: e => typeof e == "number",
    parse: parseFloat,
    transform: e => e
}
  , gs = {
    ...fo,
    transform: e => vr(0, 1, e)
}
  , Xa = {
    ...fo,
    default: 1
}
  , fs = e => Math.round(e * 1e5) / 1e5
  , Uf = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function _R(e) {
    return e == null
}
var IR = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , Gf = (e, t) => n => !!(typeof n == "string" && IR.test(n) && n.startsWith(e) || t && !_R(n) && Object.prototype.hasOwnProperty.call(n, t))
  , ay = (e, t, n) => r => {
    if (typeof r != "string")
        return r;
    let[i,o,s,a] = r.match(Uf);
    return {
        [e]: parseFloat(i),
        [t]: parseFloat(o),
        [n]: parseFloat(s),
        alpha: a !== void 0 ? parseFloat(a) : 1
    }
}
  , OR = e => vr(0, 255, e)
  , rf = {
    ...fo,
    transform: e => Math.round(OR(e))
}
  , xi = {
    test: Gf("rgb", "red"),
    parse: ay("red", "green", "blue"),
    transform: ({red: e, green: t, blue: n, alpha: r=1}) => "rgba(" + rf.transform(e) + ", " + rf.transform(t) + ", " + rf.transform(n) + ", " + fs(gs.transform(r)) + ")"
};
function MR(e) {
    let t = ""
      , n = ""
      , r = ""
      , i = "";
    return e.length > 5 ? (t = e.substring(1, 3),
    n = e.substring(3, 5),
    r = e.substring(5, 7),
    i = e.substring(7, 9)) : (t = e.substring(1, 2),
    n = e.substring(2, 3),
    r = e.substring(3, 4),
    i = e.substring(4, 5),
    t += t,
    n += n,
    r += r,
    i += i),
    {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
var vf = {
    test: Gf("#"),
    parse: MR,
    transform: xi.transform
}
  , to = {
    test: Gf("hsl", "hue"),
    parse: ay("hue", "saturation", "lightness"),
    transform: ({hue: e, saturation: t, lightness: n, alpha: r=1}) => "hsla(" + Math.round(e) + ", " + Wn.transform(fs(t)) + ", " + Wn.transform(fs(n)) + ", " + fs(gs.transform(r)) + ")"
}
  , vt = {
    test: e => xi.test(e) || vf.test(e) || to.test(e),
    parse: e => xi.test(e) ? xi.parse(e) : to.test(e) ? to.parse(e) : vf.parse(e),
    transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? xi.transform(e) : to.transform(e)
}
  , LR = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function VR(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(Uf)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(LR)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
var ly = "number"
  , cy = "color"
  , AR = "var"
  , DR = "var("
  , Ag = "${}"
  , zR = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function vs(e) {
    let t = e.toString()
      , n = []
      , r = {
        color: [],
        number: [],
        var: []
    }
      , i = []
      , o = 0
      , a = t.replace(zR, l => (vt.test(l) ? (r.color.push(o),
    i.push(cy),
    n.push(vt.parse(l))) : l.startsWith(DR) ? (r.var.push(o),
    i.push(AR),
    n.push(l)) : (r.number.push(o),
    i.push(ly),
    n.push(parseFloat(l))),
    ++o,
    Ag)).split(Ag);
    return {
        values: n,
        split: a,
        indexes: r,
        types: i
    }
}
function uy(e) {
    return vs(e).values
}
function fy(e) {
    let {split: t, types: n} = vs(e)
      , r = t.length;
    return i => {
        let o = "";
        for (let s = 0; s < r; s++)
            if (o += t[s],
            i[s] !== void 0) {
                let a = n[s];
                a === ly ? o += fs(i[s]) : a === cy ? o += vt.transform(i[s]) : o += i[s]
            }
        return o
    }
}
var BR = e => typeof e == "number" ? 0 : e;
function $R(e) {
    let t = uy(e);
    return fy(e)(t.map(BR))
}
var yr = {
    test: VR,
    parse: uy,
    createTransformer: fy,
    getAnimatableNone: $R
}
  , In = e => e * 1e3
  , Un = e => e / 1e3
  , of = .001
  , NR = .01
  , Dg = 10
  , jR = .05
  , HR = 1;
function dy({duration: e=800, bounce: t=.25, velocity: n=0, mass: r=1}) {
    let i, o;
    uo(e <= In(Dg), "Spring duration must be 10 seconds or less");
    let s = 1 - t;
    s = vr(jR, HR, s),
    e = vr(NR, Dg, Un(e)),
    s < 1 ? (i = c => {
        let u = c * s
          , f = u * e
          , d = u - n
          , p = yf(c, s)
          , v = Math.exp(-f);
        return of - d / p * v
    }
    ,
    o = c => {
        let f = c * s * e
          , d = f * n + n
          , p = Math.pow(s, 2) * Math.pow(c, 2) * e
          , v = Math.exp(-f)
          , g = yf(Math.pow(c, 2), s);
        return (-i(c) + of > 0 ? -1 : 1) * ((d - p) * v) / g
    }
    ) : (i = c => {
        let u = Math.exp(-c * e)
          , f = (c - n) * e + 1;
        return -of + u * f
    }
    ,
    o = c => {
        let u = Math.exp(-c * e)
          , f = (n - c) * (e * e);
        return u * f
    }
    );
    let a = 5 / e
      , l = UR(i, o, a);
    if (e = In(e),
    isNaN(l))
        return {
            stiffness: 100,
            damping: 10,
            duration: e
        };
    {
        let c = Math.pow(l, 2) * r;
        return {
            stiffness: c,
            damping: s * 2 * Math.sqrt(r * c),
            duration: e
        }
    }
}
var WR = 12;
function UR(e, t, n) {
    let r = n;
    for (let i = 1; i < WR; i++)
        r = r - e(r) / t(r);
    return r
}
function yf(e, t) {
    return e * Math.sqrt(1 - t * t)
}
function qf(e, t) {
    return t ? e * (1e3 / t) : 0
}
var GR = 5;
function hy(e, t, n) {
    let r = Math.max(t - GR, 0);
    return qf(n - e(r), t - r)
}
var qR = ["duration", "bounce"]
  , XR = ["stiffness", "damping", "mass"];
function zg(e, t) {
    return t.some(n => e[n] !== void 0)
}
function YR(e) {
    let t = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!zg(e, XR) && zg(e, qR)) {
        let n = dy(e);
        t = {
            ...t,
            ...n,
            mass: 1
        },
        t.isResolvedFromDuration = !0
    }
    return t
}
function ks({keyframes: e, restDelta: t, restSpeed: n, ...r}) {
    let i = e[0]
      , o = e[e.length - 1]
      , s = {
        done: !1,
        value: i
    }
      , {stiffness: a, damping: l, mass: c, duration: u, velocity: f, isResolvedFromDuration: d} = YR({
        ...r,
        velocity: -Un(r.velocity || 0)
    })
      , p = f || 0
      , v = l / (2 * Math.sqrt(a * c))
      , g = o - i
      , b = Un(Math.sqrt(a / c))
      , m = Math.abs(g) < 5;
    n || (n = m ? .01 : 2),
    t || (t = m ? .005 : .5);
    let h;
    if (v < 1) {
        let y = yf(b, v);
        h = w => {
            let C = Math.exp(-v * b * w);
            return o - C * ((p + v * b * g) / y * Math.sin(y * w) + g * Math.cos(y * w))
        }
    } else if (v === 1)
        h = y => o - Math.exp(-b * y) * (g + (p + b * g) * y);
    else {
        let y = b * Math.sqrt(v * v - 1);
        h = w => {
            let C = Math.exp(-v * b * w)
              , S = Math.min(y * w, 300);
            return o - C * ((p + v * b * g) * Math.sinh(S) + y * g * Math.cosh(S)) / y
        }
    }
    return {
        calculatedDuration: d && u || null,
        next: y => {
            let w = h(y);
            if (d)
                s.done = y >= u;
            else {
                let C = 0;
                v < 1 && (C = y === 0 ? In(p) : hy(h, y, w));
                let S = Math.abs(C) <= n
                  , T = Math.abs(o - w) <= t;
                s.done = S && T
            }
            return s.value = s.done ? o : w,
            s
        }
    }
}
function bf({keyframes: e, velocity: t=0, power: n=.8, timeConstant: r=325, bounceDamping: i=10, bounceStiffness: o=500, modifyTarget: s, min: a, max: l, restDelta: c=.5, restSpeed: u}) {
    let f = e[0]
      , d = {
        done: !1,
        value: f
    }
      , p = E => a !== void 0 && E < a || l !== void 0 && E > l
      , v = E => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l
      , g = n * t
      , b = f + g
      , m = s === void 0 ? b : s(b);
    m !== b && (g = m - f);
    let h = E => -g * Math.exp(-E / r), y = E => m + h(E), w = E => {
        let I = h(E)
          , O = y(E);
        d.done = Math.abs(I) <= c,
        d.value = d.done ? m : O
    }
    , C, S, T = E => {
        p(d.value) && (C = E,
        S = ks({
            keyframes: [d.value, v(d.value)],
            velocity: hy(y, E, d.value),
            damping: i,
            stiffness: o,
            restDelta: c,
            restSpeed: u
        }))
    }
    ;
    return T(0),
    {
        calculatedDuration: null,
        next: E => {
            let I = !1;
            return !S && C === void 0 && (I = !0,
            w(E),
            T(E)),
            C !== void 0 && E >= C ? S.next(E - C) : (!I && w(E),
            d)
        }
    }
}
var py = co(.42, 0, 1, 1)
  , my = co(0, 0, .58, 1)
  , Xf = co(.42, 0, .58, 1)
  , KR = (e, t) => n => t(e(n))
  , Gn = (...e) => e.reduce(KR)
  , br = (e, t, n) => {
    let r = t - e;
    return r === 0 ? 1 : (n - e) / r
}
  , Me = (e, t, n) => e + (t - e) * n;
function sf(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function QR({hue: e, saturation: t, lightness: n, alpha: r}) {
    e /= 360,
    t /= 100,
    n /= 100;
    let i = 0
      , o = 0
      , s = 0;
    if (!t)
        i = o = s = n;
    else {
        let a = n < .5 ? n * (1 + t) : n + t - n * t
          , l = 2 * n - a;
        i = sf(l, a, e + 1 / 3),
        o = sf(l, a, e),
        s = sf(l, a, e - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(o * 255),
        blue: Math.round(s * 255),
        alpha: r
    }
}
function nl(e, t) {
    return n => n > 0 ? t : e
}
var af = (e, t, n) => {
    let r = e * e
      , i = n * (t * t - r) + r;
    return i < 0 ? 0 : Math.sqrt(i)
}
  , ZR = [vf, xi, to]
  , JR = e => ZR.find(t => t.test(e));
function Bg(e) {
    let t = JR(e);
    if (uo(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`),
    !t)
        return !1;
    let n = t.parse(e);
    return t === to && (n = QR(n)),
    n
}
var $g = (e, t) => {
    let n = Bg(e)
      , r = Bg(t);
    if (!n || !r)
        return nl(e, t);
    let i = {
        ...n
    };
    return o => (i.red = af(n.red, r.red, o),
    i.green = af(n.green, r.green, o),
    i.blue = af(n.blue, r.blue, o),
    i.alpha = Me(n.alpha, r.alpha, o),
    xi.transform(i))
}
  , gy = e => t => typeof t == "string" && t.startsWith(e)
  , vy = gy("--")
  , eE = gy("var(--")
  , Yf = e => eE(e) ? tE.test(e.split("/*")[0].trim()) : !1
  , tE = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , xf = new Set(["none", "hidden"]);
function nE(e, t) {
    return xf.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}
function rE(e, t) {
    return n => Me(e, t, n)
}
function Kf(e) {
    return typeof e == "number" ? rE : typeof e == "string" ? Yf(e) ? nl : vt.test(e) ? $g : sE : Array.isArray(e) ? yy : typeof e == "object" ? vt.test(e) ? $g : iE : nl
}
function yy(e, t) {
    let n = [...e]
      , r = n.length
      , i = e.map( (o, s) => Kf(o)(o, t[s]));
    return o => {
        for (let s = 0; s < r; s++)
            n[s] = i[s](o);
        return n
    }
}
function iE(e, t) {
    let n = {
        ...e,
        ...t
    }
      , r = {};
    for (let i in n)
        e[i] !== void 0 && t[i] !== void 0 && (r[i] = Kf(e[i])(e[i], t[i]));
    return i => {
        for (let o in r)
            n[o] = r[o](i);
        return n
    }
}
function oE(e, t) {
    var n;
    let r = []
      , i = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let o = 0; o < t.values.length; o++) {
        let s = t.types[o]
          , a = e.indexes[s][i[s]]
          , l = (n = e.values[a]) !== null && n !== void 0 ? n : 0;
        r[o] = l,
        i[s]++
    }
    return r
}
var sE = (e, t) => {
    let n = yr.createTransformer(t)
      , r = vs(e)
      , i = vs(t);
    return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? xf.has(e) && !i.values.length || xf.has(t) && !r.values.length ? nE(e, t) : Gn(yy(oE(r, i), i.values), n) : (uo(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),
    nl(e, t))
}
;
function Qf(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Me(e, t, n) : Kf(e)(e, t)
}
function aE(e, t, n) {
    let r = []
      , i = n || Qf
      , o = e.length - 1;
    for (let s = 0; s < o; s++) {
        let a = i(e[s], e[s + 1]);
        if (t) {
            let l = Array.isArray(t) ? t[s] || yt : t;
            a = Gn(l, a)
        }
        r.push(a)
    }
    return r
}
function ho(e, t, {clamp: n=!0, ease: r, mixer: i}={}) {
    let o = e.length;
    if (Zt(o === t.length, "Both input and output ranges must be the same length"),
    o === 1)
        return () => t[0];
    if (o === 2 && e[0] === e[1])
        return () => t[1];
    e[0] > e[o - 1] && (e = [...e].reverse(),
    t = [...t].reverse());
    let s = aE(t, r, i)
      , a = s.length
      , l = c => {
        let u = 0;
        if (a > 1)
            for (; u < e.length - 2 && !(c < e[u + 1]); u++)
                ;
        let f = br(e[u], e[u + 1], c);
        return s[u](f)
    }
    ;
    return n ? c => l(vr(e[0], e[o - 1], c)) : l
}
var by = e => Array.isArray(e) && typeof e[0] != "number"
  , Zf = e => Array.isArray(e) && typeof e[0] == "number"
  , Ng = {
    linear: yt,
    easeIn: py,
    easeInOut: Xf,
    easeOut: my,
    circIn: fl,
    circInOut: Wf,
    circOut: Hf,
    backIn: ul,
    backInOut: Nf,
    backOut: $f,
    anticipate: jf
}
  , wf = e => {
    if (Zf(e)) {
        Zt(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
        let[t,n,r,i] = e;
        return co(t, n, r, i)
    } else if (typeof e == "string")
        return Zt(Ng[e] !== void 0, `Invalid easing type '${e}'`),
        Ng[e];
    return e
}
;
function xy(e, t) {
    let n = e[e.length - 1];
    for (let r = 1; r <= t; r++) {
        let i = br(0, t, r);
        e.push(Me(n, 1, i))
    }
}
function Jf(e) {
    let t = [0];
    return xy(t, e.length - 1),
    t
}
function lE(e, t) {
    return e.map(n => n * t)
}
function cE(e, t) {
    return e.map( () => t || Xf).splice(0, e.length - 1)
}
function ys({duration: e=300, keyframes: t, times: n, ease: r="easeInOut"}) {
    let i = by(r) ? r.map(wf) : wf(r)
      , o = {
        done: !1,
        value: t[0]
    }
      , s = lE(n && n.length === t.length ? n : Jf(t), e)
      , a = ho(s, t, {
        ease: Array.isArray(i) ? i : cE(t, i)
    });
    return {
        calculatedDuration: e,
        next: l => (o.value = a(l),
        o.done = l >= e,
        o)
    }
}
var Cs = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Br = new Set(Cs)
  , uE = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , jg = e => e === fo || e === Q
  , Hg = (e, t) => parseFloat(e.split(", ")[t])
  , Wg = (e, t) => (n, {transform: r}) => {
    if (r === "none" || !r)
        return 0;
    let i = r.match(/^matrix3d\((.+)\)$/u);
    if (i)
        return Hg(i[1], t);
    {
        let o = r.match(/^matrix\((.+)\)$/u);
        return o ? Hg(o[1], e) : 0
    }
}
  , fE = new Set(["x", "y", "z"])
  , dE = Cs.filter(e => !fE.has(e));
function hE(e) {
    let t = [];
    return dE.forEach(n => {
        let r = e.getValue(n);
        r !== void 0 && (t.push([n, r.get()]),
        r.set(n.startsWith("scale") ? 1 : 0))
    }
    ),
    t
}
var so = {
    width: ({x: e}, {paddingLeft: t="0", paddingRight: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({y: e}, {paddingTop: t="0", paddingBottom: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, {top: t}) => parseFloat(t),
    left: (e, {left: t}) => parseFloat(t),
    bottom: ({y: e}, {top: t}) => parseFloat(t) + (e.max - e.min),
    right: ({x: e}, {left: t}) => parseFloat(t) + (e.max - e.min),
    x: Wg(4, 13),
    y: Wg(5, 14)
};
so.translateX = so.x;
so.translateY = so.y;
var wi = new Set
  , Sf = !1
  , kf = !1;
function wy() {
    if (kf) {
        let e = Array.from(wi).filter(r => r.needsMeasurement)
          , t = new Set(e.map(r => r.element))
          , n = new Map;
        t.forEach(r => {
            let i = hE(r);
            i.length && (n.set(r, i),
            r.render())
        }
        ),
        e.forEach(r => r.measureInitialState()),
        t.forEach(r => {
            r.render();
            let i = n.get(r);
            i && i.forEach( ([o,s]) => {
                var a;
                (a = r.getValue(o)) === null || a === void 0 || a.set(s)
            }
            )
        }
        ),
        e.forEach(r => r.measureEndState()),
        e.forEach(r => {
            r.suspendedScrollY !== void 0 && P.scrollTo(0, r.suspendedScrollY)
        }
        )
    }
    kf = !1,
    Sf = !1,
    wi.forEach(e => e.complete()),
    wi.clear()
}
function Sy() {
    wi.forEach(e => {
        e.readKeyframes(),
        e.needsMeasurement && (kf = !0)
    }
    )
}
function pE() {
    Sy(),
    wy()
}
var ed = class {
    constructor(e, t, n, r, i, o=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...e],
        this.onComplete = t,
        this.name = n,
        this.motionValue = r,
        this.element = i,
        this.isAsync = o
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (wi.add(this),
        Sf || (Sf = !0,
        Z.read(Sy),
        Z.resolveKeyframes(wy))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        let {unresolvedKeyframes: e, name: t, element: n, motionValue: r} = this;
        for (let i = 0; i < e.length; i++)
            if (e[i] === null)
                if (i === 0) {
                    let o = r?.get()
                      , s = e[e.length - 1];
                    if (o !== void 0)
                        e[0] = o;
                    else if (n && t) {
                        let a = n.readValue(t, s);
                        a != null && (e[0] = a)
                    }
                    e[0] === void 0 && (e[0] = s),
                    r && o === void 0 && r.set(e[0])
                } else
                    e[i] = e[i - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        wi.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        wi.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
, Za;
function mE() {
    Za = void 0
}
var qn = {
    now: () => (Za === void 0 && qn.set(Ue.isProcessing || cl.useManualTiming ? Ue.timestamp : performance.now()),
    Za),
    set: e => {
        Za = e,
        queueMicrotask(mE)
    }
}
  , rl = {
    current: !1
};
function dl(e) {
    return typeof e == "function"
}
var Ug = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (yr.test(e) || e === "0") && !e.startsWith("url("));
function gE(e) {
    let t = e[0];
    if (e.length === 1)
        return !0;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t)
            return !0
}
function vE(e, t, n, r) {
    let i = e[0];
    if (i === null)
        return !1;
    if (t === "display" || t === "visibility")
        return !0;
    let o = e[e.length - 1]
      , s = Ug(i, t)
      , a = Ug(o, t);
    return uo(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`),
    !s || !a ? !1 : gE(e) || (n === "spring" || dl(n)) && r
}
var yE = e => e !== null;
function hl(e, {repeat: t, repeatType: n="loop"}, r) {
    let i = e.filter(yE)
      , o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
    return !o || r === void 0 ? i[o] : r
}
var bE = 40
  , ky = class {
    constructor({autoplay: e=!0, delay: t=0, type: n="keyframes", repeat: r=0, repeatDelay: i=0, repeatType: o="loop", ...s}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.createdAt = qn.now(),
        this.options = {
            autoplay: e,
            delay: t,
            type: n,
            repeat: r,
            repeatDelay: i,
            repeatType: o,
            ...s
        },
        this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > bE ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && pE(),
        this._resolved
    }
    onKeyframesResolved(e, t) {
        this.resolvedAt = qn.now(),
        this.hasAttemptedResolve = !0;
        let {name: n, type: r, velocity: i, delay: o, onComplete: s, onUpdate: a, isGenerator: l} = this.options;
        if (!l && !vE(e, n, r, i))
            if (rl.current || !o) {
                a?.(hl(e, this.options, t)),
                s?.(),
                this.resolveFinishedPromise();
                return
            } else
                this.options.duration = 0;
        let c = this.initPlayback(e, t);
        c !== !1 && (this._resolved = {
            keyframes: e,
            finalKeyframe: t,
            ...c
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(e, t) {
        return this.currentFinishedPromise.then(e, t)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(e => {
            this.resolveFinishedPromise = e
        }
        )
    }
}
  , Cf = 2e4;
function Cy(e) {
    let t = 0
      , n = 50
      , r = e.next(t);
    for (; !r.done && t < Cf; )
        t += n,
        r = e.next(t);
    return t >= Cf ? 1 / 0 : t
}
var xE = e => {
    let t = ({timestamp: n}) => e(n);
    return {
        start: () => Z.update(t, !0),
        stop: () => Lt(t),
        now: () => Ue.isProcessing ? Ue.timestamp : qn.now()
    }
}
  , wE = {
    decay: bf,
    inertia: bf,
    tween: ys,
    keyframes: ys,
    spring: ks
}
  , SE = e => e / 100
  , pl = class extends ky {
    constructor(e) {
        super(e),
        this.holdTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.startTime = null,
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            let {onStop: a} = this.options;
            a && a()
        }
        ;
        let {name: t, motionValue: n, element: r, keyframes: i} = this.options
          , o = r?.KeyframeResolver || ed
          , s = (a, l) => this.onKeyframesResolved(a, l);
        this.resolver = new o(i,s,t,n,r),
        this.resolver.scheduleResolve()
    }
    initPlayback(e) {
        let {type: t="keyframes", repeat: n=0, repeatDelay: r=0, repeatType: i, velocity: o=0} = this.options, s = dl(t) ? t : wE[t] || ys, a, l;
        s !== ys && typeof e[0] != "number" && (a = Gn(SE, Qf(e[0], e[1])),
        e = [0, 100]);
        let c = s({
            ...this.options,
            keyframes: e
        });
        i === "mirror" && (l = s({
            ...this.options,
            keyframes: [...e].reverse(),
            velocity: -o
        })),
        c.calculatedDuration === null && (c.calculatedDuration = Cy(c));
        let {calculatedDuration: u} = c
          , f = u + r
          , d = f * (n + 1) - r;
        return {
            generator: c,
            mirroredGenerator: l,
            mapPercentToKeyframes: a,
            calculatedDuration: u,
            resolvedDuration: f,
            totalDuration: d
        }
    }
    onPostResolved() {
        let {autoplay: e=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
    }
    tick(e, t=!1) {
        let {resolved: n} = this;
        if (!n) {
            let {keyframes: T} = this.options;
            return {
                done: !0,
                value: T[T.length - 1]
            }
        }
        let {finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: s, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u} = n;
        if (this.startTime === null)
            return i.next(0);
        let {delay: f, repeat: d, repeatType: p, repeatDelay: v, onUpdate: g} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)),
        t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
        let b = this.currentTime - f * (this.speed >= 0 ? 1 : -1)
          , m = this.speed >= 0 ? b < 0 : b > c;
        this.currentTime = Math.max(b, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = c);
        let h = this.currentTime
          , y = i;
        if (d) {
            let T = Math.min(this.currentTime, c) / u
              , E = Math.floor(T)
              , I = T % 1;
            !I && T >= 1 && (I = 1),
            I === 1 && E--,
            E = Math.min(E, d + 1),
            !!(E % 2) && (p === "reverse" ? (I = 1 - I,
            v && (I -= v / u)) : p === "mirror" && (y = o)),
            h = vr(0, 1, I) * u
        }
        let w = m ? {
            done: !1,
            value: a[0]
        } : y.next(h);
        s && (w.value = s(w.value));
        let {done: C} = w;
        !m && l !== null && (C = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0);
        let S = this.holdTime === null && (this.state === "finished" || this.state === "running" && C);
        return S && r !== void 0 && (w.value = hl(a, this.options, r)),
        g && g(w.value),
        S && this.finish(),
        w
    }
    get duration() {
        let {resolved: e} = this;
        return e ? Un(e.calculatedDuration) : 0
    }
    get time() {
        return Un(this.currentTime)
    }
    set time(e) {
        e = In(e),
        this.currentTime = e,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        let t = this.playbackSpeed !== e;
        this.playbackSpeed = e,
        t && (this.time = Un(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        let {driver: e=xE, onPlay: t, startTime: n} = this.options;
        this.driver || (this.driver = e(i => this.tick(i))),
        t && t();
        let r = this.driver.now();
        this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = r) : this.startTime = n ?? this.calcStartTime(),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var e;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        let {onComplete: e} = this.options;
        e && e()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0,
        this.tick(e, !0)
    }
}
;
function td(e) {
    return new pl(e)
}
var Ty = e => /^0[^.\s]+$/u.test(e);
function kE(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Ty(e) : !0
}
var Ry = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)
  , CE = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function TE(e) {
    let t = CE.exec(e);
    if (!t)
        return [, ];
    let[,n,r,i] = t;
    return [`--${n ?? r}`, i]
}
var RE = 4;
function Ey(e, t, n=1) {
    Zt(n <= RE, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
    let[r,i] = TE(e);
    if (!r)
        return;
    let o = P.getComputedStyle(t).getPropertyValue(r);
    if (o) {
        let s = o.trim();
        return Ry(s) ? parseFloat(s) : s
    }
    return Yf(i) ? Ey(i, t, n + 1) : i
}
var Fy = e => t => t.test(e)
  , EE = {
    test: e => e === "auto",
    parse: e => e
}
  , Py = [fo, Q, Wn, Dr, PR, FR, EE]
  , Gg = e => Py.find(Fy(e))
  , FE = new Set(["brightness", "contrast", "saturate", "opacity"]);
function PE(e) {
    let[t,n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow")
        return e;
    let[r] = n.match(Uf) || [];
    if (!r)
        return e;
    let i = n.replace(r, "")
      , o = FE.has(t) ? 1 : 0;
    return r !== n && (o *= 100),
    t + "(" + o + i + ")"
}
var _E = /\b([a-z-]*)\(.*?\)/gu
  , Tf = {
    ...yr,
    getAnimatableNone: e => {
        let t = e.match(_E);
        return t ? t.map(PE).join(" ") : e
    }
}
  , IE = {
    borderWidth: Q,
    borderTopWidth: Q,
    borderRightWidth: Q,
    borderBottomWidth: Q,
    borderLeftWidth: Q,
    borderRadius: Q,
    radius: Q,
    borderTopLeftRadius: Q,
    borderTopRightRadius: Q,
    borderBottomRightRadius: Q,
    borderBottomLeftRadius: Q,
    width: Q,
    maxWidth: Q,
    height: Q,
    maxHeight: Q,
    top: Q,
    right: Q,
    bottom: Q,
    left: Q,
    padding: Q,
    paddingTop: Q,
    paddingRight: Q,
    paddingBottom: Q,
    paddingLeft: Q,
    margin: Q,
    marginTop: Q,
    marginRight: Q,
    marginBottom: Q,
    marginLeft: Q,
    backgroundPositionX: Q,
    backgroundPositionY: Q
}
  , OE = {
    rotate: Dr,
    rotateX: Dr,
    rotateY: Dr,
    rotateZ: Dr,
    scale: Xa,
    scaleX: Xa,
    scaleY: Xa,
    scaleZ: Xa,
    skew: Dr,
    skewX: Dr,
    skewY: Dr,
    distance: Q,
    translateX: Q,
    translateY: Q,
    translateZ: Q,
    x: Q,
    y: Q,
    z: Q,
    perspective: Q,
    transformPerspective: Q,
    opacity: gs,
    originX: Vg,
    originY: Vg,
    originZ: Q
}
  , qg = {
    ...fo,
    transform: Math.round
}
  , nd = {
    ...IE,
    ...OE,
    zIndex: qg,
    size: Q,
    fillOpacity: gs,
    strokeOpacity: gs,
    numOctaves: qg
}
  , ME = {
    ...nd,
    color: vt,
    backgroundColor: vt,
    outlineColor: vt,
    fill: vt,
    stroke: vt,
    borderColor: vt,
    borderTopColor: vt,
    borderRightColor: vt,
    borderBottomColor: vt,
    borderLeftColor: vt,
    filter: Tf,
    WebkitFilter: Tf
}
  , rd = e => ME[e];
function _y(e, t) {
    let n = rd(e);
    return n !== Tf && (n = yr),
    n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
var LE = new Set(["auto", "none", "0"]);
function VE(e, t, n) {
    let r = 0, i;
    for (; r < e.length && !i; ) {
        let o = e[r];
        typeof o == "string" && !LE.has(o) && vs(o).values.length && (i = e[r]),
        r++
    }
    if (i && n)
        for (let o of t)
            e[o] = _y(n, i)
}
var Iy = class extends ed {
    constructor(e, t, n, r, i) {
        super(e, t, n, r, i, !0)
    }
    readKeyframes() {
        let {unresolvedKeyframes: e, element: t, name: n} = this;
        if (!t || !t.current)
            return;
        super.readKeyframes();
        for (let a = 0; a < e.length; a++) {
            let l = e[a];
            if (typeof l == "string" && (l = l.trim(),
            Yf(l))) {
                let c = Ey(l, t.current);
                c !== void 0 && (e[a] = c),
                a === e.length - 1 && (this.finalKeyframe = l)
            }
        }
        if (this.resolveNoneKeyframes(),
        !uE.has(n) || e.length !== 2)
            return;
        let[r,i] = e
          , o = Gg(r)
          , s = Gg(i);
        if (o !== s)
            if (jg(o) && jg(s))
                for (let a = 0; a < e.length; a++) {
                    let l = e[a];
                    typeof l == "string" && (e[a] = parseFloat(l))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        let {unresolvedKeyframes: e, name: t} = this
          , n = [];
        for (let r = 0; r < e.length; r++)
            kE(e[r]) && n.push(r);
        n.length && VE(e, n, t)
    }
    measureInitialState() {
        let {element: e, unresolvedKeyframes: t, name: n} = this;
        if (!e || !e.current)
            return;
        n === "height" && (this.suspendedScrollY = P.pageYOffset),
        this.measuredOrigin = so[n](e.measureViewportBox(), P.getComputedStyle(e.current)),
        t[0] = this.measuredOrigin;
        let r = t[t.length - 1];
        r !== void 0 && e.getValue(n, r).jump(r, !1)
    }
    measureEndState() {
        var e;
        let {element: t, name: n, unresolvedKeyframes: r} = this;
        if (!t || !t.current)
            return;
        let i = t.getValue(n);
        i && i.jump(this.measuredOrigin, !1);
        let o = r.length - 1
          , s = r[o];
        r[o] = so[n](t.measureViewportBox(), P.getComputedStyle(t.current)),
        s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s),
        !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach( ([a,l]) => {
            t.getValue(a).set(l)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
  , Oy = new Set(["opacity", "clipPath", "filter", "transform"])
  , AE = 10
  , DE = (e, t) => {
    let n = ""
      , r = Math.max(Math.round(t / AE), 2);
    for (let i = 0; i < r; i++)
        n += e(br(0, r - 1, i)) + ", ";
    return `linear(${n.substring(0, n.length - 2)})`
}
;
function id(e) {
    let t;
    return () => (t === void 0 && (t = e()),
    t)
}
var zE = {
    linearEasing: void 0
};
function BE(e, t) {
    let n = id(e);
    return () => {
        var r;
        return (r = zE[t]) !== null && r !== void 0 ? r : n()
    }
}
var il = BE( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing");
function My(e) {
    return !!(typeof e == "function" && il() || !e || typeof e == "string" && (e in Rf || il()) || Zf(e) || Array.isArray(e) && e.every(My))
}
var cs = ([e,t,n,r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`
  , Rf = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cs([0, .65, .55, 1]),
    circOut: cs([.55, 0, 1, .45]),
    backIn: cs([.31, .01, .66, -.59]),
    backOut: cs([.33, 1.53, .69, .99])
};
function Ly(e, t) {
    if (e)
        return typeof e == "function" && il() ? DE(e, t) : Zf(e) ? cs(e) : Array.isArray(e) ? e.map(n => Ly(n, t) || Rf.easeOut) : Rf[e]
}
function $E(e, t, n, {delay: r=0, duration: i=300, repeat: o=0, repeatType: s="loop", ease: a, times: l}={}) {
    let c = {
        [t]: n
    };
    l && (c.offset = l);
    let u = Ly(a, i);
    return Array.isArray(u) && (c.easing = u),
    e.animate(c, {
        delay: r,
        duration: i,
        easing: Array.isArray(u) ? "linear" : u,
        fill: "both",
        iterations: o + 1,
        direction: s === "reverse" ? "alternate" : "normal"
    })
}
function Xg(e, t) {
    e.timeline = t,
    e.onfinish = null
}
var NE = id( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , ol = 10
  , jE = 2e4;
function HE(e) {
    return dl(e.type) || e.type === "spring" || !My(e.ease)
}
function WE(e, t) {
    let n = new pl({
        ...t,
        keyframes: e,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    })
      , r = {
        done: !1,
        value: e[0]
    }
      , i = []
      , o = 0;
    for (; !r.done && o < jE; )
        r = n.sample(o),
        i.push(r.value),
        o += ol;
    return {
        times: void 0,
        keyframes: i,
        duration: o - ol,
        ease: "linear"
    }
}
var Vy = {
    anticipate: jf,
    backInOut: Nf,
    circInOut: Wf
};
function UE(e) {
    return e in Vy
}
var Ef = class extends ky {
    constructor(e) {
        super(e);
        let {name: t, motionValue: n, element: r, keyframes: i} = this.options;
        this.resolver = new Iy(i, (o, s) => this.onKeyframesResolved(o, s),t,n,r),
        this.resolver.scheduleResolve()
    }
    initPlayback(e, t) {
        var n;
        let {duration: r=300, times: i, ease: o, type: s, motionValue: a, name: l, startTime: c} = this.options;
        if (!(!((n = a.owner) === null || n === void 0) && n.current))
            return !1;
        if (typeof o == "string" && il() && UE(o) && (o = Vy[o]),
        HE(this.options)) {
            let {onComplete: f, onUpdate: d, motionValue: p, element: v, ...g} = this.options
              , b = WE(e, g);
            e = b.keyframes,
            e.length === 1 && (e[1] = e[0]),
            r = b.duration,
            i = b.times,
            o = b.ease,
            s = "keyframes"
        }
        let u = $E(a.owner.current, l, e, {
            ...this.options,
            duration: r,
            times: i,
            ease: o
        });
        return u.startTime = c ?? this.calcStartTime(),
        this.pendingTimeline ? (Xg(u, this.pendingTimeline),
        this.pendingTimeline = void 0) : u.onfinish = () => {
            let {onComplete: f} = this.options;
            a.set(hl(e, this.options, t)),
            f && f(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: u,
            duration: r,
            times: i,
            type: s,
            ease: o,
            keyframes: e
        }
    }
    get duration() {
        let {resolved: e} = this;
        if (!e)
            return 0;
        let {duration: t} = e;
        return Un(t)
    }
    get time() {
        let {resolved: e} = this;
        if (!e)
            return 0;
        let {animation: t} = e;
        return Un(t.currentTime || 0)
    }
    set time(e) {
        let {resolved: t} = this;
        if (!t)
            return;
        let {animation: n} = t;
        n.currentTime = In(e)
    }
    get speed() {
        let {resolved: e} = this;
        if (!e)
            return 1;
        let {animation: t} = e;
        return t.playbackRate
    }
    set speed(e) {
        let {resolved: t} = this;
        if (!t)
            return;
        let {animation: n} = t;
        n.playbackRate = e
    }
    get state() {
        let {resolved: e} = this;
        if (!e)
            return "idle";
        let {animation: t} = e;
        return t.playState
    }
    get startTime() {
        let {resolved: e} = this;
        if (!e)
            return null;
        let {animation: t} = e;
        return t.startTime
    }
    attachTimeline(e) {
        if (!this._resolved)
            this.pendingTimeline = e;
        else {
            let {resolved: t} = this;
            if (!t)
                return yt;
            let {animation: n} = t;
            Xg(n, e)
        }
        return yt
    }
    play() {
        if (this.isStopped)
            return;
        let {resolved: e} = this;
        if (!e)
            return;
        let {animation: t} = e;
        t.playState === "finished" && this.updateFinishedPromise(),
        t.play()
    }
    pause() {
        let {resolved: e} = this;
        if (!e)
            return;
        let {animation: t} = e;
        t.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        this.resolveFinishedPromise(),
        this.updateFinishedPromise();
        let {resolved: e} = this;
        if (!e)
            return;
        let {animation: t, keyframes: n, duration: r, type: i, ease: o, times: s} = e;
        if (t.playState === "idle" || t.playState === "finished")
            return;
        if (this.time) {
            let {motionValue: l, onUpdate: c, onComplete: u, element: f, ...d} = this.options
              , p = new pl({
                ...d,
                keyframes: n,
                duration: r,
                type: i,
                ease: o,
                times: s,
                isGenerator: !0
            })
              , v = In(this.time);
            l.setWithVelocity(p.sample(v - ol).value, p.sample(v).value, ol)
        }
        let {onStop: a} = this.options;
        a && a(),
        this.cancel()
    }
    complete() {
        let {resolved: e} = this;
        e && e.animation.finish()
    }
    cancel() {
        let {resolved: e} = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        let {motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s} = e;
        return NE() && n && Oy.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && s !== "inertia"
    }
}
;
function od(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}
function ml(e, t) {
    let n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
function GE([...e], t, n) {
    let r = t < 0 ? e.length + t : t;
    if (r >= 0 && r < e.length) {
        let i = n < 0 ? e.length + n : n
          , [o] = e.splice(t, 1);
        e.splice(i, 0, o)
    }
    return e
}
var sd = class {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return od(this.subscriptions, e),
        () => ml(this.subscriptions, e)
    }
    notify(e, t, n) {
        let r = this.subscriptions.length;
        if (r)
            if (r === 1)
                this.subscriptions[0](e, t, n);
            else
                for (let i = 0; i < r; i++) {
                    let o = this.subscriptions[i];
                    o && o(e, t, n)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
  , Yg = 30
  , qE = e => !isNaN(parseFloat(e))
  , ds = {
    current: void 0
}
  , gl = class {
    constructor(e, t={}) {
        this.version = "11.11.7",
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = (n, r=!0) => {
            let i = qn.now();
            this.updatedAt !== i && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(n),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(e),
        this.owner = t.owner
    }
    setCurrent(e) {
        this.current = e,
        this.updatedAt = qn.now(),
        this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = qE(this.current))
    }
    setPrevFrameValue(e=this.current) {
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new sd);
        let n = this.events[e].add(t);
        return e === "change" ? () => {
            n(),
            Z.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : n
    }
    clearListeners() {
        for (let e in this.events)
            this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e,
        this.stopPassiveEffect = t
    }
    set(e, t=!0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, n) {
        this.set(t),
        this.prev = void 0,
        this.prevFrameValue = e,
        this.prevUpdatedAt = this.updatedAt - n
    }
    jump(e, t=!0) {
        this.updateAndNotify(e),
        this.prev = e,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        t && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return ds.current && ds.current.push(this),
        this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        let e = qn.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > Yg)
            return 0;
        let t = Math.min(this.updatedAt - this.prevUpdatedAt, Yg);
        return qf(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
    }
    start(e) {
        return this.stop(),
        new Promise(t => {
            this.hasAnimated = !0,
            this.animation = e(t),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
;
function Ge(e, t) {
    return new gl(e,t)
}
var vl = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , XE = "framerAppearId"
  , yl = "data-" + vl(XE)
  , De = e => !!(e && e.getVelocity);
function Kg(e) {
    let t = [{}, {}];
    return e?.values.forEach( (n, r) => {
        t[0][r] = n.get(),
        t[1][r] = n.getVelocity()
    }
    ),
    t
}
function ad(e, t, n, r) {
    if (typeof t == "function") {
        let[i,o] = Kg(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]),
    typeof t == "function") {
        let[i,o] = Kg(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    return t
}
function bl(e, t, n) {
    let r = e.getProps();
    return ad(r, t, n !== void 0 ? n : r.custom, e)
}
var YE = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , KE = e => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , QE = {
    type: "keyframes",
    duration: .8
}
  , ZE = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , JE = (e, {keyframes: t}) => t.length > 2 ? QE : Br.has(e) ? e.startsWith("scale") ? KE(t[1]) : YE : ZE;
function ld(e, t) {
    return e ? e[t] || e.default || e : void 0
}
var Ay = id( () => P.ScrollTimeline !== void 0)
  , Dy = class {
    constructor(e) {
        this.stop = () => this.runAll("stop"),
        this.animations = e.filter(Boolean)
    }
    then(e, t) {
        return Promise.all(this.animations).then(e).catch(t)
    }
    getAll(e) {
        return this.animations[0][e]
    }
    setAll(e, t) {
        for (let n = 0; n < this.animations.length; n++)
            this.animations[n][e] = t
    }
    attachTimeline(e, t) {
        let n = this.animations.map(r => Ay() && r.attachTimeline ? r.attachTimeline(e) : t(r));
        return () => {
            n.forEach( (r, i) => {
                r && r(),
                this.animations[i].stop()
            }
            )
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(e) {
        this.setAll("time", e)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(e) {
        this.setAll("speed", e)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let e = 0;
        for (let t = 0; t < this.animations.length; t++)
            e = Math.max(e, this.animations[t].duration);
        return e
    }
    runAll(e) {
        this.animations.forEach(t => t[e]())
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
;
function eF({when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u}) {
    return !!Object.keys(u).length
}
var cd = (e, t, n, r={}, i, o) => s => {
    let a = ld(r, e) || {}
      , l = a.delay || r.delay || 0
      , {elapsed: c=0} = r;
    c = c - In(l);
    let u = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: t.getVelocity(),
        ...a,
        delay: -c,
        onUpdate: d => {
            t.set(d),
            a.onUpdate && a.onUpdate(d)
        }
        ,
        onComplete: () => {
            s(),
            a.onComplete && a.onComplete()
        }
        ,
        name: e,
        motionValue: t,
        element: o ? void 0 : i
    };
    eF(a) || (u = {
        ...u,
        ...JE(e, u)
    }),
    u.duration && (u.duration = In(u.duration)),
    u.repeatDelay && (u.repeatDelay = In(u.repeatDelay)),
    u.from !== void 0 && (u.keyframes[0] = u.from);
    let f = !1;
    if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0,
    u.delay === 0 && (f = !0)),
    (rl.current || cl.skipAnimations) && (f = !0,
    u.duration = 0,
    u.delay = 0),
    f && !o && t.get() !== void 0) {
        let d = hl(u.keyframes, a);
        if (d !== void 0)
            return Z.update( () => {
                u.onUpdate(d),
                u.onComplete()
            }
            ),
            new Dy([])
    }
    return !o && Ef.supports(u) ? new Ef(u) : new pl(u)
}
  , Ff = e => Array.isArray(e)
  , tF = e => !!(e && typeof e == "object" && e.mix && e.toValue)
  , nF = e => Ff(e) ? e[e.length - 1] || 0 : e;
function rF(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ge(n))
}
function ud(e, t) {
    let n = bl(e, t)
      , {transitionEnd: r={}, transition: i={}, ...o} = n || {};
    o = {
        ...o,
        ...r
    };
    for (let s in o) {
        let a = nF(o[s]);
        rF(e, s, a)
    }
}
function zy(e) {
    return e.props[yl]
}
function iF(e) {
    return !!(De(e) && e.add)
}
function By(e) {
    if (Br.has(e))
        return "transform";
    if (Oy.has(e))
        return vl(e)
}
function Pf(e, t) {
    var n;
    if (!e.applyWillChange)
        return;
    let r = e.getValue("willChange");
    if (iF(r))
        return r.add(t);
    !(!((n = e.props.style) === null || n === void 0) && n.willChange) && By(t) && e.setStaticValue("willChange", "transform")
}
function oF({protectedKeys: e, needsAnimating: t}, n) {
    let r = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1,
    r
}
function fd(e, t, {delay: n=0, transitionOverride: r, type: i}={}) {
    var o;
    let {transition: s=e.getDefaultTransition(), transitionEnd: a, ...l} = t;
    r && (s = r);
    let c = []
      , u = i && e.animationState && e.animationState.getState()[i];
    for (let f in l) {
        let d = e.getValue(f, (o = e.latestValues[f]) !== null && o !== void 0 ? o : null)
          , p = l[f];
        if (p === void 0 || u && oF(u, f))
            continue;
        let v = {
            delay: n,
            ...ld(s || {}, f)
        }
          , g = !1;
        if (P.MotionHandoffAnimation) {
            let m = zy(e);
            if (m) {
                let h = P.MotionHandoffAnimation(m, f, Z);
                h !== null && (v.startTime = h,
                g = !0)
            }
        }
        Pf(e, f),
        d.start(cd(f, d, p, e.shouldReduceMotion && Br.has(f) ? {
            type: !1
        } : v, e, g));
        let b = d.animation;
        b && c.push(b)
    }
    return a && Promise.all(c).then( () => {
        Z.update( () => {
            a && ud(e, a)
        }
        )
    }
    ),
    c
}
function _f(e, t, n={}) {
    var r;
    let i = bl(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0)
      , {transition: o=e.getDefaultTransition() || {}} = i || {};
    n.transitionOverride && (o = n.transitionOverride);
    let s = i ? () => Promise.all(fd(e, i, n)) : () => Promise.resolve()
      , a = e.variantChildren && e.variantChildren.size ? (c=0) => {
        let {delayChildren: u=0, staggerChildren: f, staggerDirection: d} = o;
        return sF(e, t, u + c, f, d, n)
    }
    : () => Promise.resolve()
      , {when: l} = o;
    if (l) {
        let[c,u] = l === "beforeChildren" ? [s, a] : [a, s];
        return c().then( () => u())
    } else
        return Promise.all([s(), a(n.delay)])
}
function sF(e, t, n=0, r=0, i=1, o) {
    let s = []
      , a = (e.variantChildren.size - 1) * r
      , l = i === 1 ? (c=0) => c * r : (c=0) => a - c * r;
    return Array.from(e.variantChildren).sort(aF).forEach( (c, u) => {
        c.notify("AnimationStart", t),
        s.push(_f(c, t, {
            ...o,
            delay: n + l(u)
        }).then( () => c.notify("AnimationComplete", t)))
    }
    ),
    Promise.all(s)
}
function aF(e, t) {
    return e.sortNodePosition(t)
}
function dd(e, t, n={}) {
    e.notify("AnimationStart", t);
    let r;
    if (Array.isArray(t)) {
        let i = t.map(o => _f(e, o, n));
        r = Promise.all(i)
    } else if (typeof t == "string")
        r = _f(e, t, n);
    else {
        let i = typeof t == "function" ? bl(e, t, n.custom) : t;
        r = Promise.all(fd(e, i, n))
    }
    return r.then( () => {
        e.notify("AnimationComplete", t)
    }
    )
}
function bs(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
}
function $y(e, t) {
    if (!Array.isArray(t))
        return !1;
    let n = t.length;
    if (n !== e.length)
        return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function xs(e) {
    return typeof e == "string" || Array.isArray(e)
}
var hd = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , pd = ["initial", ...hd]
  , lF = pd.length;
function Ny(e) {
    if (!e)
        return;
    if (!e.isControllingVariants) {
        let n = e.parent ? Ny(e.parent) || {} : {};
        return e.props.initial !== void 0 && (n.initial = e.props.initial),
        n
    }
    let t = {};
    for (let n = 0; n < lF; n++) {
        let r = pd[n]
          , i = e.props[r];
        (xs(i) || i === !1) && (t[r] = i)
    }
    return t
}
var cF = [...hd].reverse()
  , uF = hd.length;
function fF(e) {
    return t => Promise.all(t.map( ({animation: n, options: r}) => dd(e, n, r)))
}
function dF(e) {
    let t = fF(e)
      , n = Qg()
      , r = !0
      , i = l => (c, u) => {
        var f;
        let d = bl(e, u, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0);
        if (d) {
            let {transition: p, transitionEnd: v, ...g} = d;
            c = {
                ...c,
                ...g,
                ...v
            }
        }
        return c
    }
    ;
    function o(l) {
        t = l(e)
    }
    function s(l) {
        let {props: c} = e
          , u = Ny(e.parent) || {}
          , f = []
          , d = new Set
          , p = {}
          , v = 1 / 0;
        for (let b = 0; b < uF; b++) {
            let m = cF[b]
              , h = n[m]
              , y = c[m] !== void 0 ? c[m] : u[m]
              , w = xs(y)
              , C = m === l ? h.isActive : null;
            C === !1 && (v = b);
            let S = y === u[m] && y !== c[m] && w;
            if (S && r && e.manuallyAnimateOnMount && (S = !1),
            h.protectedKeys = {
                ...p
            },
            !h.isActive && C === null || !y && !h.prevProp || bs(y) || typeof y == "boolean")
                continue;
            let T = hF(h.prevProp, y)
              , E = T || m === l && h.isActive && !S && w || b > v && w
              , I = !1
              , O = Array.isArray(y) ? y : [y]
              , B = O.reduce(i(m), {});
            C === !1 && (B = {});
            let {prevResolvedValues: z={}} = h
              , j = {
                ...z,
                ...B
            }
              , J = ie => {
                E = !0,
                d.has(ie) && (I = !0,
                d.delete(ie)),
                h.needsAnimating[ie] = !0;
                let q = e.getValue(ie);
                q && (q.liveStyle = !1)
            }
            ;
            for (let ie in j) {
                let q = B[ie]
                  , re = z[ie];
                if (p.hasOwnProperty(ie))
                    continue;
                let U = !1;
                Ff(q) && Ff(re) ? U = !$y(q, re) : U = q !== re,
                U ? q != null ? J(ie) : d.add(ie) : q !== void 0 && d.has(ie) ? J(ie) : h.protectedKeys[ie] = !0
            }
            h.prevProp = y,
            h.prevResolvedValues = B,
            h.isActive && (p = {
                ...p,
                ...B
            }),
            r && e.blockInitialAnimation && (E = !1),
            E && (!(S && T) || I) && f.push(...O.map(ie => ({
                animation: ie,
                options: {
                    type: m
                }
            })))
        }
        if (d.size) {
            let b = {};
            d.forEach(m => {
                let h = e.getBaseTarget(m)
                  , y = e.getValue(m);
                y && (y.liveStyle = !0),
                b[m] = h ?? null
            }
            ),
            f.push({
                animation: b
            })
        }
        let g = !!f.length;
        return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1),
        r = !1,
        g ? t(f) : Promise.resolve()
    }
    function a(l, c) {
        var u;
        if (n[l].isActive === c)
            return Promise.resolve();
        (u = e.variantChildren) === null || u === void 0 || u.forEach(d => {
            var p;
            return (p = d.animationState) === null || p === void 0 ? void 0 : p.setActive(l, c)
        }
        ),
        n[l].isActive = c;
        let f = s(l);
        for (let d in n)
            n[d].protectedKeys = {};
        return f
    }
    return {
        animateChanges: s,
        setActive: a,
        setAnimateFunction: o,
        getState: () => n,
        reset: () => {
            n = Qg(),
            r = !0
        }
    }
}
function hF(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !$y(t, e) : !1
}
function vi(e=!1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function Qg() {
    return {
        animate: vi(!0),
        whileInView: vi(),
        whileHover: vi(),
        whileTap: vi(),
        whileDrag: vi(),
        whileFocus: vi(),
        exit: vi()
    }
}
var $r = class {
    constructor(e) {
        this.isMounted = !1,
        this.node = e
    }
    update() {}
}
  , pF = class extends $r {
    constructor(e) {
        super(e),
        e.animationState || (e.animationState = dF(e))
    }
    updateAnimationControlsSubscription() {
        let {animate: e} = this.node.getProps();
        bs(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        let {animate: e} = this.node.getProps()
          , {animate: t} = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(),
        (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
}
  , mF = 0
  , gF = class extends $r {
    constructor() {
        super(...arguments),
        this.id = mF++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        let {isPresent: e, onExitComplete: t} = this.node.presenceContext
          , {isPresent: n} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === n)
            return;
        let r = this.node.animationState.setActive("exit", !e);
        t && !e && r.then( () => t(this.id))
    }
    mount() {
        let {register: e} = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
  , xl = {
    animation: {
        Feature: pF
    },
    exit: {
        Feature: gF
    }
}
  , jy = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function wl(e, t="page") {
    return {
        point: {
            x: e[`${t}X`],
            y: e[`${t}Y`]
        }
    }
}
var Hy = e => t => jy(t) && e(t, wl(t));
function gr(e, t, n, r={
    passive: !0
}) {
    return e.addEventListener(t, n, r),
    () => e.removeEventListener(t, n)
}
function Xn(e, t, n, r) {
    return gr(e, t, Hy(n), r)
}
var If = (e, t) => Math.abs(e - t);
function Wy(e, t) {
    let n = If(e.x, t.x)
      , r = If(e.y, t.y);
    return Math.sqrt(n ** 2 + r ** 2)
}
function Uy(e) {
    let t = null;
    return () => {
        let n = () => {
            t = null
        }
        ;
        return t === null ? (t = e,
        n) : !1
    }
}
var Zg = Uy("dragHorizontal")
  , Jg = Uy("dragVertical");
function Gy(e) {
    let t = !1;
    if (e === "y")
        t = Jg();
    else if (e === "x")
        t = Zg();
    else {
        let n = Zg()
          , r = Jg();
        n && r ? t = () => {
            n(),
            r()
        }
        : (n && n(),
        r && r())
    }
    return t
}
function md() {
    let e = Gy(!0);
    return e ? (e(),
    !1) : !0
}
var qy = 1e-4
  , vF = 1 - qy
  , yF = 1 + qy
  , Xy = .01
  , bF = 0 - Xy
  , xF = 0 + Xy;
function jt(e) {
    return e.max - e.min
}
function wF(e, t, n) {
    return Math.abs(e - t) <= n
}
function ev(e, t, n, r=.5) {
    e.origin = r,
    e.originPoint = Me(t.min, t.max, e.origin),
    e.scale = jt(n) / jt(t),
    e.translate = Me(n.min, n.max, e.origin) - e.originPoint,
    (e.scale >= vF && e.scale <= yF || isNaN(e.scale)) && (e.scale = 1),
    (e.translate >= bF && e.translate <= xF || isNaN(e.translate)) && (e.translate = 0)
}
function hs(e, t, n, r) {
    ev(e.x, t.x, n.x, r ? r.originX : void 0),
    ev(e.y, t.y, n.y, r ? r.originY : void 0)
}
function tv(e, t, n) {
    e.min = n.min + t.min,
    e.max = e.min + jt(t)
}
function SF(e, t, n) {
    tv(e.x, t.x, n.x),
    tv(e.y, t.y, n.y)
}
function nv(e, t, n) {
    e.min = t.min - n.min,
    e.max = e.min + jt(t)
}
function ps(e, t, n) {
    nv(e.x, t.x, n.x),
    nv(e.y, t.y, n.y)
}
var rv = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , no = () => ({
    x: rv(),
    y: rv()
})
  , iv = () => ({
    min: 0,
    max: 0
})
  , Be = () => ({
    x: iv(),
    y: iv()
})
  , po = ve(null);
function gd() {
    let e = D(po);
    if (e === null)
        return [!0, null];
    let {isPresent: t, onExitComplete: n, register: r} = e
      , i = gi();
    $( () => r(i), []);
    let o = K( () => n && n(i), [i, n]);
    return !t && n ? [!1, o] : [!0]
}
var ws = ve({})
  , Sl = ve({})
  , sl = {};
function vd(e) {
    Object.assign(sl, e)
}
var kF = (e, t) => e.depth - t.depth
  , Yy = class {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(e) {
        od(this.children, e),
        this.isDirty = !0
    }
    remove(e) {
        ml(this.children, e),
        this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(kF),
        this.isDirty = !1,
        this.children.forEach(e)
    }
}
;
function Ct(e) {
    let t = De(e) ? e.get() : e;
    return tF(t) ? t.toValue() : t
}
function Ky(e, t) {
    let n = qn.now()
      , r = ({timestamp: i}) => {
        let o = i - n;
        o >= t && (Lt(r),
        e(o - t))
    }
    ;
    return Z.read(r, !0),
    () => Lt(r)
}
var xr = ve({
    transformPagePoint: e => e,
    isStatic: !1,
    reducedMotion: "never"
})
  , Ts = ve({})
  , kl = typeof P < "u"
  , Nr = kl ? Ae : $
  , Qy = ve({
    strict: !1
})
  , {schedule: yd, cancel: $$} = oy(queueMicrotask, !1);
function ro(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}
function CF(e, t, n, r, i) {
    var o, s;
    let {visualElement: a} = D(Ts)
      , l = D(Qy)
      , c = D(po)
      , u = D(xr).reducedMotion
      , f = V();
    r = r || l.renderer,
    !f.current && r && (f.current = r(e, {
        visualState: t,
        parent: a,
        props: n,
        presenceContext: c,
        blockInitialAnimation: c ? c.initial === !1 : !1,
        reducedMotionConfig: u
    }));
    let d = f.current
      , p = D(Sl);
    d && !d.projection && i && (d.type === "html" || d.type === "svg") && TF(f.current, n, i, p),
    ct( () => {
        d && d.update(n, c)
    }
    );
    let v = n[yl]
      , g = V(!!v && !(!((o = P.MotionHandoffIsComplete) === null || o === void 0) && o.call(P, v)) && ((s = P.MotionHasOptimisedAnimation) === null || s === void 0 ? void 0 : s.call(P, v)));
    return Nr( () => {
        d && (P.MotionIsMounted = !0,
        d.updateFeatures(),
        yd.render(d.render),
        g.current && d.animationState && d.animationState.animateChanges())
    }
    ),
    $( () => {
        d && (!g.current && d.animationState && d.animationState.animateChanges(),
        g.current && (queueMicrotask( () => {
            var b;
            (b = P.MotionHandoffMarkAsComplete) === null || b === void 0 || b.call(P, v)
        }
        ),
        g.current = !1))
    }
    ),
    d
}
function TF(e, t, n, r) {
    let {layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c} = t;
    e.projection = new n(e.latestValues,t["data-framer-portal-id"] ? void 0 : Zy(e.parent)),
    e.projection.setOptions({
        layoutId: i,
        layout: o,
        alwaysMeasureLayout: !!s || a && ro(a),
        visualElement: e,
        animationType: typeof o == "string" ? o : "both",
        initialPromotionConfig: r,
        layoutScroll: l,
        layoutRoot: c
    })
}
function Zy(e) {
    if (e)
        return e.options.allowProjection !== !1 ? e.projection : Zy(e.parent)
}
function RF(e, t, n) {
    return K(r => {
        r && e.mount && e.mount(r),
        t && (r ? t.mount(r) : t.unmount()),
        n && (typeof n == "function" ? n(r) : ro(n) && (n.current = r))
    }
    , [t])
}
function Cl(e) {
    return bs(e.animate) || pd.some(t => xs(e[t]))
}
function Jy(e) {
    return !!(Cl(e) || e.variants)
}
function EF(e, t) {
    if (Cl(e)) {
        let {initial: n, animate: r} = e;
        return {
            initial: n === !1 || xs(n) ? n : void 0,
            animate: xs(r) ? r : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}
function FF(e) {
    let {initial: t, animate: n} = EF(e, D(Ts));
    return se( () => ({
        initial: t,
        animate: n
    }), [ov(t), ov(n)])
}
function ov(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
var sv = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , ao = {};
for (let e in sv)
    ao[e] = {
        isEnabled: t => sv[e].some(n => !!t[n])
    };
function PF(e) {
    for (let t in e)
        ao[t] = {
            ...ao[t],
            ...e[t]
        }
}
var bd = Symbol.for("motionComponentSymbol");
function e0({preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i}) {
    e && PF(e);
    function o(a, l) {
        let c, u = {
            ...D(xr),
            ...a,
            layoutId: _F(a)
        }, {isStatic: f} = u, d = FF(a), p = r(a, f);
        if (!f && kl) {
            IF(u, e);
            let v = OF(u);
            c = v.MeasureLayout,
            d.visualElement = CF(i, p, u, t, v.ProjectionNode)
        }
        return he(Ts.Provider, {
            value: d,
            children: [c && d.visualElement ? k(c, {
                visualElement: d.visualElement,
                ...u
            }) : null, n(i, a, RF(p, d.visualElement, l), p, f, d.visualElement)]
        })
    }
    let s = Ie(o);
    return s[bd] = i,
    s
}
function _F({layoutId: e}) {
    let t = D(ws).id;
    return t && e !== void 0 ? t + "-" + e : e
}
function IF(e, t) {
    let n = D(Qy).strict
}
function OF(e) {
    let {drag: t, layout: n} = ao;
    if (!t && !n)
        return {};
    let r = {
        ...t,
        ...n
    };
    return {
        MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0,
        ProjectionNode: r.ProjectionNode
    }
}
function Kn(e) {
    let t = V(null);
    return t.current === null && (t.current = e()),
    t.current
}
function MF({applyWillChange: e=!1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r}, i, o, s, a) {
    let l = {
        latestValues: LF(i, o, s, a ? !1 : e, t),
        renderState: n()
    };
    return r && (l.mount = c => r(i, c, l)),
    l
}
var Tl = e => (t, n) => {
    let r = D(Ts)
      , i = D(po)
      , o = () => MF(e, t, r, i, n);
    return n ? o() : Kn(o)
}
;
function av(e, t, n) {
    let r = Array.isArray(t) ? t : [t];
    for (let i = 0; i < r.length; i++) {
        let o = ad(e, r[i]);
        if (o) {
            let {transitionEnd: s, transition: a, ...l} = o;
            n(l, s)
        }
    }
}
function LF(e, t, n, r, i) {
    var o;
    let s = {}
      , a = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0
      , l = i(e, {});
    for (let g in l)
        s[g] = Ct(l[g]);
    let {initial: c, animate: u} = e
      , f = Cl(e)
      , d = Jy(e);
    t && d && !f && e.inherit !== !1 && (c === void 0 && (c = t.initial),
    u === void 0 && (u = t.animate));
    let p = n ? n.initial === !1 : !1;
    p = p || c === !1;
    let v = p ? u : c;
    return v && typeof v != "boolean" && !bs(v) && av(e, v, (g, b) => {
        for (let m in g) {
            let h = g[m];
            if (Array.isArray(h)) {
                let y = p ? h.length - 1 : 0;
                h = h[y]
            }
            h !== null && (s[m] = h)
        }
        for (let m in b)
            s[m] = b[m]
    }
    ),
    a && u && c !== !1 && !bs(u) && av(e, u, g => {
        for (let b in g)
            if (By(b)) {
                s.willChange = "transform";
                return
            }
    }
    ),
    s
}
var t0 = (e, t) => t && typeof e == "number" ? t.transform(e) : e
  , VF = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , AF = Cs.length;
function n0(e, t, n) {
    let r = ""
      , i = !0;
    for (let o = 0; o < AF; o++) {
        let s = Cs[o]
          , a = e[s];
        if (a === void 0)
            continue;
        let l = !0;
        if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0,
        !l || n) {
            let c = t0(a, nd[s]);
            if (!l) {
                i = !1;
                let u = VF[s] || s;
                r += `${u}(${c}) `
            }
            n && (t[s] = c)
        }
    }
    return r = r.trim(),
    n ? r = n(t, i ? "" : r) : i && (r = "none"),
    r
}
var DF = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function lo(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || DF.has(e)
}
var r0 = e => !lo(e);
function i0(e) {
    e && (r0 = t => t.startsWith("on") ? !lo(t) : e(t))
}
try {
    i0(SR().default)
} catch {}
function o0(e, t, n) {
    let r = {};
    for (let i in e)
        i === "values" && typeof e.values == "object" || (r0(i) || n === !0 && lo(i) || !t && !lo(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
    return r
}
var Yn = new WeakMap
  , al = {
    current: null
}
  , xd = {
    current: !1
};
function s0() {
    if (xd.current = !0,
    !!kl)
        if (P.matchMedia) {
            let e = P.matchMedia("(prefers-reduced-motion)")
              , t = () => al.current = e.matches;
            e.addListener(t),
            t()
        } else
            al.current = !1
}
function zF(e, t, n) {
    for (let r in t) {
        let i = t[r]
          , o = n[r];
        if (De(i))
            e.addValue(r, i);
        else if (De(o))
            e.addValue(r, Ge(i, {
                owner: e
            }));
        else if (o !== i)
            if (e.hasValue(r)) {
                let s = e.getValue(r);
                s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i)
            } else {
                let s = e.getStaticValue(r);
                e.addValue(r, Ge(s !== void 0 ? s : i, {
                    owner: e
                }))
            }
    }
    for (let r in n)
        t[r] === void 0 && e.removeValue(r);
    return t
}
var BF = [...Py, vt, yr]
  , $F = e => BF.find(Fy(e))
  , lv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , wd = class {
    scrapeMotionValuesFromProps(e, t, n) {
        return {}
    }
    constructor({parent: e, props: t, presenceContext: n, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o}, s={}) {
        this.applyWillChange = !1,
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = ed,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            let f = qn.now();
            this.renderScheduledAt < f && (this.renderScheduledAt = f,
            Z.render(this.render, !1, !0))
        }
        ;
        let {latestValues: a, renderState: l} = o;
        this.latestValues = a,
        this.baseTarget = {
            ...a
        },
        this.initialValues = t.initial ? {
            ...a
        } : {},
        this.renderState = l,
        this.parent = e,
        this.props = t,
        this.presenceContext = n,
        this.depth = e ? e.depth + 1 : 0,
        this.reducedMotionConfig = r,
        this.options = s,
        this.blockInitialAnimation = !!i,
        this.isControllingVariants = Cl(t),
        this.isVariantNode = Jy(t),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(e && e.current);
        let {willChange: c, ...u} = this.scrapeMotionValuesFromProps(t, {}, this);
        for (let f in u) {
            let d = u[f];
            a[f] !== void 0 && De(d) && d.set(a[f], !1)
        }
    }
    mount(e) {
        this.current = e,
        Yn.set(e, this),
        this.projection && !this.projection.instance && this.projection.mount(e),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (t, n) => this.bindToMotionValue(n, t)),
        xd.current || s0(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : al.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        Yn.delete(this.current),
        this.projection && this.projection.unmount(),
        Lt(this.notifyUpdate),
        Lt(this.render),
        this.valueSubscriptions.forEach(e => e()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (let e in this.events)
            this.events[e].clear();
        for (let e in this.features) {
            let t = this.features[e];
            t && (t.unmount(),
            t.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, t) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        let n = Br.has(e), r = t.on("change", s => {
            this.latestValues[e] = s,
            this.props.onUpdate && Z.preRender(this.notifyUpdate),
            n && this.projection && (this.projection.isTransformDirty = !0)
        }
        ), i = t.on("renderRequest", this.scheduleRender), o;
        P.MotionCheckAppearSync && (o = P.MotionCheckAppearSync(this, e, t)),
        this.valueSubscriptions.set(e, () => {
            r(),
            i(),
            o && o(),
            t.owner && t.stop()
        }
        )
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in ao) {
            let t = ao[e];
            if (!t)
                continue;
            let {isEnabled: n, Feature: r} = t;
            if (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)),
            this.features[e]) {
                let i = this.features[e];
                i.isMounted ? i.update() : (i.mount(),
                i.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Be()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = e,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = t;
        for (let n = 0; n < lv.length; n++) {
            let r = lv[n];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](),
            delete this.propEventSubscriptions[r]);
            let i = "on" + r
              , o = e[i];
            o && (this.propEventSubscriptions[r] = this.on(r, o))
        }
        this.prevMotionValues = zF(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        let t = this.getClosestVariantNode();
        if (t)
            return t.variantChildren && t.variantChildren.add(e),
            () => t.variantChildren.delete(e)
    }
    addValue(e, t) {
        let n = this.values.get(e);
        t !== n && (n && this.removeValue(e),
        this.bindToMotionValue(e, t),
        this.values.set(e, t),
        this.latestValues[e] = t.get())
    }
    removeValue(e) {
        this.values.delete(e);
        let t = this.valueSubscriptions.get(e);
        t && (t(),
        this.valueSubscriptions.delete(e)),
        delete this.latestValues[e],
        this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e])
            return this.props.values[e];
        let n = this.values.get(e);
        return n === void 0 && t !== void 0 && (n = Ge(t === null ? void 0 : t, {
            owner: this
        }),
        this.addValue(e, n)),
        n
    }
    readValue(e, t) {
        var n;
        let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
        return r != null && (typeof r == "string" && (Ry(r) || Ty(r)) ? r = parseFloat(r) : !$F(r) && yr.test(t) && (r = _y(e, t)),
        this.setBaseTarget(e, De(r) ? r.get() : r)),
        De(r) ? r.get() : r
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var t;
        let {initial: n} = this.props, r;
        if (typeof n == "string" || typeof n == "object") {
            let o = ad(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom);
            o && (r = o[e])
        }
        if (n && r !== void 0)
            return r;
        let i = this.getBaseTargetFromProps(this.props, e);
        return i !== void 0 && !De(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new sd),
        this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
;
function NF(e) {
    if (typeof Proxy > "u")
        return e;
    let t = new Map
      , n = (...r) => e(...r);
    return new Proxy(n,{
        get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)),
        t.get(i))
    })
}
var a0 = class {
    constructor(e, t, {transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = P,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            let u = cf(this.lastMoveEventInfo, this.history)
              , f = this.startEvent !== null
              , d = Wy(u.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!f && !d)
                return;
            let {point: p} = u
              , {timestamp: v} = Ue;
            this.history.push({
                ...p,
                timestamp: v
            });
            let {onStart: g, onMove: b} = this.handlers;
            f || (g && g(this.lastMoveEvent, u),
            this.startEvent = this.lastMoveEvent),
            b && b(this.lastMoveEvent, u)
        }
        ,
        this.handlePointerMove = (u, f) => {
            this.lastMoveEvent = u,
            this.lastMoveEventInfo = lf(f, this.transformPagePoint),
            Z.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (u, f) => {
            this.end();
            let {onEnd: d, onSessionEnd: p, resumeAnimation: v} = this.handlers;
            if (this.dragSnapToOrigin && v && v(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            let g = cf(u.type === "pointercancel" ? this.lastMoveEventInfo : lf(f, this.transformPagePoint), this.history);
            this.startEvent && d && d(u, g),
            p && p(u, g)
        }
        ,
        !jy(e))
            return;
        this.dragSnapToOrigin = i,
        this.handlers = t,
        this.transformPagePoint = n,
        this.contextWindow = r || P;
        let o = wl(e)
          , s = lf(o, this.transformPagePoint)
          , {point: a} = s
          , {timestamp: l} = Ue;
        this.history = [{
            ...a,
            timestamp: l
        }];
        let {onSessionStart: c} = t;
        c && c(e, cf(s, this.history)),
        this.removeListeners = Gn(Xn(this.contextWindow, "pointermove", this.handlePointerMove), Xn(this.contextWindow, "pointerup", this.handlePointerUp), Xn(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(),
        Lt(this.updatePoint)
    }
}
;
function lf(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}
function cv(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}
function cf({point: e}, t) {
    return {
        point: e,
        delta: cv(e, l0(t)),
        offset: cv(e, jF(t)),
        velocity: HF(t, .1)
    }
}
function jF(e) {
    return e[0]
}
function l0(e) {
    return e[e.length - 1]
}
function HF(e, t) {
    if (e.length < 2)
        return {
            x: 0,
            y: 0
        };
    let n = e.length - 1
      , r = null
      , i = l0(e);
    for (; n >= 0 && (r = e[n],
    !(i.timestamp - r.timestamp > In(t))); )
        n--;
    if (!r)
        return {
            x: 0,
            y: 0
        };
    let o = Un(i.timestamp - r.timestamp);
    if (o === 0)
        return {
            x: 0,
            y: 0
        };
    let s = {
        x: (i.x - r.x) / o,
        y: (i.y - r.y) / o
    };
    return s.x === 1 / 0 && (s.x = 0),
    s.y === 1 / 0 && (s.y = 0),
    s
}
function WF(e, {min: t, max: n}, r) {
    return t !== void 0 && e < t ? e = r ? Me(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Me(n, e, r.max) : Math.min(e, n)),
    e
}
function uv(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}
function UF(e, {top: t, left: n, bottom: r, right: i}) {
    return {
        x: uv(e.x, n, i),
        y: uv(e.y, t, r)
    }
}
function fv(e, t) {
    let n = t.min - e.min
      , r = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n,r] = [r, n]),
    {
        min: n,
        max: r
    }
}
function GF(e, t) {
    return {
        x: fv(e.x, t.x),
        y: fv(e.y, t.y)
    }
}
function qF(e, t) {
    let n = .5
      , r = jt(e)
      , i = jt(t);
    return i > r ? n = br(t.min, t.max - r, e.min) : r > i && (n = br(e.min, e.max - i, t.min)),
    vr(0, 1, n)
}
function XF(e, t) {
    let n = {};
    return t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
}
var Of = .35;
function YF(e=Of) {
    return e === !1 ? e = 0 : e === !0 && (e = Of),
    {
        x: dv(e, "left", "right"),
        y: dv(e, "top", "bottom")
    }
}
function dv(e, t, n) {
    return {
        min: hv(e, t),
        max: hv(e, n)
    }
}
function hv(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
function yn(e) {
    return [e("x"), e("y")]
}
function c0({top: e, left: t, right: n, bottom: r}) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: r
        }
    }
}
function KF({x: e, y: t}) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}
function QF(e, t) {
    if (!t)
        return e;
    let n = t({
        x: e.left,
        y: e.top
    })
      , r = t({
        x: e.right,
        y: e.bottom
    });
    return {
        top: n.y,
        left: n.x,
        bottom: r.y,
        right: r.x
    }
}
function uf(e) {
    return e === void 0 || e === 1
}
function Mf({scale: e, scaleX: t, scaleY: n}) {
    return !uf(e) || !uf(t) || !uf(n)
}
function yi(e) {
    return Mf(e) || u0(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}
function u0(e) {
    return pv(e.x) || pv(e.y)
}
function pv(e) {
    return e && e !== "0%"
}
function ll(e, t, n) {
    let r = e - n
      , i = t * r;
    return n + i
}
function mv(e, t, n, r, i) {
    return i !== void 0 && (e = ll(e, i, r)),
    ll(e, n, r) + t
}
function Lf(e, t=0, n=1, r, i) {
    e.min = mv(e.min, t, n, r, i),
    e.max = mv(e.max, t, n, r, i)
}
function f0(e, {x: t, y: n}) {
    Lf(e.x, t.translate, t.scale, t.originPoint),
    Lf(e.y, n.translate, n.scale, n.originPoint)
}
var gv = .999999999999
  , vv = 1.0000000000001;
function ZF(e, t, n, r=!1) {
    let i = n.length;
    if (!i)
        return;
    t.x = t.y = 1;
    let o, s;
    for (let a = 0; a < i; a++) {
        o = n[a],
        s = o.projectionDelta;
        let {visualElement: l} = o.options;
        l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && oo(e, {
            x: -o.scroll.offset.x,
            y: -o.scroll.offset.y
        }),
        s && (t.x *= s.x.scale,
        t.y *= s.y.scale,
        f0(e, s)),
        r && yi(o.latestValues) && oo(e, o.latestValues))
    }
    t.x < vv && t.x > gv && (t.x = 1),
    t.y < vv && t.y > gv && (t.y = 1)
}
function io(e, t) {
    e.min = e.min + t,
    e.max = e.max + t
}
function yv(e, t, n, r, i=.5) {
    let o = Me(e.min, e.max, i);
    Lf(e, t, n, o, r)
}
function oo(e, t) {
    yv(e.x, t.x, t.scaleX, t.scale, t.originX),
    yv(e.y, t.y, t.scaleY, t.scale, t.originY)
}
function d0(e, t) {
    return c0(QF(e.getBoundingClientRect(), t))
}
function JF(e, t, n) {
    let r = d0(e, n)
      , {scroll: i} = t;
    return i && (io(r.x, i.offset.x),
    io(r.y, i.offset.y)),
    r
}
var h0 = ({current: e}) => e ? e.ownerDocument.defaultView : null
  , eP = new WeakMap
  , tP = class {
    constructor(e) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Be(),
        this.visualElement = e
    }
    start(e, {snapToCursor: t=!1}={}) {
        let {presenceContext: n} = this.visualElement;
        if (n && n.isPresent === !1)
            return;
        let r = c => {
            let {dragSnapToOrigin: u} = this.getProps();
            u ? this.pauseAnimation() : this.stopAnimation(),
            t && this.snapToCursor(wl(c, "page").point)
        }
          , i = (c, u) => {
            let {drag: f, dragPropagation: d, onDragStart: p} = this.getProps();
            if (f && !d && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = Gy(f),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            yn(g => {
                let b = this.getAxisMotionValue(g).get() || 0;
                if (Wn.test(b)) {
                    let {projection: m} = this.visualElement;
                    if (m && m.layout) {
                        let h = m.layout.layoutBox[g];
                        h && (b = jt(h) * (parseFloat(b) / 100))
                    }
                }
                this.originPoint[g] = b
            }
            ),
            p && Z.postRender( () => p(c, u)),
            Pf(this.visualElement, "transform");
            let {animationState: v} = this.visualElement;
            v && v.setActive("whileDrag", !0)
        }
          , o = (c, u) => {
            let {dragPropagation: f, dragDirectionLock: d, onDirectionLock: p, onDrag: v} = this.getProps();
            if (!f && !this.openGlobalLock)
                return;
            let {offset: g} = u;
            if (d && this.currentDirection === null) {
                this.currentDirection = nP(g),
                this.currentDirection !== null && p && p(this.currentDirection);
                return
            }
            this.updateAxis("x", u.point, g),
            this.updateAxis("y", u.point, g),
            this.visualElement.render(),
            v && v(c, u)
        }
          , s = (c, u) => this.stop(c, u)
          , a = () => yn(c => {
            var u;
            return this.getAnimationState(c) === "paused" && ((u = this.getAxisMotionValue(c).animation) === null || u === void 0 ? void 0 : u.play())
        }
        )
          , {dragSnapToOrigin: l} = this.getProps();
        this.panSession = new a0(e,{
            onSessionStart: r,
            onStart: i,
            onMove: o,
            onSessionEnd: s,
            resumeAnimation: a
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: l,
            contextWindow: h0(this.visualElement)
        })
    }
    stop(e, t) {
        let n = this.isDragging;
        if (this.cancel(),
        !n)
            return;
        let {velocity: r} = t;
        this.startAnimation(r);
        let {onDragEnd: i} = this.getProps();
        i && Z.postRender( () => i(e, t))
    }
    cancel() {
        this.isDragging = !1;
        let {projection: e, animationState: t} = this.visualElement;
        e && (e.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        let {dragPropagation: n} = this.getProps();
        !n && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, n) {
        let {drag: r} = this.getProps();
        if (!n || !Ya(e, r, this.currentDirection))
            return;
        let i = this.getAxisMotionValue(e)
          , o = this.originPoint[e] + n[e];
        this.constraints && this.constraints[e] && (o = WF(o, this.constraints[e], this.elastic[e])),
        i.set(o)
    }
    resolveConstraints() {
        var e;
        let {dragConstraints: t, dragElastic: n} = this.getProps()
          , r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout
          , i = this.constraints;
        t && ro(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = UF(r.layoutBox, t) : this.constraints = !1,
        this.elastic = YF(n),
        i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && yn(o => {
            this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = XF(r.layoutBox[o], this.constraints[o]))
        }
        )
    }
    resolveRefConstraints() {
        let {dragConstraints: e, onMeasureDragConstraints: t} = this.getProps();
        if (!e || !ro(e))
            return !1;
        let n = e.current;
        Zt(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        let {projection: r} = this.visualElement;
        if (!r || !r.layout)
            return !1;
        let i = JF(n, r.root, this.visualElement.getTransformPagePoint())
          , o = GF(r.layout.layoutBox, i);
        if (t) {
            let s = t(KF(o));
            this.hasMutatedConstraints = !!s,
            s && (o = c0(s))
        }
        return o
    }
    startAnimation(e) {
        let {drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: s} = this.getProps()
          , a = this.constraints || {}
          , l = yn(c => {
            if (!Ya(c, t, this.currentDirection))
                return;
            let u = a && a[c] || {};
            o && (u = {
                min: 0,
                max: 0
            });
            let f = r ? 200 : 1e6
              , d = r ? 40 : 1e7
              , p = {
                type: "inertia",
                velocity: n ? e[c] : 0,
                bounceStiffness: f,
                bounceDamping: d,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...i,
                ...u
            };
            return this.startAxisValueAnimation(c, p)
        }
        );
        return Promise.all(l).then(s)
    }
    startAxisValueAnimation(e, t) {
        let n = this.getAxisMotionValue(e);
        return Pf(this.visualElement, e),
        n.start(cd(e, n, 0, t, this.visualElement, !1))
    }
    stopAnimation() {
        yn(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        yn(e => {
            var t;
            return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause()
        }
        )
    }
    getAnimationState(e) {
        var t;
        return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state
    }
    getAxisMotionValue(e) {
        let t = `_drag${e.toUpperCase()}`
          , n = this.visualElement.getProps()
          , r = n[t];
        return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        yn(t => {
            let {drag: n} = this.getProps();
            if (!Ya(t, n, this.currentDirection))
                return;
            let {projection: r} = this.visualElement
              , i = this.getAxisMotionValue(t);
            if (r && r.layout) {
                let {min: o, max: s} = r.layout.layoutBox[t];
                i.set(e[t] - Me(o, s, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        let {drag: e, dragConstraints: t} = this.getProps()
          , {projection: n} = this.visualElement;
        if (!ro(t) || !n || !this.constraints)
            return;
        this.stopAnimation();
        let r = {
            x: 0,
            y: 0
        };
        yn(o => {
            let s = this.getAxisMotionValue(o);
            if (s && this.constraints !== !1) {
                let a = s.get();
                r[o] = qF({
                    min: a,
                    max: a
                }, this.constraints[o])
            }
        }
        );
        let {transformTemplate: i} = this.visualElement.getProps();
        this.visualElement.current.style.transform = i ? i({}, "") : "none",
        n.root && n.root.updateScroll(),
        n.updateLayout(),
        this.resolveConstraints(),
        yn(o => {
            if (!Ya(o, e, null))
                return;
            let s = this.getAxisMotionValue(o)
              , {min: a, max: l} = this.constraints[o];
            s.set(Me(a, l, r[o]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        eP.set(this.visualElement, this);
        let e = this.visualElement.current
          , t = Xn(e, "pointerdown", a => {
            let {drag: l, dragListener: c=!0} = this.getProps();
            l && c && this.start(a)
        }
        )
          , n = () => {
            let {dragConstraints: a} = this.getProps();
            ro(a) && a.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: r} = this.visualElement
          , i = r.addEventListener("measure", n);
        r && !r.layout && (r.root && r.root.updateScroll(),
        r.updateLayout()),
        Z.read(n);
        let o = gr(P, "resize", () => this.scalePositionWithinConstraints())
          , s = r.addEventListener("didUpdate", ({delta: a, hasLayoutChanged: l}) => {
            this.isDragging && l && (yn(c => {
                let u = this.getAxisMotionValue(c);
                u && (this.originPoint[c] += a[c].translate,
                u.set(u.get() + a[c].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            o(),
            t(),
            i(),
            s && s()
        }
    }
    getProps() {
        let e = this.visualElement.getProps()
          , {drag: t=!1, dragDirectionLock: n=!1, dragPropagation: r=!1, dragConstraints: i=!1, dragElastic: o=Of, dragMomentum: s=!0} = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: n,
            dragPropagation: r,
            dragConstraints: i,
            dragElastic: o,
            dragMomentum: s
        }
    }
}
;
function Ya(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}
function nP(e, t=10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"),
    n
}
var rP = class extends $r {
    constructor(e) {
        super(e),
        this.removeGroupControls = yt,
        this.removeListeners = yt,
        this.controls = new tP(e)
    }
    mount() {
        let {dragControls: e} = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || yt
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
  , bv = e => (t, n) => {
    e && Z.postRender( () => e(t, n))
}
  , iP = class extends $r {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = yt
    }
    onPointerDown(e) {
        this.session = new a0(e,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: h0(this.node)
        })
    }
    createPanHandlers() {
        let {onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r} = this.node.getProps();
        return {
            onSessionStart: bv(e),
            onStart: bv(t),
            onMove: n,
            onEnd: (i, o) => {
                delete this.session,
                r && Z.postRender( () => r(i, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = Xn(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
  , Ja = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function xv(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
var ss = {
    correct: (e, t) => {
        if (!t.target)
            return e;
        if (typeof e == "string")
            if (Q.test(e))
                e = parseFloat(e);
            else
                return e;
        let n = xv(e, t.target.x)
          , r = xv(e, t.target.y);
        return `${n}% ${r}%`
    }
}
  , oP = {
    correct: (e, {treeScale: t, projectionDelta: n}) => {
        let r = e
          , i = yr.parse(e);
        if (i.length > 5)
            return r;
        let o = yr.createTransformer(e)
          , s = typeof i[0] != "number" ? 1 : 0
          , a = n.x.scale * t.x
          , l = n.y.scale * t.y;
        i[0 + s] /= a,
        i[1 + s] /= l;
        let c = Me(a, l, .5);
        return typeof i[2 + s] == "number" && (i[2 + s] /= c),
        typeof i[3 + s] == "number" && (i[3 + s] /= c),
        o(i)
    }
}
  , sP = class extends we {
    componentDidMount() {
        let {visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r} = this.props
          , {projection: i} = e;
        vd(aP),
        i && (t.group && t.group.add(i),
        n && n.register && r && n.register(i),
        i.root.didUpdate(),
        i.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        i.setOptions({
            ...i.options,
            onExitComplete: () => this.safeToRemove()
        })),
        Ja.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        let {layoutDependency: t, visualElement: n, drag: r, isPresent: i} = this.props
          , o = n.projection;
        return o && (o.isPresent = i,
        r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(),
        e.isPresent !== i && (i ? o.promote() : o.relegate() || Z.postRender( () => {
            let s = o.getStack();
            (!s || !s.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        let {projection: e} = this.props.visualElement;
        e && (e.root.didUpdate(),
        yd.postRender( () => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        let {visualElement: e, layoutGroup: t, switchLayoutGroup: n} = this.props
          , {projection: r} = e;
        r && (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        n && n.deregister && n.deregister(r))
    }
    safeToRemove() {
        let {safeToRemove: e} = this.props;
        e && e()
    }
    render() {
        return null
    }
}
;
function p0(e) {
    let[t,n] = gd()
      , r = D(ws);
    return k(sP, {
        ...e,
        layoutGroup: r,
        switchLayoutGroup: D(Sl),
        isPresent: t,
        safeToRemove: n
    })
}
var aP = {
    borderRadius: {
        ...ss,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: ss,
    borderTopRightRadius: ss,
    borderBottomLeftRadius: ss,
    borderBottomRightRadius: ss,
    boxShadow: oP
}
  , m0 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , lP = m0.length
  , wv = e => typeof e == "string" ? parseFloat(e) : e
  , Sv = e => typeof e == "number" || Q.test(e);
function cP(e, t, n, r, i, o) {
    i ? (e.opacity = Me(0, n.opacity !== void 0 ? n.opacity : 1, uP(r)),
    e.opacityExit = Me(t.opacity !== void 0 ? t.opacity : 1, 0, fP(r))) : o && (e.opacity = Me(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let s = 0; s < lP; s++) {
        let a = `border${m0[s]}Radius`
          , l = kv(t, a)
          , c = kv(n, a);
        if (l === void 0 && c === void 0)
            continue;
        l || (l = 0),
        c || (c = 0),
        l === 0 || c === 0 || Sv(l) === Sv(c) ? (e[a] = Math.max(Me(wv(l), wv(c), r), 0),
        (Wn.test(c) || Wn.test(l)) && (e[a] += "%")) : e[a] = c
    }
    (t.rotate || n.rotate) && (e.rotate = Me(t.rotate || 0, n.rotate || 0, r))
}
function kv(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
var uP = g0(0, .5, Hf)
  , fP = g0(.5, .95, yt);
function g0(e, t, n) {
    return r => r < e ? 0 : r > t ? 1 : n(br(e, t, r))
}
function Cv(e, t) {
    e.min = t.min,
    e.max = t.max
}
function vn(e, t) {
    Cv(e.x, t.x),
    Cv(e.y, t.y)
}
function Tv(e, t) {
    e.translate = t.translate,
    e.scale = t.scale,
    e.originPoint = t.originPoint,
    e.origin = t.origin
}
function Rv(e, t, n, r, i) {
    return e -= t,
    e = ll(e, 1 / n, r),
    i !== void 0 && (e = ll(e, 1 / i, r)),
    e
}
function dP(e, t=0, n=1, r=.5, i, o=e, s=e) {
    if (Wn.test(t) && (t = parseFloat(t),
    t = Me(s.min, s.max, t / 100) - s.min),
    typeof t != "number")
        return;
    let a = Me(o.min, o.max, r);
    e === o && (a -= t),
    e.min = Rv(e.min, t, n, a, i),
    e.max = Rv(e.max, t, n, a, i)
}
function Ev(e, t, [n,r,i], o, s) {
    dP(e, t[n], t[r], t[i], t.scale, o, s)
}
var hP = ["x", "scaleX", "originX"]
  , pP = ["y", "scaleY", "originY"];
function Fv(e, t, n, r) {
    Ev(e.x, t, hP, n ? n.x : void 0, r ? r.x : void 0),
    Ev(e.y, t, pP, n ? n.y : void 0, r ? r.y : void 0)
}
function Pv(e) {
    return e.translate === 0 && e.scale === 1
}
function v0(e) {
    return Pv(e.x) && Pv(e.y)
}
function _v(e, t) {
    return e.min === t.min && e.max === t.max
}
function mP(e, t) {
    return _v(e.x, t.x) && _v(e.y, t.y)
}
function Iv(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}
function y0(e, t) {
    return Iv(e.x, t.x) && Iv(e.y, t.y)
}
function Ov(e) {
    return jt(e.x) / jt(e.y)
}
function Mv(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
var gP = class {
    constructor() {
        this.members = []
    }
    add(e) {
        od(this.members, e),
        e.scheduleRender()
    }
    remove(e) {
        if (ml(this.members, e),
        e === this.prevLead && (this.prevLead = void 0),
        e === this.lead) {
            let t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        let t = this.members.findIndex(r => e === r);
        if (t === 0)
            return !1;
        let n;
        for (let r = t; r >= 0; r--) {
            let i = this.members[r];
            if (i.isPresent !== !1) {
                n = i;
                break
            }
        }
        return n ? (this.promote(n),
        !0) : !1
    }
    promote(e, t) {
        let n = this.lead;
        if (e !== n && (this.prevLead = n,
        this.lead = e,
        e.show(),
        n)) {
            n.instance && n.scheduleRender(),
            e.scheduleRender(),
            e.resumeFrom = n,
            t && (e.resumeFrom.preserveOpacity = !0),
            n.snapshot && (e.snapshot = n.snapshot,
            e.snapshot.latestValues = n.animationValues || n.latestValues),
            e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            let {crossfade: r} = e.options;
            r === !1 && n.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            let {options: t, resumingFrom: n} = e;
            t.onExitComplete && t.onExitComplete(),
            n && n.options.onExitComplete && n.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
;
function vP(e, t, n) {
    let r = ""
      , i = e.x.translate / t.x
      , o = e.y.translate / t.y
      , s = n?.z || 0;
    if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `),
    (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
    n) {
        let {transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: p, skewY: v} = n;
        c && (r = `perspective(${c}px) ${r}`),
        u && (r += `rotate(${u}deg) `),
        f && (r += `rotateX(${f}deg) `),
        d && (r += `rotateY(${d}deg) `),
        p && (r += `skewX(${p}deg) `),
        v && (r += `skewY(${v}deg) `)
    }
    let a = e.x.scale * t.x
      , l = e.y.scale * t.y;
    return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`),
    r || "none"
}
function b0(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
function x0(e, t, n) {
    let r = De(e) ? e : Ge(e);
    return r.start(cd("", r, t, n)),
    r.animation
}
var bi = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
}
  , us = typeof P < "u" && P.MotionDebug !== void 0
  , ff = ["", "X", "Y", "Z"]
  , yP = {
    visibility: "hidden"
}
  , Lv = 1e3
  , bP = 0;
function df(e, t, n, r) {
    let {latestValues: i} = t;
    i[e] && (n[e] = i[e],
    t.setStaticValue(e, 0),
    r && (r[e] = 0))
}
function w0(e) {
    if (e.hasCheckedOptimisedAppear = !0,
    e.root === e)
        return;
    let {visualElement: t} = e.options;
    if (!t)
        return;
    let n = zy(t);
    if (P.MotionHasOptimisedAnimation(n, "transform")) {
        let {layout: i, layoutId: o} = e.options;
        P.MotionCancelOptimisedAnimation(n, "transform", Z, !(i || o))
    }
    let {parent: r} = e;
    r && !r.hasCheckedOptimisedAppear && w0(r)
}
function S0({attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i}) {
    return class {
        constructor(s={}, a=t?.()) {
            this.id = bP++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                us && (bi.totalNodes = bi.resolvedTargetDeltas = bi.recalculatedProjection = 0),
                this.nodes.forEach(SP),
                this.nodes.forEach(EP),
                this.nodes.forEach(FP),
                this.nodes.forEach(kP),
                us && P.MotionDebug.record(bi)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = s,
            this.root = a ? a.root || a : this,
            this.path = a ? [...a.path, a] : [],
            this.parent = a,
            this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++)
                this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new Yy)
        }
        addEventListener(s, a) {
            return this.eventHandlers.has(s) || this.eventHandlers.set(s, new sd),
            this.eventHandlers.get(s).add(a)
        }
        notifyListeners(s, ...a) {
            let l = this.eventHandlers.get(s);
            l && l.notify(...a)
        }
        hasListeners(s) {
            return this.eventHandlers.has(s)
        }
        mount(s, a=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = b0(s),
            this.instance = s;
            let {layoutId: l, layout: c, visualElement: u} = this.options;
            if (u && !u.current && u.mount(s),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            a && (c || l) && (this.isLayoutDirty = !0),
            e) {
                let f, d = () => this.root.updateBlockedByResize = !1;
                e(s, () => {
                    this.root.updateBlockedByResize = !0,
                    f && f(),
                    f = Ky(d, 250),
                    Ja.hasAnimatedSinceResize && (Ja.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(Av))
                }
                )
            }
            l && this.root.registerSharedNode(l, this),
            this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: p, layout: v}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                let g = this.options.transition || u.getDefaultTransition() || MP
                  , {onLayoutAnimationStart: b, onLayoutAnimationComplete: m} = u.getProps()
                  , h = !this.targetLayout || !y0(this.targetLayout, v) || p
                  , y = !d && p;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || y || d && (h || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(f, y);
                    let w = {
                        ...ld(g, "layout"),
                        onPlay: b,
                        onComplete: m
                    };
                    (u.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0,
                    w.type = !1),
                    this.startAnimation(w)
                } else
                    d || Av(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = v
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            let s = this.getStack();
            s && s.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            Lt(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(PP),
            this.animationId++)
        }
        getTransformTemplate() {
            let {visualElement: s} = this.options;
            return s && s.getProps().transformTemplate
        }
        willUpdate(s=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (P.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && w0(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                let f = this.path[u];
                f.shouldResetTransform = !0,
                f.updateScroll("snapshot"),
                f.options.layoutRoot && f.willUpdate(!1)
            }
            let {layoutId: a, layout: l} = this.options;
            if (a === void 0 && !l)
                return;
            let c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            s && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(Vv);
                return
            }
            this.isUpdating || this.nodes.forEach(TP),
            this.isUpdating = !1,
            this.nodes.forEach(RP),
            this.nodes.forEach(xP),
            this.nodes.forEach(wP),
            this.clearAllSnapshots();
            let a = qn.now();
            Ue.delta = vr(0, 1e3 / 60, a - Ue.timestamp),
            Ue.timestamp = a,
            Ue.isProcessing = !0,
            Qa.update.process(Ue),
            Qa.preRender.process(Ue),
            Qa.render.process(Ue),
            Ue.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            yd.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(CP),
            this.sharedNodes.forEach(_P)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            Z.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            Z.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++)
                    this.path[l].updateScroll();
            let s = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Be(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            let {visualElement: a} = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0)
        }
        updateScroll(s="measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1),
            a) {
                let l = r(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: s,
                    isRoot: l,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : l
                }
            }
        }
        resetTransform() {
            if (!i)
                return;
            let s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , a = this.projectionDelta && !v0(this.projectionDelta)
              , l = this.getTransformTemplate()
              , c = l ? l(this.latestValues, "") : void 0
              , u = c !== this.prevTransformTemplateValue;
            s && (a || yi(this.latestValues) || u) && (i(this.instance, c),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(s=!0) {
            let a = this.measurePageBox()
              , l = this.removeElementScroll(a);
            return s && (l = this.removeTransform(l)),
            LP(l),
            {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var s;
            let {visualElement: a} = this.options;
            if (!a)
                return Be();
            let l = a.measureViewportBox();
            if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(VP))) {
                let {scroll: u} = this.root;
                u && (io(l.x, u.offset.x),
                io(l.y, u.offset.y))
            }
            return l
        }
        removeElementScroll(s) {
            var a;
            let l = Be();
            if (vn(l, s),
            !((a = this.scroll) === null || a === void 0) && a.wasRoot)
                return l;
            for (let c = 0; c < this.path.length; c++) {
                let u = this.path[c]
                  , {scroll: f, options: d} = u;
                u !== this.root && f && d.layoutScroll && (f.wasRoot && vn(l, s),
                io(l.x, f.offset.x),
                io(l.y, f.offset.y))
            }
            return l
        }
        applyTransform(s, a=!1) {
            let l = Be();
            vn(l, s);
            for (let c = 0; c < this.path.length; c++) {
                let u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && oo(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }),
                yi(u.latestValues) && oo(l, u.latestValues)
            }
            return yi(this.latestValues) && oo(l, this.latestValues),
            l
        }
        removeTransform(s) {
            let a = Be();
            vn(a, s);
            for (let l = 0; l < this.path.length; l++) {
                let c = this.path[l];
                if (!c.instance || !yi(c.latestValues))
                    continue;
                Mf(c.latestValues) && c.updateSnapshot();
                let u = Be()
                  , f = c.measurePageBox();
                vn(u, f),
                Fv(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return yi(this.latestValues) && Fv(a, this.latestValues),
            a
        }
        setTargetDelta(s) {
            this.targetDelta = s,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(s) {
            this.options = {
                ...this.options,
                ...s,
                crossfade: s.crossfade !== void 0 ? s.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ue.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(s=!1) {
            var a;
            let l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            let c = !!this.resumingFrom || this !== l;
            if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            let {layout: f, layoutId: d} = this.options;
            if (!(!this.layout || !(f || d))) {
                if (this.resolvedRelativeTargetAt = Ue.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    let p = this.getClosestProjectingParent();
                    p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = Be(),
                    this.relativeTargetOrigin = Be(),
                    ps(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox),
                    vn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Be(),
                    this.targetWithTransforms = Be()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    SF(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : vn(this.target, this.layout.layoutBox),
                    f0(this.target, this.targetDelta)) : vn(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        let p = this.getClosestProjectingParent();
                        p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = Be(),
                        this.relativeTargetOrigin = Be(),
                        ps(this.relativeTargetOrigin, this.target, p.target),
                        vn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    us && bi.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Mf(this.parent.latestValues) || u0(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var s;
            let a = this.getLead()
              , l = !!this.resumingFrom || this !== a
              , c = !0;
            if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1),
            l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1),
            this.resolvedRelativeTargetAt === Ue.timestamp && (c = !1),
            c)
                return;
            let {layout: u, layoutId: f} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(u || f))
                return;
            vn(this.layoutCorrected, this.layout.layoutBox);
            let d = this.treeScale.x
              , p = this.treeScale.y;
            ZF(this.layoutCorrected, this.treeScale, this.path, l),
            a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox,
            a.targetWithTransforms = Be());
            let {target: v} = a;
            if (!v) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Tv(this.prevProjectionDelta.x, this.projectionDelta.x),
            Tv(this.prevProjectionDelta.y, this.projectionDelta.y)),
            hs(this.projectionDelta, this.layoutCorrected, v, this.latestValues),
            (this.treeScale.x !== d || this.treeScale.y !== p || !Mv(this.projectionDelta.x, this.prevProjectionDelta.x) || !Mv(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", v)),
            us && bi.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(s=!0) {
            var a;
            if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(),
            s) {
                let l = this.getStack();
                l && l.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = no(),
            this.projectionDelta = no(),
            this.projectionDeltaWithTransform = no()
        }
        setAnimationOrigin(s, a=!1) {
            let l = this.snapshot
              , c = l ? l.latestValues : {}
              , u = {
                ...this.latestValues
            }
              , f = no();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !a;
            let d = Be()
              , p = l ? l.source : void 0
              , v = this.layout ? this.layout.source : void 0
              , g = p !== v
              , b = this.getStack()
              , m = !b || b.members.length <= 1
              , h = !!(g && !m && this.options.crossfade === !0 && !this.path.some(OP));
            this.animationProgress = 0;
            let y;
            this.mixTargetDelta = w => {
                let C = w / 1e3;
                Dv(f.x, s.x, C),
                Dv(f.y, s.y, C),
                this.setTargetDelta(f),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ps(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                IP(this.relativeTarget, this.relativeTargetOrigin, d, C),
                y && mP(this.relativeTarget, y) && (this.isProjectionDirty = !1),
                y || (y = Be()),
                vn(y, this.relativeTarget)),
                g && (this.animationValues = u,
                cP(u, c, this.latestValues, C, h, m)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = C
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(s) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (Lt(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = Z.update( () => {
                Ja.hasAnimatedSinceResize = !0,
                this.currentAnimation = x0(0, Lv, {
                    ...s,
                    onUpdate: a => {
                        this.mixTargetDelta(a),
                        s.onUpdate && s.onUpdate(a)
                    }
                    ,
                    onComplete: () => {
                        s.onComplete && s.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            let s = this.getStack();
            s && s.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Lv),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            let s = this.getLead()
              , {targetWithTransforms: a, target: l, layout: c, latestValues: u} = s;
            if (!(!a || !l || !c)) {
                if (this !== s && this.layout && c && k0(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || Be();
                    let f = jt(this.layout.layoutBox.x);
                    l.x.min = s.target.x.min,
                    l.x.max = l.x.min + f;
                    let d = jt(this.layout.layoutBox.y);
                    l.y.min = s.target.y.min,
                    l.y.max = l.y.min + d
                }
                vn(a, l),
                oo(a, u),
                hs(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(s, a) {
            this.sharedNodes.has(s) || this.sharedNodes.set(s, new gP),
            this.sharedNodes.get(s).add(a);
            let c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            let s = this.getStack();
            return s ? s.lead === this : !0
        }
        getLead() {
            var s;
            let {layoutId: a} = this.options;
            return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this
        }
        getPrevLead() {
            var s;
            let {layoutId: a} = this.options;
            return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0
        }
        getStack() {
            let {layoutId: s} = this.options;
            if (s)
                return this.root.sharedNodes.get(s)
        }
        promote({needsReset: s, transition: a, preserveFollowOpacity: l}={}) {
            let c = this.getStack();
            c && c.promote(this, l),
            s && (this.projectionDelta = void 0,
            this.needsReset = !0),
            a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            let s = this.getStack();
            return s ? s.relegate(this) : !1
        }
        resetSkewAndRotation() {
            let {visualElement: s} = this.options;
            if (!s)
                return;
            let a = !1
              , {latestValues: l} = s;
            if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0),
            !a)
                return;
            let c = {};
            l.z && df("z", s, c, this.animationValues);
            for (let u = 0; u < ff.length; u++)
                df(`rotate${ff[u]}`, s, c, this.animationValues),
                df(`skew${ff[u]}`, s, c, this.animationValues);
            s.render();
            for (let u in c)
                s.setStaticValue(u, c[u]),
                this.animationValues && (this.animationValues[u] = c[u]);
            s.scheduleRender()
        }
        getProjectionStyles(s) {
            var a, l;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return yP;
            let c = {
                visibility: ""
            }
              , u = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                c.opacity = "",
                c.pointerEvents = Ct(s?.pointerEvents) || "",
                c.transform = u ? u(this.latestValues, "") : "none",
                c;
            let f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                let g = {};
                return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                g.pointerEvents = Ct(s?.pointerEvents) || ""),
                this.hasProjected && !yi(this.latestValues) && (g.transform = u ? u({}, "") : "none",
                this.hasProjected = !1),
                g
            }
            let d = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(),
            c.transform = vP(this.projectionDeltaWithTransform, this.treeScale, d),
            u && (c.transform = u(d, c.transform));
            let {x: p, y: v} = this.projectionDelta;
            c.transformOrigin = `${p.origin * 100}% ${v.origin * 100}% 0`,
            f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (let g in sl) {
                if (d[g] === void 0)
                    continue;
                let {correct: b, applyTo: m} = sl[g]
                  , h = c.transform === "none" ? d[g] : b(d[g], f);
                if (m) {
                    let y = m.length;
                    for (let w = 0; w < y; w++)
                        c[m[w]] = h
                } else
                    c[g] = h
            }
            return this.options.layoutId && (c.pointerEvents = f === this ? Ct(s?.pointerEvents) || "" : "none"),
            c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(s => {
                var a;
                return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }
            ),
            this.root.nodes.forEach(Vv),
            this.root.sharedNodes.clear()
        }
    }
}
function xP(e) {
    e.updateLayout()
}
function wP(e) {
    var t;
    let n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        let {layoutBox: r, measuredBox: i} = e.layout
          , {animationType: o} = e.options
          , s = n.source !== e.layout.source;
        o === "size" ? yn(f => {
            let d = s ? n.measuredBox[f] : n.layoutBox[f]
              , p = jt(d);
            d.min = r[f].min,
            d.max = d.min + p
        }
        ) : k0(o, n.layoutBox, r) && yn(f => {
            let d = s ? n.measuredBox[f] : n.layoutBox[f]
              , p = jt(r[f]);
            d.max = d.min + p,
            e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0,
            e.relativeTarget[f].max = e.relativeTarget[f].min + p)
        }
        );
        let a = no();
        hs(a, r, n.layoutBox);
        let l = no();
        s ? hs(l, e.applyTransform(i, !0), n.measuredBox) : hs(l, r, n.layoutBox);
        let c = !v0(a)
          , u = !1;
        if (!e.resumeFrom) {
            let f = e.getClosestProjectingParent();
            if (f && !f.resumeFrom) {
                let {snapshot: d, layout: p} = f;
                if (d && p) {
                    let v = Be();
                    ps(v, n.layoutBox, d.layoutBox);
                    let g = Be();
                    ps(g, r, p.layoutBox),
                    y0(v, g) || (u = !0),
                    f.options.layoutRoot && (e.relativeTarget = g,
                    e.relativeTargetOrigin = v,
                    e.relativeParent = f)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: u
        })
    } else if (e.isLead()) {
        let {onExitComplete: r} = e.options;
        r && r()
    }
    e.options.transition = void 0
}
function SP(e) {
    us && bi.totalNodes++,
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
    e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)),
    e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function kP(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function CP(e) {
    e.clearSnapshot()
}
function Vv(e) {
    e.clearMeasurements()
}
function TP(e) {
    e.isLayoutDirty = !1
}
function RP(e) {
    let {visualElement: t} = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    e.resetTransform()
}
function Av(e) {
    e.finishAnimation(),
    e.targetDelta = e.relativeTarget = e.target = void 0,
    e.isProjectionDirty = !0
}
function EP(e) {
    e.resolveTargetDelta()
}
function FP(e) {
    e.calcProjection()
}
function PP(e) {
    e.resetSkewAndRotation()
}
function _P(e) {
    e.removeLeadSnapshot()
}
function Dv(e, t, n) {
    e.translate = Me(t.translate, 0, n),
    e.scale = Me(t.scale, 1, n),
    e.origin = t.origin,
    e.originPoint = t.originPoint
}
function zv(e, t, n, r) {
    e.min = Me(t.min, n.min, r),
    e.max = Me(t.max, n.max, r)
}
function IP(e, t, n, r) {
    zv(e.x, t.x, n.x, r),
    zv(e.y, t.y, n.y, r)
}
function OP(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
var MP = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , Bv = e => typeof Fe < "u" && Fe.userAgent && Fe.userAgent.toLowerCase().includes(e)
  , $v = Bv("applewebkit/") && !Bv("chrome/") ? Math.round : yt;
function Nv(e) {
    e.min = $v(e.min),
    e.max = $v(e.max)
}
function LP(e) {
    Nv(e.x),
    Nv(e.y)
}
function k0(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !wF(Ov(t), Ov(n), .2)
}
function VP(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
var AP = S0({
    attachResizeListener: (e, t) => gr(e, "resize", t),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , Si = {
    current: void 0
}
  , C0 = S0({
    measureScroll: e => ({
        x: e.scrollLeft,
        y: e.scrollTop
    }),
    defaultParent: () => {
        if (!Si.current) {
            let e = new AP({});
            e.mount(P),
            e.setOptions({
                layoutScroll: !0
            }),
            Si.current = e
        }
        return Si.current
    }
    ,
    resetTransform: (e, t) => {
        e.style.transform = t !== void 0 ? t : "none"
    }
    ,
    checkIsScrollRoot: e => P.getComputedStyle(e).position === "fixed"
})
  , T0 = {
    pan: {
        Feature: iP
    },
    drag: {
        Feature: rP,
        ProjectionNode: C0,
        MeasureLayout: p0
    }
};
function jv(e, t) {
    let n = t ? "pointerenter" : "pointerleave"
      , r = t ? "onHoverStart" : "onHoverEnd"
      , i = (o, s) => {
        if (o.pointerType === "touch" || md())
            return;
        let a = e.getProps();
        e.animationState && a.whileHover && e.animationState.setActive("whileHover", t);
        let l = a[r];
        l && Z.postRender( () => l(o, s))
    }
    ;
    return Xn(e.current, n, i, {
        passive: !e.getProps()[r]
    })
}
var DP = class extends $r {
    mount() {
        this.unmount = Gn(jv(this.node, !0), jv(this.node, !1))
    }
    unmount() {}
}
  , zP = class extends $r {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }
        !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = Gn(gr(this.node.current, "focus", () => this.onFocus()), gr(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
  , R0 = (e, t) => t ? e === t ? !0 : R0(e, t.parentElement) : !1;
function hf(e, t) {
    if (!t)
        return;
    let n = new PointerEvent("pointer" + e);
    t(n, wl(n))
}
var BP = class extends $r {
    constructor() {
        super(...arguments),
        this.removeStartListeners = yt,
        this.removeEndListeners = yt,
        this.removeAccessibleListeners = yt,
        this.startPointerPress = (e, t) => {
            if (this.isPressing)
                return;
            this.removeEndListeners();
            let n = this.node.getProps()
              , i = Xn(P, "pointerup", (s, a) => {
                if (!this.checkPressEnd())
                    return;
                let {onTap: l, onTapCancel: c, globalTapTarget: u} = this.node.getProps()
                  , f = !u && !R0(this.node.current, s.target) ? c : l;
                f && Z.update( () => f(s, a))
            }
            , {
                passive: !(n.onTap || n.onPointerUp)
            })
              , o = Xn(P, "pointercancel", (s, a) => this.cancelPress(s, a), {
                passive: !(n.onTapCancel || n.onPointerCancel)
            });
            this.removeEndListeners = Gn(i, o),
            this.startPress(e, t)
        }
        ,
        this.startAccessiblePress = () => {
            let e = i => {
                if (i.key !== "Enter" || this.isPressing)
                    return;
                let o = s => {
                    s.key !== "Enter" || !this.checkPressEnd() || hf("up", (a, l) => {
                        let {onTap: c} = this.node.getProps();
                        c && Z.postRender( () => c(a, l))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = gr(this.node.current, "keyup", o),
                hf("down", (s, a) => {
                    this.startPress(s, a)
                }
                )
            }
              , t = gr(this.node.current, "keydown", e)
              , n = () => {
                this.isPressing && hf("cancel", (i, o) => this.cancelPress(i, o))
            }
              , r = gr(this.node.current, "blur", n);
            this.removeAccessibleListeners = Gn(t, r)
        }
    }
    startPress(e, t) {
        this.isPressing = !0;
        let {onTapStart: n, whileTap: r} = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        n && Z.postRender( () => n(e, t))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !md()
    }
    cancelPress(e, t) {
        if (!this.checkPressEnd())
            return;
        let {onTapCancel: n} = this.node.getProps();
        n && Z.postRender( () => n(e, t))
    }
    mount() {
        let e = this.node.getProps()
          , t = Xn(e.globalTapTarget ? P : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(e.onTapStart || e.onPointerStart)
        })
          , n = gr(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Gn(t, n)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
  , Vf = new WeakMap
  , pf = new WeakMap
  , $P = e => {
    let t = Vf.get(e.target);
    t && t(e)
}
  , NP = e => {
    e.forEach($P)
}
;
function jP({root: e, ...t}) {
    let n = e || document;
    pf.has(n) || pf.set(n, {});
    let r = pf.get(n)
      , i = JSON.stringify(t);
    return r[i] || (r[i] = new IntersectionObserver(NP,{
        root: e,
        ...t
    })),
    r[i]
}
function HP(e, t, n) {
    let r = jP(t);
    return Vf.set(e, n),
    r.observe(e),
    () => {
        Vf.delete(e),
        r.unobserve(e)
    }
}
var WP = {
    some: 0,
    all: 1
}
  , UP = class extends $r {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        let {viewport: e={}} = this.node.getProps()
          , {root: t, margin: n, amount: r="some", once: i} = e
          , o = {
            root: t ? t.current : void 0,
            rootMargin: n,
            threshold: typeof r == "number" ? r : WP[r]
        }
          , s = a => {
            let {isIntersecting: l} = a;
            if (this.isInView === l || (this.isInView = l,
            i && !l && this.hasEnteredView))
                return;
            l && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", l);
            let {onViewportEnter: c, onViewportLeave: u} = this.node.getProps()
              , f = l ? c : u;
            f && f(a)
        }
        ;
        return HP(this.node.current, o, s)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        let {props: e, prevProps: t} = this.node;
        ["amount", "margin", "root"].some(GP(e, t)) && this.startObserver()
    }
    unmount() {}
}
;
function GP({viewport: e={}}, {viewport: t={}}={}) {
    return n => e[n] !== t[n]
}
var E0 = {
    inView: {
        Feature: UP
    },
    tap: {
        Feature: BP
    },
    focus: {
        Feature: zP
    },
    hover: {
        Feature: DP
    }
}
  , F0 = {
    layout: {
        ProjectionNode: C0,
        MeasureLayout: p0
    }
}
  , qP = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function Sd(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(qP.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
function P0(e, {style: t, vars: n}, r, i) {
    Object.assign(e.style, t, i && i.getProjectionStyles(r));
    for (let o in n)
        e.style.setProperty(o, n[o])
}
var _0 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function I0(e, t, n, r) {
    P0(e, t, void 0, r);
    for (let i in t.attrs)
        e.setAttribute(_0.has(i) ? i : vl(i), t.attrs[i])
}
function O0(e, {layout: t, layoutId: n}) {
    return Br.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!sl[e] || e === "opacity")
}
function kd(e, t, n) {
    var r;
    let {style: i} = e
      , o = {};
    for (let s in i)
        (De(i[s]) || t.style && De(t.style[s]) || O0(s, e) || ((r = n?.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]);
    return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1),
    o
}
function M0(e, t, n) {
    let r = kd(e, t, n);
    for (let i in e)
        if (De(e[i]) || De(t[i])) {
            let o = Cs.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            r[o] = e[i]
        }
    return r
}
var Cd = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
})
  , L0 = () => ({
    ...Cd(),
    attrs: {}
});
function Td(e, t, n) {
    let {style: r, vars: i, transformOrigin: o} = e
      , s = !1
      , a = !1;
    for (let l in t) {
        let c = t[l];
        if (Br.has(l)) {
            s = !0;
            continue
        } else if (vy(l)) {
            i[l] = c;
            continue
        } else {
            let u = t0(c, nd[l]);
            l.startsWith("origin") ? (a = !0,
            o[l] = u) : r[l] = u
        }
    }
    if (t.transform || (s || n ? r.transform = n0(t, e.transform, n) : r.transform && (r.transform = "none")),
    a) {
        let {originX: l="50%", originY: c="50%", originZ: u=0} = o;
        r.transformOrigin = `${l} ${c} ${u}`
    }
}
function Hv(e, t, n) {
    return typeof e == "string" ? e : Q.transform(t + n * e)
}
function XP(e, t, n) {
    let r = Hv(t, e.x, e.width)
      , i = Hv(n, e.y, e.height);
    return `${r} ${i}`
}
var YP = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , KP = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function QP(e, t, n=1, r=0, i=!0) {
    e.pathLength = 1;
    let o = i ? YP : KP;
    e[o.offset] = Q.transform(-r);
    let s = Q.transform(t)
      , a = Q.transform(n);
    e[o.array] = `${s} ${a}`
}
function Rd(e, {attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a=1, pathOffset: l=0, ...c}, u, f) {
    if (Td(e, c, f),
    u) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style,
    e.style = {};
    let {attrs: d, style: p, dimensions: v} = e;
    d.transform && (v && (p.transform = d.transform),
    delete d.transform),
    v && (i !== void 0 || o !== void 0 || p.transform) && (p.transformOrigin = XP(v, i !== void 0 ? i : .5, o !== void 0 ? o : .5)),
    t !== void 0 && (d.x = t),
    n !== void 0 && (d.y = n),
    r !== void 0 && (d.scale = r),
    s !== void 0 && QP(d, s, a, l, !1)
}
var Ed = e => typeof e == "string" && e.toLowerCase() === "svg"
  , ZP = {
    useVisualState: Tl({
        scrapeMotionValuesFromProps: M0,
        createRenderState: L0,
        onMount: (e, t, {renderState: n, latestValues: r}) => {
            Z.read( () => {
                try {
                    n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect()
                } catch {
                    n.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            Z.render( () => {
                Rd(n, r, Ed(t.tagName), e.transformTemplate),
                I0(t, n)
            }
            )
        }
    })
}
  , JP = {
    useVisualState: Tl({
        applyWillChange: !0,
        scrapeMotionValuesFromProps: kd,
        createRenderState: Cd
    })
};
function V0(e, t, n) {
    for (let r in t)
        !De(t[r]) && !O0(r, n) && (e[r] = t[r])
}
function e_({transformTemplate: e}, t) {
    return se( () => {
        let n = Cd();
        return Td(n, t, e),
        Object.assign({}, n.vars, n.style)
    }
    , [t])
}
function t_(e, t) {
    let n = e.style || {}
      , r = {};
    return V0(r, n, e),
    Object.assign(r, e_(e, t)),
    r
}
function n_(e, t) {
    let n = {}
      , r = t_(e, t);
    return e.drag && e.dragListener !== !1 && (n.draggable = !1,
    r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none",
    r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
    n.style = r,
    n
}
function r_(e, t, n, r) {
    let i = se( () => {
        let o = L0();
        return Rd(o, t, Ed(r), e.transformTemplate),
        {
            ...o.attrs,
            style: {
                ...o.style
            }
        }
    }
    , [t]);
    if (e.style) {
        let o = {};
        V0(o, e.style, e),
        i.style = {
            ...o,
            ...i.style
        }
    }
    return i
}
function i_(e=!1) {
    return (n, r, i, {latestValues: o}, s) => {
        let l = (Sd(n) ? r_ : n_)(r, o, s, n)
          , c = o0(r, typeof n == "string", e)
          , u = n !== gn ? {
            ...c,
            ...l,
            ref: i
        } : {}
          , {children: f} = r
          , d = se( () => De(f) ? f.get() : f, [f]);
        return Ji(n, {
            ...u,
            children: d
        })
    }
}
function o_(e, t) {
    return function(r, {forwardMotionProps: i}={
        forwardMotionProps: !1
    }) {
        let s = {
            ...Sd(r) ? ZP : JP,
            preloadedFeatures: e,
            useRender: i_(i),
            createVisualElement: t,
            Component: r
        };
        return e0(s)
    }
}
var A0 = class extends wd {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = Iy
    }
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {vars: t, style: n}) {
        delete t[e],
        delete n[e]
    }
}
;
function s_(e) {
    return P.getComputedStyle(e)
}
var D0 = class extends A0 {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.applyWillChange = !0,
        this.renderInstance = P0
    }
    readValueFromInstance(e, t) {
        if (Br.has(t)) {
            let n = rd(t);
            return n && n.default || 0
        } else {
            let n = s_(e)
              , r = (vy(t) ? n.getPropertyValue(t) : n[t]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(e, {transformPagePoint: t}) {
        return d0(e, t)
    }
    build(e, t, n) {
        Td(e, t, n.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return kd(e, t, n)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        let {children: e} = this.props;
        De(e) && (this.childSubscription = e.on("change", t => {
            this.current && (this.current.textContent = `${t}`)
        }
        ))
    }
}
  , z0 = class extends A0 {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = Be
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (Br.has(t)) {
            let n = rd(t);
            return n && n.default || 0
        }
        return t = _0.has(t) ? t : vl(t),
        e.getAttribute(t)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return M0(e, t, n)
    }
    build(e, t, n) {
        Rd(e, t, this.isSVGTag, n.transformTemplate)
    }
    renderInstance(e, t, n, r) {
        I0(e, t, n, r)
    }
    mount(e) {
        this.isSVGTag = Ed(e.tagName),
        super.mount(e)
    }
}
  , Fd = (e, t) => Sd(e) ? new z0(t) : new D0(t,{
    allowProjection: e !== gn
})
  , a_ = o_({
    ...xl,
    ...E0,
    ...T0,
    ...F0
}, Fd)
  , Jt = NF(a_);
var l_ = class extends we {
    getSnapshotBeforeUpdate(e) {
        let t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
            let n = this.props.sizeRef.current;
            n.height = t.offsetHeight || 0,
            n.width = t.offsetWidth || 0,
            n.top = t.offsetTop,
            n.left = t.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
;
function c_({children: e, isPresent: t}) {
    let n = gi()
      , r = V(null)
      , i = V({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: o} = D(xr);
    return ct( () => {
        let {width: s, height: a, top: l, left: c} = i.current;
        if (t || !r.current || !s || !a)
            return;
        r.current.dataset.motionPopId = n;
        let u = document.createElement("style");
        return o && (u.nonce = o),
        document.head.appendChild(u),
        u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `),
        () => {
            document.head.removeChild(u)
        }
    }
    , [t]),
    k(l_, {
        isPresent: t,
        childRef: r,
        sizeRef: i,
        children: mr(e, {
            ref: r
        })
    })
}
var u_ = ({children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s}) => {
    let a = Kn(f_)
      , l = gi()
      , c = K(f => {
        a.set(f, !0);
        for (let d of a.values())
            if (!d)
                return;
        r && r()
    }
    , [a, r])
      , u = se( () => ({
        id: l,
        initial: t,
        isPresent: n,
        custom: i,
        onExitComplete: c,
        register: f => (a.set(f, !1),
        () => a.delete(f))
    }), o ? [Math.random(), c] : [n, c]);
    return se( () => {
        a.forEach( (f, d) => a.set(d, !1))
    }
    , [n]),
    $( () => {
        !n && !a.size && r && r()
    }
    , [n]),
    s === "popLayout" && (e = k(c_, {
        isPresent: n,
        children: e
    })),
    k(po.Provider, {
        value: u,
        children: e
    })
}
;
function f_() {
    return new Map
}
var Ka = e => e.key || "";
function Wv(e) {
    let t = [];
    return mn.forEach(e, n => {
        Ot(n) && t.push(n)
    }
    ),
    t
}
var Pd = ({children: e, exitBeforeEnter: t, custom: n, initial: r=!0, onExitComplete: i, presenceAffectsLayout: o=!0, mode: s="sync"}) => {
    Zt(!t, "Replace exitBeforeEnter with mode='wait'");
    let a = se( () => Wv(e), [e])
      , l = a.map(Ka)
      , c = V(!0)
      , u = V(a)
      , f = Kn( () => new Map)
      , [d,p] = Oe(a)
      , [v,g] = Oe(a);
    Nr( () => {
        c.current = !1,
        u.current = a;
        for (let h = 0; h < v.length; h++) {
            let y = Ka(v[h]);
            l.includes(y) ? f.delete(y) : f.get(y) !== !0 && f.set(y, !1)
        }
    }
    , [v, l.length, l.join("-")]);
    let b = [];
    if (a !== d) {
        let h = [...a];
        for (let y = 0; y < v.length; y++) {
            let w = v[y]
              , C = Ka(w);
            l.includes(C) || (h.splice(y, 0, w),
            b.push(w))
        }
        s === "wait" && b.length && (h = b),
        g(Wv(h)),
        p(a);
        return
    }
    let {forceRender: m} = D(ws);
    return k(it, {
        children: v.map(h => {
            let y = Ka(h)
              , w = a === v || l.includes(y)
              , C = () => {
                if (f.has(y))
                    f.set(y, !0);
                else
                    return;
                let S = !0;
                f.forEach(T => {
                    T || (S = !1)
                }
                ),
                S && (m?.(),
                g(u.current),
                i && i())
            }
            ;
            return k(u_, {
                isPresent: w,
                initial: !c.current || r ? void 0 : !1,
                custom: w ? void 0 : n,
                presenceAffectsLayout: o,
                mode: s,
                onExitComplete: w ? void 0 : C,
                children: h
            }, y)
        }
        )
    })
}
;
function B0({children: e, isValidProp: t, ...n}) {
    t && i0(t),
    n = {
        ...D(xr),
        ...n
    },
    n.isStatic = Kn( () => n.isStatic);
    let r = se( () => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]);
    return k(xr.Provider, {
        value: r,
        children: e
    })
}
var $0 = ve(null);
function d_() {
    let e = V(!1);
    return Nr( () => (e.current = !0,
    () => {
        e.current = !1
    }
    ), []),
    e
}
function _d() {
    let e = d_()
      , [t,n] = Oe(0)
      , r = K( () => {
        e.current && n(t + 1)
    }
    , [t]);
    return [K( () => Z.postRender(r), [r]), t]
}
var h_ = e => !e.isLayoutDirty && e.willUpdate(!1);
function Uv() {
    let e = new Set
      , t = new WeakMap
      , n = () => e.forEach(h_);
    return {
        add: r => {
            e.add(r),
            t.set(r, r.addEventListener("willUpdate", n))
        }
        ,
        remove: r => {
            e.delete(r);
            let i = t.get(r);
            i && (i(),
            t.delete(r)),
            n()
        }
        ,
        dirty: n
    }
}
var N0 = e => e === !0
  , p_ = e => N0(e === !0) || e === "id"
  , j0 = ({children: e, id: t, inherit: n=!0}) => {
    let r = D(ws)
      , i = D($0)
      , [o,s] = _d()
      , a = V(null)
      , l = r.id || i;
    a.current === null && (p_(n) && l && (t = t ? l + "-" + t : l),
    a.current = {
        id: t,
        group: N0(n) && r.group || Uv()
    });
    let c = se( () => ({
        ...a.current,
        forceRender: o
    }), [s]);
    return k(ws.Provider, {
        value: c,
        children: e
    })
}
  , m_ = {
    renderer: Fd,
    ...xl
}
  , H0 = {
    renderer: Fd,
    ...xl,
    ...E0
}
  , g_ = {
    ...H0,
    ...T0,
    ...F0
};
function Qn(e) {
    let t = Kn( () => Ge(e))
      , {isStatic: n} = D(xr);
    if (n) {
        let[,r] = Oe(e);
        $( () => t.on("change", r), [])
    }
    return t
}
function W0(e, t) {
    let n = Qn(t())
      , r = () => n.set(t());
    return r(),
    Nr( () => {
        let i = () => Z.preRender(r, !1, !0)
          , o = e.map(s => s.on("change", i));
        return () => {
            o.forEach(s => s()),
            Lt(r)
        }
    }
    ),
    n
}
var v_ = e => e && typeof e == "object" && e.mix
  , y_ = e => v_(e) ? e.mix : void 0;
function Rs(...e) {
    let t = !Array.isArray(e[0])
      , n = t ? 0 : -1
      , r = e[0 + n]
      , i = e[1 + n]
      , o = e[2 + n]
      , s = e[3 + n]
      , a = ho(i, o, {
        mixer: y_(o[0]),
        ...s
    });
    return t ? a(r) : a
}
function b_(e) {
    ds.current = [],
    e();
    let t = W0(ds.current, e);
    return ds.current = void 0,
    t
}
function Vt(e, t, n, r) {
    if (typeof e == "function")
        return b_(e);
    let i = typeof t == "function" ? t : Rs(t, n, r);
    return Array.isArray(e) ? Gv(e, i) : Gv([e], ([o]) => i(o))
}
function Gv(e, t) {
    let n = Kn( () => []);
    return W0(e, () => {
        n.length = 0;
        let r = e.length;
        for (let i = 0; i < r; i++)
            n[i] = e[i].get();
        return t(n)
    }
    )
}
function qv(e) {
    return typeof e == "number" ? e : parseFloat(e)
}
function Id(e, t={}) {
    let {isStatic: n} = D(xr)
      , r = V(null)
      , i = Qn(De(e) ? qv(e.get()) : e)
      , o = V(i.get())
      , s = V( () => {}
    )
      , a = () => {
        let c = r.current;
        c && c.time === 0 && c.sample(Ue.delta),
        l(),
        r.current = td({
            keyframes: [i.get(), o.current],
            velocity: i.getVelocity(),
            type: "spring",
            restDelta: .001,
            restSpeed: .01,
            ...t,
            onUpdate: s.current
        })
    }
      , l = () => {
        r.current && r.current.stop()
    }
    ;
    return ct( () => i.attach( (c, u) => n ? u(c) : (o.current = c,
    s.current = u,
    Z.update(a),
    i.get()), l), [JSON.stringify(t)]),
    Nr( () => {
        if (De(e))
            return e.on("change", c => i.set(qv(c)))
    }
    , [i]),
    i
}
function Od(e, t, n) {
    var r;
    if (typeof e == "string") {
        let i = document;
        t && (Zt(!!t.current, "Scope provided, but no element detected."),
        i = t.current),
        n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)),
        e = n[e]) : e = i.querySelectorAll(e)
    } else
        e instanceof Element && (e = [e]);
    return Array.from(e || [])
}
var el = new WeakMap, zr;
function x_(e, t) {
    if (t) {
        let {inlineSize: n, blockSize: r} = t[0];
        return {
            width: n,
            height: r
        }
    } else
        return e instanceof SVGElement && "getBBox"in e ? e.getBBox() : {
            width: e.offsetWidth,
            height: e.offsetHeight
        }
}
function w_({target: e, contentRect: t, borderBoxSize: n}) {
    var r;
    (r = el.get(e)) === null || r === void 0 || r.forEach(i => {
        i({
            target: e,
            contentSize: t,
            get size() {
                return x_(e, n)
            }
        })
    }
    )
}
function S_(e) {
    e.forEach(w_)
}
function k_() {
    typeof ResizeObserver > "u" || (zr = new ResizeObserver(S_))
}
function C_(e, t) {
    zr || k_();
    let n = Od(e);
    return n.forEach(r => {
        let i = el.get(r);
        i || (i = new Set,
        el.set(r, i)),
        i.add(t),
        zr?.observe(r)
    }
    ),
    () => {
        n.forEach(r => {
            let i = el.get(r);
            i?.delete(t),
            i?.size || zr?.unobserve(r)
        }
        )
    }
}
var tl = new Set, ms;
function T_() {
    ms = () => {
        let e = {
            width: P.innerWidth,
            height: P.innerHeight
        }
          , t = {
            target: P,
            size: e,
            contentSize: e
        };
        tl.forEach(n => n(t))
    }
    ,
    P.addEventListener("resize", ms)
}
function R_(e) {
    return tl.add(e),
    ms || T_(),
    () => {
        tl.delete(e),
        !tl.size && ms && (ms = void 0)
    }
}
function E_(e, t) {
    return typeof e == "function" ? R_(e) : C_(e, t)
}
var F_ = 50
  , Xv = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0
})
  , P_ = () => ({
    time: 0,
    x: Xv(),
    y: Xv()
})
  , __ = {
    x: {
        length: "Width",
        position: "Left"
    },
    y: {
        length: "Height",
        position: "Top"
    }
};
function Yv(e, t, n, r) {
    let i = n[t]
      , {length: o, position: s} = __[t]
      , a = i.current
      , l = n.time;
    i.current = e[`scroll${s}`],
    i.scrollLength = e[`scroll${o}`] - e[`client${o}`],
    i.offset.length = 0,
    i.offset[0] = 0,
    i.offset[1] = i.scrollLength,
    i.progress = br(0, i.scrollLength, i.current);
    let c = r - l;
    i.velocity = c > F_ ? 0 : qf(i.current - a, c)
}
function I_(e, t, n) {
    Yv(e, "x", t, n),
    Yv(e, "y", t, n),
    t.time = n
}
function O_(e, t) {
    let n = {
        x: 0,
        y: 0
    }
      , r = e;
    for (; r && r !== t; )
        if (r instanceof HTMLElement)
            n.x += r.offsetLeft,
            n.y += r.offsetTop,
            r = r.offsetParent;
        else if (r.tagName === "svg") {
            let i = r.getBoundingClientRect();
            r = r.parentElement;
            let o = r.getBoundingClientRect();
            n.x += i.left - o.left,
            n.y += i.top - o.top
        } else if (r instanceof SVGGraphicsElement) {
            let {x: i, y: o} = r.getBBox();
            n.x += i,
            n.y += o;
            let s = null
              , a = r.parentNode;
            for (; !s; )
                a.tagName === "svg" && (s = a),
                a = r.parentNode;
            r = s
        } else
            break;
    return n
}
var M_ = {
    Enter: [[0, 1], [1, 1]],
    Exit: [[0, 0], [1, 0]],
    Any: [[1, 0], [0, 1]],
    All: [[0, 0], [1, 1]]
}
  , Af = {
    start: 0,
    center: .5,
    end: 1
};
function Kv(e, t, n=0) {
    let r = 0;
    if (e in Af && (e = Af[e]),
    typeof e == "string") {
        let i = parseFloat(e);
        e.endsWith("px") ? r = i : e.endsWith("%") ? e = i / 100 : e.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : e = i
    }
    return typeof e == "number" && (r = t * e),
    n + r
}
var L_ = [0, 0];
function V_(e, t, n, r) {
    let i = Array.isArray(e) ? e : L_
      , o = 0
      , s = 0;
    return typeof e == "number" ? i = [e, e] : typeof e == "string" && (e = e.trim(),
    e.includes(" ") ? i = e.split(" ") : i = [e, Af[e] ? e : "0"]),
    o = Kv(i[0], n, r),
    s = Kv(i[1], t),
    o - s
}
var A_ = {
    x: 0,
    y: 0
};
function D_(e) {
    return "getBBox"in e && e.tagName !== "svg" ? e.getBBox() : {
        width: e.clientWidth,
        height: e.clientHeight
    }
}
function z_(e, t, n) {
    let {offset: r=M_.All} = n
      , {target: i=e, axis: o="y"} = n
      , s = o === "y" ? "height" : "width"
      , a = i !== e ? O_(i, e) : A_
      , l = i === e ? {
        width: e.scrollWidth,
        height: e.scrollHeight
    } : D_(i)
      , c = {
        width: e.clientWidth,
        height: e.clientHeight
    };
    t[o].offset.length = 0;
    let u = !t[o].interpolate
      , f = r.length;
    for (let d = 0; d < f; d++) {
        let p = V_(r[d], c[s], l[s], a[o]);
        !u && p !== t[o].interpolatorOffsets[d] && (u = !0),
        t[o].offset[d] = p
    }
    u && (t[o].interpolate = ho(t[o].offset, Jf(r)),
    t[o].interpolatorOffsets = [...t[o].offset]),
    t[o].progress = t[o].interpolate(t[o].current)
}
function B_(e, t=e, n) {
    if (n.x.targetOffset = 0,
    n.y.targetOffset = 0,
    t !== e) {
        let r = t;
        for (; r && r !== e; )
            n.x.targetOffset += r.offsetLeft,
            n.y.targetOffset += r.offsetTop,
            r = r.offsetParent
    }
    n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth,
    n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight,
    n.x.containerLength = e.clientWidth,
    n.y.containerLength = e.clientHeight
}
function $_(e, t, n, r={}) {
    return {
        measure: () => B_(e, r.target, n),
        update: i => {
            I_(e, n, i),
            (r.offset || r.target) && z_(e, n, r)
        }
        ,
        notify: () => t(n)
    }
}
var as = new WeakMap
  , Qv = new WeakMap
  , mf = new WeakMap
  , Zv = e => e === document.documentElement ? P : e;
function jr(e, {container: t=document.documentElement, ...n}={}) {
    let r = mf.get(t);
    r || (r = new Set,
    mf.set(t, r));
    let i = P_()
      , o = $_(t, e, i, n);
    if (r.add(o),
    !as.has(t)) {
        let a = () => {
            for (let d of r)
                d.measure()
        }
          , l = () => {
            for (let d of r)
                d.update(Ue.timestamp)
        }
          , c = () => {
            for (let d of r)
                d.notify()
        }
          , u = () => {
            Z.read(a, !1, !0),
            Z.read(l, !1, !0),
            Z.update(c, !1, !0)
        }
        ;
        as.set(t, u);
        let f = Zv(t);
        P.addEventListener("resize", u, {
            passive: !0
        }),
        t !== document.documentElement && Qv.set(t, E_(t, u)),
        f.addEventListener("scroll", u, {
            passive: !0
        })
    }
    let s = as.get(t);
    return Z.read(s, !1, !0),
    () => {
        var a;
        Lt(s);
        let l = mf.get(t);
        if (!l || (l.delete(o),
        l.size))
            return;
        let c = as.get(t);
        as.delete(t),
        c && (Zv(t).removeEventListener("scroll", c),
        (a = Qv.get(t)) === null || a === void 0 || a(),
        P.removeEventListener("resize", c))
    }
}
function U0(e, t) {
    let n, r = () => {
        let {currentTime: i} = t
          , s = (i === null ? 0 : i.value) / 100;
        n !== s && e(s),
        n = s
    }
    ;
    return Z.update(r, !0),
    () => Lt(r)
}
function N_({source: e, container: t, axis: n="y"}) {
    e && (t = e);
    let r = {
        value: 0
    }
      , i = jr(o => {
        r.value = o[n].progress * 100
    }
    , {
        container: t,
        axis: n
    });
    return {
        currentTime: r,
        cancel: i
    }
}
var gf = new Map;
function G0({source: e, container: t=document.documentElement, axis: n="y"}={}) {
    e && (t = e),
    gf.has(t) || gf.set(t, {});
    let r = gf.get(t);
    return r[n] || (r[n] = Ay() ? new ScrollTimeline({
        source: t,
        axis: n
    }) : N_({
        source: t,
        axis: n
    })),
    r[n]
}
function j_(e) {
    return e.length === 2
}
function q0(e) {
    return e && (e.target || e.offset)
}
function H_(e, t) {
    return j_(e) || q0(t) ? jr(n => {
        e(n[t.axis].progress, n)
    }
    , t) : U0(e, G0(t))
}
function W_(e, t) {
    if (q0(t))
        return e.pause(),
        jr(n => {
            e.time = e.duration * n[t.axis].progress
        }
        , t);
    {
        let n = G0(t);
        return e.attachTimeline(n, r => (r.pause(),
        U0(i => {
            r.time = r.duration * i
        }
        , n)))
    }
}
function X0(e, {axis: t="y", ...n}={}) {
    let r = {
        axis: t,
        ...n
    };
    return typeof e == "function" ? H_(e, r) : W_(e, r)
}
function Jv(e, t) {
    uo(!!(!t || t.current), `You have defined a ${e} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`)
}
var U_ = () => ({
    scrollX: Ge(0),
    scrollY: Ge(0),
    scrollXProgress: Ge(0),
    scrollYProgress: Ge(0)
});
function Y0({container: e, target: t, layoutEffect: n=!0, ...r}={}) {
    let i = Kn(U_);
    return (n ? Nr : $)( () => (Jv("target", t),
    Jv("container", e),
    X0( (s, {x: a, y: l}) => {
        i.scrollX.set(a.current),
        i.scrollXProgress.set(a.progress),
        i.scrollY.set(l.current),
        i.scrollYProgress.set(l.progress)
    }
    , {
        ...r,
        container: e?.current || void 0,
        target: t?.current || void 0
    })), [e, t, JSON.stringify(r.offset)]),
    i
}
function K0() {
    !xd.current && s0();
    let[e] = Oe(al.current);
    return e
}
function ki() {
    let e = K0()
      , {reducedMotion: t} = D(xr);
    return t === "never" ? !1 : t === "always" ? !0 : e
}
function G_(e) {
    e.values.forEach(t => t.stop())
}
function Df(e, t) {
    [...t].reverse().forEach(r => {
        let i = e.getVariant(r);
        i && ud(e, i),
        e.variantChildren && e.variantChildren.forEach(o => {
            Df(o, t)
        }
        )
    }
    )
}
function q_(e, t) {
    if (Array.isArray(t))
        return Df(e, t);
    if (typeof t == "string")
        return Df(e, [t]);
    ud(e, t)
}
function Q0() {
    let e = !1
      , t = new Set
      , n = {
        subscribe(r) {
            return t.add(r),
            () => void t.delete(r)
        },
        start(r, i) {
            Zt(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
            let o = [];
            return t.forEach(s => {
                o.push(dd(s, r, {
                    transitionOverride: i
                }))
            }
            ),
            Promise.all(o)
        },
        set(r) {
            return Zt(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."),
            t.forEach(i => {
                q_(i, r)
            }
            )
        },
        stop() {
            t.forEach(r => {
                G_(r)
            }
            )
        },
        mount() {
            return e = !0,
            () => {
                e = !1,
                n.stop()
            }
        }
    };
    return n
}
var Z0 = (e, t, n) => {
    let r = t - e;
    return ((n - e) % r + r) % r + e
}
;
function X_(e, t=100, n) {
    let r = n({
        ...e,
        keyframes: [0, t]
    })
      , i = Math.min(Cy(r), Cf);
    return {
        type: "keyframes",
        ease: o => r.next(i * o).value / t,
        duration: Un(i)
    }
}
function Md(e) {
    return typeof e == "object" && !Array.isArray(e)
}
function J0(e, t, n, r) {
    return typeof e == "string" && Md(t) ? Od(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e]
}
function ey(e, t, n, r) {
    var i;
    return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e
}
function Y_(e, t) {
    return by(e) ? e[Z0(0, e.length, t)] : e
}
function K_(e, t, n) {
    for (let r = 0; r < e.length; r++) {
        let i = e[r];
        i.at > t && i.at < n && (ml(e, i),
        r--)
    }
}
function Q_(e, t, n, r, i, o) {
    K_(e, i, o);
    for (let s = 0; s < t.length; s++)
        e.push({
            value: t[s],
            at: Me(i, o, r[s]),
            easing: Y_(n, s)
        })
}
function Z_(e, t) {
    return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at
}
var J_ = "easeInOut";
function eI(e, {defaultTransition: t={}, ...n}={}, r, i) {
    let o = t.duration || .3
      , s = new Map
      , a = new Map
      , l = {}
      , c = new Map
      , u = 0
      , f = 0
      , d = 0;
    for (let p = 0; p < e.length; p++) {
        let v = e[p];
        if (typeof v == "string") {
            c.set(v, f);
            continue
        } else if (!Array.isArray(v)) {
            c.set(v.name, ey(f, v.at, u, c));
            continue
        }
        let[g,b,m={}] = v;
        m.at !== void 0 && (f = ey(f, m.at, u, c));
        let h = 0
          , y = (w, C, S, T=0, E=0) => {
            let I = tI(w)
              , {delay: O=0, times: B=Jf(I), type: z="keyframes", ...j} = C
              , {ease: J=t.ease || "easeOut", duration: H} = C
              , fe = typeof O == "function" ? O(T, E) : O
              , ie = I.length
              , q = dl(z) ? z : i?.[z];
            if (ie <= 2 && q) {
                let me = 100;
                if (ie === 2 && iI(I)) {
                    let Ye = I[1] - I[0];
                    me = Math.abs(Ye)
                }
                let ae = {
                    ...j
                };
                H !== void 0 && (ae.duration = In(H));
                let X = X_(ae, me, q);
                J = X.ease,
                H = X.duration
            }
            H ?? (H = o);
            let re = f + fe
              , U = re + H;
            B.length === 1 && B[0] === 0 && (B[1] = 1);
            let pe = B.length - I.length;
            pe > 0 && xy(B, pe),
            I.length === 1 && I.unshift(null),
            Q_(S, I, J, B, re, U),
            h = Math.max(fe + H, h),
            d = Math.max(U, d)
        }
        ;
        if (De(g)) {
            let w = ty(g, a);
            y(b, m, ny("default", w))
        } else {
            let w = J0(g, b, r, l)
              , C = w.length;
            for (let S = 0; S < C; S++) {
                b = b,
                m = m;
                let T = w[S]
                  , E = ty(T, a);
                for (let I in b)
                    y(b[I], nI(m, I), ny(I, E), S, C)
            }
        }
        u = f,
        f += h
    }
    return a.forEach( (p, v) => {
        for (let g in p) {
            let b = p[g];
            b.sort(Z_);
            let m = []
              , h = []
              , y = [];
            for (let C = 0; C < b.length; C++) {
                let {at: S, value: T, easing: E} = b[C];
                m.push(T),
                h.push(br(0, d, S)),
                y.push(E || "easeOut")
            }
            h[0] !== 0 && (h.unshift(0),
            m.unshift(m[0]),
            y.unshift(J_)),
            h[h.length - 1] !== 1 && (h.push(1),
            m.push(null)),
            s.has(v) || s.set(v, {
                keyframes: {},
                transition: {}
            });
            let w = s.get(v);
            w.keyframes[g] = m,
            w.transition[g] = {
                ...t,
                duration: d,
                ease: y,
                times: h,
                ...n
            }
        }
    }
    ),
    s
}
function ty(e, t) {
    return !t.has(e) && t.set(e, {}),
    t.get(e)
}
function ny(e, t) {
    return t[e] || (t[e] = []),
    t[e]
}
function tI(e) {
    return Array.isArray(e) ? e : [e]
}
function nI(e, t) {
    return e && e[t] ? {
        ...e,
        ...e[t]
    } : {
        ...e
    }
}
var rI = e => typeof e == "number"
  , iI = e => e.every(rI);
function oI(e, t) {
    return e in t
}
var sI = class extends wd {
    constructor() {
        super(...arguments),
        this.type = "object"
    }
    readValueFromInstance(e, t) {
        if (oI(t, e)) {
            let n = e[t];
            if (typeof n == "string" || typeof n == "number")
                return n
        }
    }
    getBaseTargetFromProps() {}
    removeValueFromRenderState(e, t) {
        delete t.output[e]
    }
    measureInstanceViewportBox() {
        return Be()
    }
    build(e, t) {
        Object.assign(e.output, t)
    }
    renderInstance(e, {output: t}) {
        Object.assign(e, t)
    }
    sortInstanceNodePosition() {
        return 0
    }
}
;
function aI(e) {
    let t = {
        presenceContext: null,
        props: {},
        visualState: {
            renderState: {
                transform: {},
                transformOrigin: {},
                style: {},
                vars: {},
                attrs: {}
            },
            latestValues: {}
        }
    }
      , n = b0(e) ? new z0(t) : new D0(t);
    n.mount(e),
    Yn.set(e, n)
}
function lI(e) {
    let t = {
        presenceContext: null,
        props: {},
        visualState: {
            renderState: {
                output: {}
            },
            latestValues: {}
        }
    }
      , n = new sI(t);
    n.mount(e),
    Yn.set(e, n)
}
function cI(e, t) {
    return De(e) || typeof e == "number" || typeof e == "string" && !Md(t)
}
function eb(e, t, n, r) {
    let i = [];
    if (cI(e, t))
        i.push(x0(e, Md(t) && t.default || t, n && (n.default || n)));
    else {
        let o = J0(e, t, r)
          , s = o.length;
        Zt(!!s, "No valid elements provided.");
        for (let a = 0; a < s; a++) {
            let l = o[a]
              , c = l instanceof Element ? aI : lI;
            Yn.has(l) || c(l);
            let u = Yn.get(l)
              , f = {
                ...n
            };
            "delay"in f && typeof f.delay == "function" && (f.delay = f.delay(a, s)),
            i.push(...fd(u, {
                ...t,
                transition: f
            }, {}))
        }
    }
    return i
}
function uI(e, t, n) {
    let r = [];
    return eI(e, t, n, {
        spring: ks
    }).forEach( ({keyframes: o, transition: s}, a) => {
        r.push(...eb(a, o, s))
    }
    ),
    r
}
function fI(e) {
    return Array.isArray(e) && Array.isArray(e[0])
}
function tb(e) {
    function t(n, r, i) {
        let o = [];
        fI(n) ? o = uI(n, r, e) : o = eb(n, r, i, e);
        let s = new Dy(o);
        return e && e.animations.push(s),
        s
    }
    return t
}
var Zn = tb();
function nb() {
    let e = Kn(Q0);
    return Nr(e.mount, []),
    e
}
var rb = nb;
var dI = {
    some: 0,
    all: 1
};
function Ld(e, t, {root: n, margin: r, amount: i="some"}={}) {
    let o = Od(e)
      , s = new WeakMap
      , a = c => {
        c.forEach(u => {
            let f = s.get(u.target);
            if (u.isIntersecting !== !!f)
                if (u.isIntersecting) {
                    let d = t(u);
                    typeof d == "function" ? s.set(u.target, d) : l.unobserve(u.target)
                } else
                    f && (f(u),
                    s.delete(u.target))
        }
        )
    }
      , l = new IntersectionObserver(a,{
        root: n,
        rootMargin: r,
        threshold: typeof i == "number" ? i : dI[i]
    });
    return o.forEach(c => l.observe(c)),
    () => l.disconnect()
}
function Rl(e) {
    return e !== null && typeof e == "object" && bd in e
}
function Vd(e) {
    if (Rl(e))
        return e[bd]
}
function Ad() {
    return hI
}
function hI(e) {
    Si.current && (Si.current.isUpdating = !1,
    Si.current.blockUpdate(),
    e && e())
}
function ib() {
    let[e,t] = _d()
      , n = Ad()
      , r = V();
    return $( () => {
        Z.postRender( () => Z.postRender( () => {
            t === r.current && (rl.current = !1)
        }
        ))
    }
    , [t]),
    i => {
        n( () => {
            rl.current = !0,
            e(),
            i(),
            r.current = t + 1
        }
        )
    }
}
function ob() {
    return K( () => {
        let t = Si.current;
        t && t.resetTree()
    }
    , [])
}
var ry = () => ({});
var FN = Tl({
    scrapeMotionValuesFromProps: ry,
    createRenderState: ry
});
var sb = {};
wg(sb, {
    Group: () => gI,
    Item: () => xI
});
var ab = ve(null);
function pI(e, t, n, r) {
    if (!r)
        return e;
    let i = e.findIndex(u => u.value === t);
    if (i === -1)
        return e;
    let o = r > 0 ? 1 : -1
      , s = e[i + o];
    if (!s)
        return e;
    let a = e[i]
      , l = s.layout
      , c = Me(l.min, l.max, .5);
    return o === 1 && a.layout.max + n > c || o === -1 && a.layout.min + n < c ? GE(e, i, i + o) : e
}
function mI({children: e, as: t="ul", axis: n="y", onReorder: r, values: i, ...o}, s) {
    let a = Kn( () => Jt[t])
      , l = []
      , c = V(!1);
    Zt(!!i, "Reorder.Group must be provided a values prop");
    let u = {
        axis: n,
        registerItem: (f, d) => {
            let p = l.findIndex(v => f === v.value);
            p !== -1 ? l[p].layout = d[n] : l.push({
                value: f,
                layout: d[n]
            }),
            l.sort(yI)
        }
        ,
        updateOrder: (f, d, p) => {
            if (c.current)
                return;
            let v = pI(l, f, d, p);
            l !== v && (c.current = !0,
            r(v.map(vI).filter(g => i.indexOf(g) !== -1)))
        }
    };
    return $( () => {
        c.current = !1
    }
    ),
    k(a, {
        ...o,
        ref: s,
        ignoreStrict: !0,
        children: k(ab.Provider, {
            value: u,
            children: e
        })
    })
}
var gI = Ie(mI);
function vI(e) {
    return e.value
}
function yI(e, t) {
    return e.layout.min - t.layout.min
}
function iy(e, t=0) {
    return De(e) ? e : Qn(t)
}
function bI({children: e, style: t={}, value: n, as: r="li", onDrag: i, layout: o=!0, ...s}, a) {
    let l = Kn( () => Jt[r])
      , c = D(ab)
      , u = {
        x: iy(t.x),
        y: iy(t.y)
    }
      , f = Vt([u.x, u.y], ([g,b]) => g || b ? 1 : "unset");
    Zt(!!c, "Reorder.Item must be a child of Reorder.Group");
    let {axis: d, registerItem: p, updateOrder: v} = c;
    return k(l, {
        drag: d,
        ...s,
        dragSnapToOrigin: !0,
        style: {
            ...t,
            x: u.x,
            y: u.y,
            zIndex: f
        },
        layout: o,
        onDrag: (g, b) => {
            let {velocity: m} = b;
            m[d] && v(n, u[d].get(), m[d]),
            i && i(g, b)
        }
        ,
        onLayoutMeasure: g => p(n, g),
        ref: a,
        ignoreStrict: !0,
        children: e
    })
}
var xI = Ie(bI);
function wI(e, t) {
    if (e === "first")
        return 0;
    {
        let n = t - 1;
        return e === "last" ? n : n / 2
    }
}
function Dd(e=.1, {startDelay: t=0, from: n=0, ease: r}={}) {
    return (i, o) => {
        let s = typeof n == "number" ? n : wI(n, o)
          , a = Math.abs(s - i)
          , l = e * a;
        if (r) {
            let c = o * e;
            l = wf(r)(l / c) * c
        }
        return t + l
    }
}
var SI = ls.reduce( (e, t) => (e[t] = n => Lt(n),
e), {});
var rM = {};
Ku(rM, {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => UO,
    createPortal: () => GO,
    createRoot: () => qO,
    default: () => CS,
    findDOMNode: () => XO,
    flushSync: () => YO,
    hydrate: () => KO,
    hydrateRoot: () => QO,
    render: () => ZO,
    unmountComponentAtNode: () => JO,
    unstable_batchedUpdates: () => eM,
    unstable_renderSubtreeIntoContainer: () => tM,
    version: () => nM
});
var Ol = {};
Ku(Ol, {
    default: () => ee,
    unstable_IdlePriority: () => TI,
    unstable_ImmediatePriority: () => RI,
    unstable_LowPriority: () => EI,
    unstable_NormalPriority: () => FI,
    unstable_Profiling: () => PI,
    unstable_UserBlockingPriority: () => _I,
    unstable_cancelCallback: () => II,
    unstable_continueExecution: () => OI,
    unstable_forceFrameRate: () => MI,
    unstable_getCurrentPriorityLevel: () => LI,
    unstable_getFirstCallbackNode: () => VI,
    unstable_next: () => AI,
    unstable_now: () => CI,
    unstable_pauseExecution: () => DI,
    unstable_requestPaint: () => zI,
    unstable_runWithPriority: () => BI,
    unstable_scheduleCallback: () => $I,
    unstable_shouldYield: () => NI,
    unstable_wrapCallback: () => jI
});
var ee = {};
function Nd(e, t) {
    var n = e.length;
    e.push(t);
    e: for (; 0 < n; ) {
        var r = n - 1 >>> 1
          , i = e[r];
        if (!(0 < El(i, t)))
            break e;
        e[r] = t,
        e[n] = i,
        n = r
    }
}
function On(e) {
    return e.length === 0 ? null : e[0]
}
function Pl(e) {
    if (e.length === 0)
        return null;
    var t = e[0]
      , n = e.pop();
    if (n !== t) {
        e[0] = n;
        e: for (var r = 0, i = e.length, o = i >>> 1; r < o; ) {
            var s = 2 * (r + 1) - 1
              , a = e[s]
              , l = s + 1
              , c = e[l];
            if (0 > El(a, n))
                l < i && 0 > El(c, a) ? (e[r] = c,
                e[l] = n,
                r = l) : (e[r] = a,
                e[s] = n,
                r = s);
            else {
                if (!(l < i && 0 > El(c, n)))
                    break e;
                e[r] = c,
                e[l] = n,
                r = l
            }
        }
    }
    return t
}
function El(e, t) {
    var n = e.sortIndex - t.sortIndex;
    return n !== 0 ? n : e.id - t.id
}
typeof performance == "object" && typeof performance.now == "function" ? (lb = performance,
ee.unstable_now = function() {
    return lb.now()
}
) : (zd = Date,
cb = zd.now(),
ee.unstable_now = function() {
    return zd.now() - cb
}
);
var lb, zd, cb, Jn = [], Hr = [], kI = 1, bn = null, Tt = 3, _l = !1, Ci = !1, Fs = !1, db = typeof setTimeout == "function" ? setTimeout : null, hb = typeof clearTimeout == "function" ? clearTimeout : null, ub = typeof setImmediate < "u" ? setImmediate : null;
typeof Fe < "u" && Fe.scheduling !== void 0 && Fe.scheduling.isInputPending !== void 0 && Fe.scheduling.isInputPending.bind(Fe.scheduling);
function jd(e) {
    for (var t = On(Hr); t !== null; ) {
        if (t.callback === null)
            Pl(Hr);
        else {
            if (!(t.startTime <= e))
                break;
            Pl(Hr),
            t.sortIndex = t.expirationTime,
            Nd(Jn, t)
        }
        t = On(Hr)
    }
}
function Hd(e) {
    if (Fs = !1,
    jd(e),
    !Ci)
        if (On(Jn) !== null)
            Ci = !0,
            Ud(Wd);
        else {
            var t = On(Hr);
            t !== null && Gd(Hd, t.startTime - e)
        }
}
function Wd(e, t) {
    Ci = !1,
    Fs && (Fs = !1,
    hb(Ps),
    Ps = -1),
    _l = !0;
    var n = Tt;
    try {
        for (jd(t),
        bn = On(Jn); bn !== null && (!(bn.expirationTime > t) || e && !gb()); ) {
            var r = bn.callback;
            if (typeof r == "function") {
                bn.callback = null,
                Tt = bn.priorityLevel;
                var i = r(bn.expirationTime <= t);
                t = ee.unstable_now(),
                typeof i == "function" ? bn.callback = i : bn === On(Jn) && Pl(Jn),
                jd(t)
            } else
                Pl(Jn);
            bn = On(Jn)
        }
        if (bn !== null)
            var o = !0;
        else {
            var s = On(Hr);
            s !== null && Gd(Hd, s.startTime - t),
            o = !1
        }
        return o
    } finally {
        bn = null,
        Tt = n,
        _l = !1
    }
}
var Il = !1
  , Fl = null
  , Ps = -1
  , pb = 5
  , mb = -1;
function gb() {
    return !(ee.unstable_now() - mb < pb)
}
function Bd() {
    if (Fl !== null) {
        var e = ee.unstable_now();
        mb = e;
        var t = !0;
        try {
            t = Fl(!0, e)
        } finally {
            t ? Es() : (Il = !1,
            Fl = null)
        }
    } else
        Il = !1
}
var Es;
typeof ub == "function" ? Es = function() {
    ub(Bd)
}
: typeof MessageChannel < "u" ? ($d = new MessageChannel,
fb = $d.port2,
$d.port1.onmessage = Bd,
Es = function() {
    fb.postMessage(null)
}
) : Es = function() {
    db(Bd, 0)
}
;
var $d, fb;
function Ud(e) {
    Fl = e,
    Il || (Il = !0,
    Es())
}
function Gd(e, t) {
    Ps = db(function() {
        e(ee.unstable_now())
    }, t)
}
ee.unstable_IdlePriority = 5;
ee.unstable_ImmediatePriority = 1;
ee.unstable_LowPriority = 4;
ee.unstable_NormalPriority = 3;
ee.unstable_Profiling = null;
ee.unstable_UserBlockingPriority = 2;
ee.unstable_cancelCallback = function(e) {
    e.callback = null
}
;
ee.unstable_continueExecution = function() {
    Ci || _l || (Ci = !0,
    Ud(Wd))
}
;
ee.unstable_forceFrameRate = function(e) {
    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : pb = 0 < e ? Math.floor(1e3 / e) : 5
}
;
ee.unstable_getCurrentPriorityLevel = function() {
    return Tt
}
;
ee.unstable_getFirstCallbackNode = function() {
    return On(Jn)
}
;
ee.unstable_next = function(e) {
    switch (Tt) {
    case 1:
    case 2:
    case 3:
        var t = 3;
        break;
    default:
        t = Tt
    }
    var n = Tt;
    Tt = t;
    try {
        return e()
    } finally {
        Tt = n
    }
}
;
ee.unstable_pauseExecution = function() {}
;
ee.unstable_requestPaint = function() {}
;
ee.unstable_runWithPriority = function(e, t) {
    switch (e) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        break;
    default:
        e = 3
    }
    var n = Tt;
    Tt = e;
    try {
        return t()
    } finally {
        Tt = n
    }
}
;
ee.unstable_scheduleCallback = function(e, t, n) {
    var r = ee.unstable_now();
    switch (typeof n == "object" && n !== null ? (n = n.delay,
    n = typeof n == "number" && 0 < n ? r + n : r) : n = r,
    e) {
    case 1:
        var i = -1;
        break;
    case 2:
        i = 250;
        break;
    case 5:
        i = 1073741823;
        break;
    case 4:
        i = 1e4;
        break;
    default:
        i = 5e3
    }
    return i = n + i,
    e = {
        id: kI++,
        callback: t,
        priorityLevel: e,
        startTime: n,
        expirationTime: i,
        sortIndex: -1
    },
    n > r ? (e.sortIndex = n,
    Nd(Hr, e),
    On(Jn) === null && e === On(Hr) && (Fs ? (hb(Ps),
    Ps = -1) : Fs = !0,
    Gd(Hd, n - r))) : (e.sortIndex = i,
    Nd(Jn, e),
    Ci || _l || (Ci = !0,
    Ud(Wd))),
    e
}
;
ee.unstable_shouldYield = gb;
ee.unstable_wrapCallback = function(e) {
    var t = Tt;
    return function() {
        var n = Tt;
        Tt = t;
        try {
            return e.apply(this, arguments)
        } finally {
            Tt = n
        }
    }
}
;
var CI = ee.unstable_now
  , TI = ee.unstable_IdlePriority
  , RI = ee.unstable_ImmediatePriority
  , EI = ee.unstable_LowPriority
  , FI = ee.unstable_NormalPriority
  , PI = ee.unstable_Profiling
  , _I = ee.unstable_UserBlockingPriority
  , II = ee.unstable_cancelCallback
  , OI = ee.unstable_continueExecution
  , MI = ee.unstable_forceFrameRate
  , LI = ee.unstable_getCurrentPriorityLevel
  , VI = ee.unstable_getFirstCallbackNode
  , AI = ee.unstable_next
  , DI = ee.unstable_pauseExecution
  , zI = ee.unstable_requestPaint
  , BI = ee.unstable_runWithPriority
  , $I = ee.unstable_scheduleCallback
  , NI = ee.unstable_shouldYield
  , jI = ee.unstable_wrapCallback;
var HI = "default"in kt ? x : kt
  , WI = "default"in Ol ? ee : Ol
  , on = {}
  , kx = HI
  , rn = WI;
function M(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
        t += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var Cx = new Set
  , Qs = {};
function Di(e, t) {
    Vo(e, t),
    Vo(e + "Capture", t)
}
function Vo(e, t) {
    for (Qs[e] = t,
    e = 0; e < t.length; e++)
        Cx.add(t[e])
}
var Rr = !(typeof P > "u" || typeof P.document > "u" || typeof P.document.createElement > "u")
  , mh = Object.prototype.hasOwnProperty
  , UI = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , vb = {}
  , yb = {};
function GI(e) {
    return mh.call(yb, e) ? !0 : mh.call(vb, e) ? !1 : UI.test(e) ? yb[e] = !0 : (vb[e] = !0,
    !1)
}
function qI(e, t, n, r) {
    if (n !== null && n.type === 0)
        return !1;
    switch (typeof t) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
        e !== "data-" && e !== "aria-");
    default:
        return !1
    }
}
function XI(e, t, n, r) {
    if (t === null || typeof t > "u" || qI(e, t, n, r))
        return !0;
    if (r)
        return !1;
    if (n !== null)
        switch (n.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
        }
    return !1
}
function zt(e, t, n, r, i, o, s) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4,
    this.attributeName = r,
    this.attributeNamespace = i,
    this.mustUseProperty = n,
    this.propertyName = e,
    this.type = t,
    this.sanitizeURL = o,
    this.removeEmptyString = s
}
var wt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    wt[e] = new zt(e,0,!1,e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
    var t = e[0];
    wt[t] = new zt(t,1,!1,e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    wt[e] = new zt(e,2,!1,e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    wt[e] = new zt(e,2,!1,e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    wt[e] = new zt(e,3,!1,e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    wt[e] = new zt(e,3,!0,e,null,!1,!1)
});
["capture", "download"].forEach(function(e) {
    wt[e] = new zt(e,4,!1,e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    wt[e] = new zt(e,6,!1,e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(e) {
    wt[e] = new zt(e,5,!1,e.toLowerCase(),null,!1,!1)
});
var sp = /[\-:]([a-z])/g;
function ap(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(sp, ap);
    wt[t] = new zt(t,1,!1,e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(sp, ap);
    wt[t] = new zt(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(sp, ap);
    wt[t] = new zt(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    wt[e] = new zt(e,1,!1,e.toLowerCase(),null,!1,!1)
});
wt.xlinkHref = new zt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(e) {
    wt[e] = new zt(e,1,!1,e.toLowerCase(),null,!0,!0)
});
function lp(e, t, n, r) {
    var i = wt.hasOwnProperty(t) ? wt[t] : null;
    (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (XI(t, n, i, r) && (n = null),
    r || i === null ? GI(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && "" : n : (t = i.attributeName,
    r = i.attributeNamespace,
    n === null ? e.removeAttribute(t) : (i = i.type,
    n = i === 3 || i === 4 && n === !0 ? "" : "" + n,
    r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var _r = kx.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Ml = Symbol.for("react.element")
  , vo = Symbol.for("react.portal")
  , yo = Symbol.for("react.fragment")
  , cp = Symbol.for("react.strict_mode")
  , gh = Symbol.for("react.profiler")
  , Tx = Symbol.for("react.provider")
  , Rx = Symbol.for("react.context")
  , up = Symbol.for("react.forward_ref")
  , vh = Symbol.for("react.suspense")
  , yh = Symbol.for("react.suspense_list")
  , fp = Symbol.for("react.memo")
  , Ur = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var Ex = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.cache");
Symbol.for("react.tracing_marker");
var bb = Symbol.iterator;
function _s(e) {
    return e === null || typeof e != "object" ? null : (e = bb && e[bb] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var qd, je = Object.assign;
function zs(e) {
    if (qd === void 0)
        try {
            throw Error()
        } catch (n) {
            var t = n.stack.trim().match(/\n( *(at )?)/);
            qd = t && t[1] || ""
        }
    return `
` + qd + e
}
var Xd = !1;
function Yd(e, t) {
    if (!e || Xd)
        return "";
    Xd = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                throw Error()
            }
            ,
            Object.defineProperty(t.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (c) {
                    r = c
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            e()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a]; )
                a--;
            for (; 1 <= s && 0 <= a; s--,
            a--)
                if (i[s] !== o[a]) {
                    if (s !== 1 || a !== 1)
                        do
                            if (s--,
                            a--,
                            0 > a || i[s] !== o[a]) {
                                var l = `
` + i[s].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                l
                            }
                        while (1 <= s && 0 <= a);
                    break
                }
        }
    } finally {
        Xd = !1,
        Error.prepareStackTrace = n
    }
    return (e = e ? e.displayName || e.name : "") ? zs(e) : ""
}
function YI(e) {
    switch (e.tag) {
    case 5:
        return zs(e.type);
    case 16:
        return zs("Lazy");
    case 13:
        return zs("Suspense");
    case 19:
        return zs("SuspenseList");
    case 0:
    case 2:
    case 15:
        return e = Yd(e.type, !1),
        e;
    case 11:
        return e = Yd(e.type.render, !1),
        e;
    case 1:
        return e = Yd(e.type, !0),
        e;
    default:
        return ""
    }
}
function bh(e) {
    if (e == null)
        return null;
    if (typeof e == "function")
        return e.displayName || e.name || null;
    if (typeof e == "string")
        return e;
    switch (e) {
    case yo:
        return "Fragment";
    case vo:
        return "Portal";
    case gh:
        return "Profiler";
    case cp:
        return "StrictMode";
    case vh:
        return "Suspense";
    case yh:
        return "SuspenseList"
    }
    if (typeof e == "object")
        switch (e.$$typeof) {
        case Rx:
            return (e.displayName || "Context") + ".Consumer";
        case Tx:
            return (e._context.displayName || "Context") + ".Provider";
        case up:
            var t = e.render;
            return e = e.displayName,
            e || (e = t.displayName || t.name || "",
            e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
            e;
        case fp:
            return t = e.displayName || null,
            t !== null ? t : bh(e.type) || "Memo";
        case Ur:
            t = e._payload,
            e = e._init;
            try {
                return bh(e(t))
            } catch {}
        }
    return null
}
function KI(e) {
    var t = e.type;
    switch (e.tag) {
    case 24:
        return "Cache";
    case 9:
        return (t.displayName || "Context") + ".Consumer";
    case 10:
        return (t._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return e = t.render,
        e = e.displayName || e.name || "",
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return t;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return bh(t);
    case 8:
        return t === cp ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof t == "function")
            return t.displayName || t.name || null;
        if (typeof t == "string")
            return t
    }
    return null
}
function oi(e) {
    switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return e;
    case "object":
        return e;
    default:
        return ""
    }
}
function Fx(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function QI(e) {
    var t = Fx(e) ? "checked" : "value"
      , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
      , r = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get
          , o = n.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(s) {
                r = "" + s,
                o.call(this, s)
            }
        }),
        Object.defineProperty(e, t, {
            enumerable: n.enumerable
        }),
        {
            getValue: function() {
                return r
            },
            setValue: function(s) {
                r = "" + s
            },
            stopTracking: function() {
                e._valueTracker = null,
                delete e[t]
            }
        }
    }
}
function Ll(e) {
    e._valueTracker || (e._valueTracker = QI(e))
}
function Px(e) {
    if (!e)
        return !1;
    var t = e._valueTracker;
    if (!t)
        return !0;
    var n = t.getValue()
      , r = "";
    return e && (r = Fx(e) ? e.checked ? "true" : "false" : e.value),
    e = r,
    e !== n && (t.setValue(e),
    !0)
}
function lc(e) {
    if (e = e || (typeof document < "u" ? document : void 0),
    typeof e > "u")
        return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}
function xh(e, t) {
    var n = t.checked;
    return je({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ?? e._wrapperState.initialChecked
    })
}
function xb(e, t) {
    var n = t.defaultValue == null ? "" : t.defaultValue
      , r = t.checked != null ? t.checked : t.defaultChecked;
    n = oi(t.value != null ? t.value : n),
    e._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}
function _x(e, t) {
    t = t.checked,
    t != null && lp(e, "checked", t, !1)
}
function wh(e, t) {
    _x(e, t);
    var n = oi(t.value)
      , r = t.type;
    if (n != null)
        r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if (r === "submit" || r === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? Sh(e, t.type, n) : t.hasOwnProperty("defaultValue") && Sh(e, t.type, oi(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function wb(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var r = t.type;
        if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null))
            return;
        t = "" + e._wrapperState.initialValue,
        n || t === e.value || (e.value = t),
        e.defaultValue = t
    }
    n = e.name,
    n !== "" && (e.name = ""),
    e.defaultChecked = !!e._wrapperState.initialChecked,
    n !== "" && (e.name = n)
}
function Sh(e, t, n) {
    t === "number" && lc(e.ownerDocument) === e || (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Bs = Array.isArray;
function Po(e, t, n, r) {
    if (e = e.options,
    t) {
        t = {};
        for (var i = 0; i < n.length; i++)
            t["$" + n[i]] = !0;
        for (n = 0; n < e.length; n++)
            i = t.hasOwnProperty("$" + e[n].value),
            e[n].selected !== i && (e[n].selected = i),
            i && r && (e[n].defaultSelected = !0)
    } else {
        for (n = "" + oi(n),
        t = null,
        i = 0; i < e.length; i++) {
            if (e[i].value === n) {
                e[i].selected = !0,
                r && (e[i].defaultSelected = !0);
                return
            }
            t !== null || e[i].disabled || (t = e[i])
        }
        t !== null && (t.selected = !0)
    }
}
function kh(e, t) {
    if (t.dangerouslySetInnerHTML != null)
        throw Error(M(91));
    return je({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}
function Sb(e, t) {
    var n = t.value;
    if (n == null) {
        if (n = t.children,
        t = t.defaultValue,
        n != null) {
            if (t != null)
                throw Error(M(92));
            if (Bs(n)) {
                if (1 < n.length)
                    throw Error(M(93));
                n = n[0]
            }
            t = n
        }
        t == null && (t = ""),
        n = t
    }
    e._wrapperState = {
        initialValue: oi(n)
    }
}
function Ix(e, t) {
    var n = oi(t.value)
      , r = oi(t.defaultValue);
    n != null && (n = "" + n,
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = "" + r)
}
function kb(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function Ox(e) {
    switch (e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Ch(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? Ox(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Vl, Mx = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, n, r, i)
        })
    }
    : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in e)
        e.innerHTML = t;
    else {
        for (Vl = Vl || document.createElement("div"),
        Vl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
        t = Vl.firstChild; e.firstChild; )
            e.removeChild(e.firstChild);
        for (; t.firstChild; )
            e.appendChild(t.firstChild)
    }
});
function Zs(e, t) {
    if (t) {
        var n = e.firstChild;
        if (n && n === e.lastChild && n.nodeType === 3) {
            n.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var js = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , ZI = ["Webkit", "ms", "Moz", "O"];
Object.keys(js).forEach(function(e) {
    ZI.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1),
        js[t] = js[e]
    })
});
function Lx(e, t, n) {
    return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || js.hasOwnProperty(e) && js[e] ? ("" + t).trim() : t + "px"
}
function Vx(e, t) {
    e = e.style;
    for (var n in t)
        if (t.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0
              , i = Lx(n, t[n], r);
            n === "float" && (n = "cssFloat"),
            r ? e.setProperty(n, i) : e[n] = i
        }
}
var JI = je({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Th(e, t) {
    if (t) {
        if (JI[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
            throw Error(M(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null)
                throw Error(M(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html"in t.dangerouslySetInnerHTML))
                throw Error(M(61))
        }
        if (t.style != null && typeof t.style != "object")
            throw Error(M(62))
    }
}
function Rh(e, t) {
    if (e.indexOf("-") === -1)
        return typeof t.is == "string";
    switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Eh = null;
function dp(e) {
    return e = e.target || e.srcElement || P,
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
}
var Fh = null
  , _o = null
  , Io = null;
function Cb(e) {
    if (e = ga(e)) {
        if (typeof Fh != "function")
            throw Error(M(280));
        var t = e.stateNode;
        t && (t = Ac(t),
        Fh(e.stateNode, e.type, t))
    }
}
function Ax(e) {
    _o ? Io ? Io.push(e) : Io = [e] : _o = e
}
function Dx() {
    if (_o) {
        var e = _o
          , t = Io;
        if (Io = _o = null,
        Cb(e),
        t)
            for (e = 0; e < t.length; e++)
                Cb(t[e])
    }
}
function zx(e, t) {
    return e(t)
}
function Bx() {}
var Kd = !1;
function $x(e, t, n) {
    if (Kd)
        return e(t, n);
    Kd = !0;
    try {
        return zx(e, t, n)
    } finally {
        Kd = !1,
        (_o !== null || Io !== null) && (Bx(),
        Dx())
    }
}
function Js(e, t) {
    var n = e.stateNode;
    if (n === null)
        return null;
    var r = Ac(n);
    if (r === null)
        return null;
    n = r[t];
    e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (r = !r.disabled) || (e = e.type,
        r = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
        e = !r;
        break e;
    default:
        e = !1
    }
    if (e)
        return null;
    if (n && typeof n != "function")
        throw Error(M(231, t, typeof n));
    return n
}
var Ph = !1;
if (Rr)
    try {
        mo = {},
        Object.defineProperty(mo, "passive", {
            get: function() {
                Ph = !0
            }
        }),
        P.addEventListener("test", mo, mo),
        P.removeEventListener("test", mo, mo)
    } catch {
        Ph = !1
    }
var mo;
function e2(e, t, n, r, i, o, s, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(n, c)
    } catch (u) {
        this.onError(u)
    }
}
var Hs = !1
  , cc = null
  , uc = !1
  , _h = null
  , t2 = {
    onError: function(e) {
        Hs = !0,
        cc = e
    }
};
function n2(e, t, n, r, i, o, s, a, l) {
    Hs = !1,
    cc = null,
    e2.apply(t2, arguments)
}
function r2(e, t, n, r, i, o, s, a, l) {
    if (n2.apply(this, arguments),
    Hs) {
        if (!Hs)
            throw Error(M(198));
        var c = cc;
        Hs = !1,
        cc = null,
        uc || (uc = !0,
        _h = c)
    }
}
function zi(e) {
    var t = e
      , n = e;
    if (e.alternate)
        for (; t.return; )
            t = t.return;
    else {
        e = t;
        do
            t = e,
            4098 & t.flags && (n = t.return),
            e = t.return;
        while (e)
    }
    return t.tag === 3 ? n : null
}
function Nx(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate,
        e !== null && (t = e.memoizedState)),
        t !== null)
            return t.dehydrated
    }
    return null
}
function Tb(e) {
    if (zi(e) !== e)
        throw Error(M(188))
}
function i2(e) {
    var t = e.alternate;
    if (!t) {
        if (t = zi(e),
        t === null)
            throw Error(M(188));
        return t !== e ? null : e
    }
    for (var n = e, r = t; ; ) {
        var i = n.return;
        if (i === null)
            break;
        var o = i.alternate;
        if (o === null) {
            if (r = i.return,
            r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === o.child) {
            for (o = i.child; o; ) {
                if (o === n)
                    return Tb(i),
                    e;
                if (o === r)
                    return Tb(i),
                    t;
                o = o.sibling
            }
            throw Error(M(188))
        }
        if (n.return !== r.return)
            n = i,
            r = o;
        else {
            for (var s = !1, a = i.child; a; ) {
                if (a === n) {
                    s = !0,
                    n = i,
                    r = o;
                    break
                }
                if (a === r) {
                    s = !0,
                    r = i,
                    n = o;
                    break
                }
                a = a.sibling
            }
            if (!s) {
                for (a = o.child; a; ) {
                    if (a === n) {
                        s = !0,
                        n = o,
                        r = i;
                        break
                    }
                    if (a === r) {
                        s = !0,
                        r = o,
                        n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!s)
                    throw Error(M(189))
            }
        }
        if (n.alternate !== r)
            throw Error(M(190))
    }
    if (n.tag !== 3)
        throw Error(M(188));
    return n.stateNode.current === n ? e : t
}
function jx(e) {
    return e = i2(e),
    e !== null ? Hx(e) : null
}
function Hx(e) {
    if (e.tag === 5 || e.tag === 6)
        return e;
    for (e = e.child; e !== null; ) {
        var t = Hx(e);
        if (t !== null)
            return t;
        e = e.sibling
    }
    return null
}
var Wx = rn.unstable_scheduleCallback
  , Rb = rn.unstable_cancelCallback
  , o2 = rn.unstable_shouldYield
  , s2 = rn.unstable_requestPaint
  , Ze = rn.unstable_now
  , a2 = rn.unstable_getCurrentPriorityLevel
  , hp = rn.unstable_ImmediatePriority
  , Ux = rn.unstable_UserBlockingPriority
  , fc = rn.unstable_NormalPriority
  , l2 = rn.unstable_LowPriority
  , Gx = rn.unstable_IdlePriority
  , Oc = null
  , rr = null;
function c2(e) {
    if (rr && typeof rr.onCommitFiberRoot == "function")
        try {
            rr.onCommitFiberRoot(Oc, e, void 0, (128 & e.current.flags) === 128)
        } catch {}
}
var Dn = Math.clz32 ? Math.clz32 : d2
  , u2 = Math.log
  , f2 = Math.LN2;
function d2(e) {
    return e >>>= 0,
    e === 0 ? 32 : 31 - (u2(e) / f2 | 0) | 0
}
var Al = 64
  , Dl = 4194304;
function $s(e) {
    switch (e & -e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return 4194240 & e;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return 130023424 & e;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return e
    }
}
function dc(e, t) {
    var n = e.pendingLanes;
    if (n === 0)
        return 0;
    var r = 0
      , i = e.suspendedLanes
      , o = e.pingedLanes
      , s = 268435455 & n;
    if (s !== 0) {
        var a = s & ~i;
        a !== 0 ? r = $s(a) : (o &= s,
        o !== 0 && (r = $s(o)))
    } else
        s = n & ~i,
        s !== 0 ? r = $s(s) : o !== 0 && (r = $s(o));
    if (r === 0)
        return 0;
    if (t !== 0 && t !== r && !(t & i) && (i = r & -r,
    o = t & -t,
    i >= o || i === 16 && (4194240 & o) !== 0))
        return t;
    if (4 & r && (r |= 16 & n),
    t = e.entangledLanes,
    t !== 0)
        for (e = e.entanglements,
        t &= r; 0 < t; )
            n = 31 - Dn(t),
            i = 1 << n,
            r |= e[n],
            t &= ~i;
    return r
}
function h2(e, t) {
    switch (e) {
    case 1:
    case 2:
    case 4:
        return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function p2(e, t) {
    for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o; ) {
        var s = 31 - Dn(o)
          , a = 1 << s
          , l = i[s];
        l === -1 ? a & n && !(a & r) || (i[s] = h2(a, t)) : l <= t && (e.expiredLanes |= a),
        o &= ~a
    }
}
function Ih(e) {
    return e = -1073741825 & e.pendingLanes,
    e !== 0 ? e : 1073741824 & e ? 1073741824 : 0
}
function qx() {
    var e = Al;
    return Al <<= 1,
    !(4194240 & Al) && (Al = 64),
    e
}
function Qd(e) {
    for (var t = [], n = 0; 31 > n; n++)
        t.push(e);
    return t
}
function pa(e, t, n) {
    e.pendingLanes |= t,
    t !== 536870912 && (e.suspendedLanes = 0,
    e.pingedLanes = 0),
    e = e.eventTimes,
    t = 31 - Dn(t),
    e[t] = n
}
function m2(e, t) {
    var n = e.pendingLanes & ~t;
    e.pendingLanes = t,
    e.suspendedLanes = 0,
    e.pingedLanes = 0,
    e.expiredLanes &= t,
    e.mutableReadLanes &= t,
    e.entangledLanes &= t,
    t = e.entanglements;
    var r = e.eventTimes;
    for (e = e.expirationTimes; 0 < n; ) {
        var i = 31 - Dn(n)
          , o = 1 << i;
        t[i] = 0,
        r[i] = -1,
        e[i] = -1,
        n &= ~o
    }
}
function pp(e, t) {
    var n = e.entangledLanes |= t;
    for (e = e.entanglements; n; ) {
        var r = 31 - Dn(n)
          , i = 1 << r;
        i & t | e[r] & t && (e[r] |= t),
        n &= ~i
    }
}
var Se = 0;
function Xx(e) {
    return e &= -e,
    1 < e ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1
}
var Yx, mp, Kx, Qx, Zx, Oh = !1, zl = [], Qr = null, Zr = null, Jr = null, ea = new Map, ta = new Map, qr = [], g2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Eb(e, t) {
    switch (e) {
    case "focusin":
    case "focusout":
        Qr = null;
        break;
    case "dragenter":
    case "dragleave":
        Zr = null;
        break;
    case "mouseover":
    case "mouseout":
        Jr = null;
        break;
    case "pointerover":
    case "pointerout":
        ea.delete(t.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        ta.delete(t.pointerId)
    }
}
function Is(e, t, n, r, i, o) {
    return e === null || e.nativeEvent !== o ? (e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i]
    },
    t !== null && (t = ga(t),
    t !== null && mp(t)),
    e) : (e.eventSystemFlags |= r,
    t = e.targetContainers,
    i !== null && t.indexOf(i) === -1 && t.push(i),
    e)
}
function v2(e, t, n, r, i) {
    switch (t) {
    case "focusin":
        return Qr = Is(Qr, e, t, n, r, i),
        !0;
    case "dragenter":
        return Zr = Is(Zr, e, t, n, r, i),
        !0;
    case "mouseover":
        return Jr = Is(Jr, e, t, n, r, i),
        !0;
    case "pointerover":
        var o = i.pointerId;
        return ea.set(o, Is(ea.get(o) || null, e, t, n, r, i)),
        !0;
    case "gotpointercapture":
        return o = i.pointerId,
        ta.set(o, Is(ta.get(o) || null, e, t, n, r, i)),
        !0
    }
    return !1
}
function Jx(e) {
    var t = Ei(e.target);
    if (t !== null) {
        var n = zi(t);
        if (n !== null) {
            if (t = n.tag,
            t === 13) {
                if (t = Nx(n),
                t !== null) {
                    e.blockedOn = t,
                    Zx(e.priority, function() {
                        Kx(n)
                    });
                    return
                }
            } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}
function Zl(e) {
    if (e.blockedOn !== null)
        return !1;
    for (var t = e.targetContainers; 0 < t.length; ) {
        var n = Mh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (n !== null)
            return t = ga(n),
            t !== null && mp(t),
            e.blockedOn = n,
            !1;
        n = e.nativeEvent;
        var r = new n.constructor(n.type,n);
        Eh = r,
        n.target.dispatchEvent(r),
        Eh = null,
        t.shift()
    }
    return !0
}
function Fb(e, t, n) {
    Zl(e) && n.delete(t)
}
function y2() {
    Oh = !1,
    Qr !== null && Zl(Qr) && (Qr = null),
    Zr !== null && Zl(Zr) && (Zr = null),
    Jr !== null && Zl(Jr) && (Jr = null),
    ea.forEach(Fb),
    ta.forEach(Fb)
}
function Os(e, t) {
    e.blockedOn === t && (e.blockedOn = null,
    Oh || (Oh = !0,
    rn.unstable_scheduleCallback(rn.unstable_NormalPriority, y2)))
}
function na(e) {
    function t(i) {
        return Os(i, e)
    }
    if (0 < zl.length) {
        Os(zl[0], e);
        for (var n = 1; n < zl.length; n++) {
            var r = zl[n];
            r.blockedOn === e && (r.blockedOn = null)
        }
    }
    for (Qr !== null && Os(Qr, e),
    Zr !== null && Os(Zr, e),
    Jr !== null && Os(Jr, e),
    ea.forEach(t),
    ta.forEach(t),
    n = 0; n < qr.length; n++)
        r = qr[n],
        r.blockedOn === e && (r.blockedOn = null);
    for (; 0 < qr.length && (n = qr[0],
    n.blockedOn === null); )
        Jx(n),
        n.blockedOn === null && qr.shift()
}
var Oo = _r.ReactCurrentBatchConfig
  , hc = !0;
function b2(e, t, n, r) {
    var i = Se
      , o = Oo.transition;
    Oo.transition = null;
    try {
        Se = 1,
        gp(e, t, n, r)
    } finally {
        Se = i,
        Oo.transition = o
    }
}
function x2(e, t, n, r) {
    var i = Se
      , o = Oo.transition;
    Oo.transition = null;
    try {
        Se = 4,
        gp(e, t, n, r)
    } finally {
        Se = i,
        Oo.transition = o
    }
}
function gp(e, t, n, r) {
    if (hc) {
        var i = Mh(e, t, n, r);
        if (i === null)
            ih(e, t, r, pc, n),
            Eb(e, r);
        else if (v2(i, e, t, n, r))
            r.stopPropagation();
        else if (Eb(e, r),
        4 & t && -1 < g2.indexOf(e)) {
            for (; i !== null; ) {
                var o = ga(i);
                if (o !== null && Yx(o),
                o = Mh(e, t, n, r),
                o === null && ih(e, t, r, pc, n),
                o === i)
                    break;
                i = o
            }
            i !== null && r.stopPropagation()
        } else
            ih(e, t, r, null, n)
    }
}
var pc = null;
function Mh(e, t, n, r) {
    if (pc = null,
    e = dp(r),
    e = Ei(e),
    e !== null)
        if (t = zi(e),
        t === null)
            e = null;
        else if (n = t.tag,
        n === 13) {
            if (e = Nx(t),
            e !== null)
                return e;
            e = null
        } else if (n === 3) {
            if (t.stateNode.current.memoizedState.isDehydrated)
                return t.tag === 3 ? t.stateNode.containerInfo : null;
            e = null
        } else
            t !== e && (e = null);
    return pc = e,
    null
}
function ew(e) {
    switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (a2()) {
        case hp:
            return 1;
        case Ux:
            return 4;
        case fc:
        case l2:
            return 16;
        case Gx:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Yr = null
  , vp = null
  , Jl = null;
function tw() {
    if (Jl)
        return Jl;
    var e, t, n = vp, r = n.length, i = "value"in Yr ? Yr.value : Yr.textContent, o = i.length;
    for (e = 0; e < r && n[e] === i[e]; e++)
        ;
    var s = r - e;
    for (t = 1; t <= s && n[r - t] === i[o - t]; t++)
        ;
    return Jl = i.slice(e, 1 < t ? 1 - t : void 0)
}
function ec(e) {
    var t = e.keyCode;
    return "charCode"in e ? (e = e.charCode,
    e === 0 && t === 13 && (e = 13)) : e = t,
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
}
function Bl() {
    return !0
}
function Pb() {
    return !1
}
function sn(e) {
    function t(n, r, i, o, s) {
        this._reactName = n,
        this._targetInst = i,
        this.type = r,
        this.nativeEvent = o,
        this.target = s,
        this.currentTarget = null;
        for (var a in e)
            e.hasOwnProperty(a) && (n = e[a],
            this[a] = n ? n(o) : o[a]);
        return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Bl : Pb,
        this.isPropagationStopped = Pb,
        this
    }
    return je(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
            this.isDefaultPrevented = Bl)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
            this.isPropagationStopped = Bl)
        },
        persist: function() {},
        isPersistent: Bl
    }),
    t
}
var Zd, Jd, Ms, jo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(e) {
        return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, yp = sn(jo), ma = je({}, jo, {
    view: 0,
    detail: 0
}), w2 = sn(ma), Mc = je({}, ma, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: bp,
    button: 0,
    buttons: 0,
    relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function(e) {
        return "movementX"in e ? e.movementX : (e !== Ms && (Ms && e.type === "mousemove" ? (Zd = e.screenX - Ms.screenX,
        Jd = e.screenY - Ms.screenY) : Jd = Zd = 0,
        Ms = e),
        Zd)
    },
    movementY: function(e) {
        return "movementY"in e ? e.movementY : Jd
    }
}), _b = sn(Mc), S2 = je({}, Mc, {
    dataTransfer: 0
}), k2 = sn(S2), C2 = je({}, ma, {
    relatedTarget: 0
}), eh = sn(C2), T2 = je({}, jo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), R2 = sn(T2), E2 = je({}, jo, {
    clipboardData: function(e) {
        return "clipboardData"in e ? e.clipboardData : P.clipboardData
    }
}), F2 = sn(E2), P2 = je({}, jo, {
    data: 0
}), Ib = sn(P2), _2 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, I2 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, O2 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function M2(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : !!(e = O2[e]) && !!t[e]
}
function bp() {
    return M2
}
var L2 = je({}, ma, {
    key: function(e) {
        if (e.key) {
            var t = _2[e.key] || e.key;
            if (t !== "Unidentified")
                return t
        }
        return e.type === "keypress" ? (e = ec(e),
        e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? I2[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: bp,
    charCode: function(e) {
        return e.type === "keypress" ? ec(e) : 0
    },
    keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function(e) {
        return e.type === "keypress" ? ec(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
})
  , V2 = sn(L2)
  , A2 = je({}, Mc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Ob = sn(A2)
  , D2 = je({}, ma, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: bp
})
  , z2 = sn(D2)
  , B2 = je({}, jo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , $2 = sn(B2)
  , N2 = je({}, Mc, {
    deltaX: function(e) {
        return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
    },
    deltaY: function(e) {
        return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , j2 = sn(N2)
  , H2 = [9, 13, 27, 32]
  , xp = Rr && "CompositionEvent"in P
  , Ws = null;
Rr && "documentMode"in document && (Ws = document.documentMode);
var W2 = Rr && "TextEvent"in P && !Ws
  , nw = Rr && (!xp || Ws && 8 < Ws && 11 >= Ws)
  , Mb = String.fromCharCode(32)
  , Lb = !1;
function rw(e, t) {
    switch (e) {
    case "keyup":
        return H2.indexOf(t.keyCode) !== -1;
    case "keydown":
        return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function iw(e) {
    return e = e.detail,
    typeof e == "object" && "data"in e ? e.data : null
}
var bo = !1;
function U2(e, t) {
    switch (e) {
    case "compositionend":
        return iw(t);
    case "keypress":
        return t.which !== 32 ? null : (Lb = !0,
        Mb);
    case "textInput":
        return e = t.data,
        e === Mb && Lb ? null : e;
    default:
        return null
    }
}
function G2(e, t) {
    if (bo)
        return e === "compositionend" || !xp && rw(e, t) ? (e = tw(),
        Jl = vp = Yr = null,
        bo = !1,
        e) : null;
    switch (e) {
    case "paste":
        return null;
    case "keypress":
        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
            if (t.char && 1 < t.char.length)
                return t.char;
            if (t.which)
                return String.fromCharCode(t.which)
        }
        return null;
    case "compositionend":
        return nw && t.locale !== "ko" ? null : t.data;
    default:
        return null
    }
}
var q2 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Vb(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!q2[e.type] : t === "textarea"
}
function ow(e, t, n, r) {
    Ax(r),
    t = mc(t, "onChange"),
    0 < t.length && (n = new yp("onChange","change",null,n,r),
    e.push({
        event: n,
        listeners: t
    }))
}
var Us = null
  , ra = null;
function X2(e) {
    gw(e, 0)
}
function Lc(e) {
    var t = So(e);
    if (Px(t))
        return e
}
function Y2(e, t) {
    if (e === "change")
        return t
}
var sw = !1;
Rr && (Rr ? (Nl = "oninput"in document,
Nl || (th = document.createElement("div"),
th.setAttribute("oninput", "return;"),
Nl = typeof th.oninput == "function"),
$l = Nl) : $l = !1,
sw = $l && (!document.documentMode || 9 < document.documentMode));
var $l, Nl, th;
function Ab() {
    Us && (Us.detachEvent("onpropertychange", aw),
    ra = Us = null)
}
function aw(e) {
    if (e.propertyName === "value" && Lc(ra)) {
        var t = [];
        ow(t, ra, e, dp(e)),
        $x(X2, t)
    }
}
function K2(e, t, n) {
    e === "focusin" ? (Ab(),
    Us = t,
    ra = n,
    Us.attachEvent("onpropertychange", aw)) : e === "focusout" && Ab()
}
function Q2(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return Lc(ra)
}
function Z2(e, t) {
    if (e === "click")
        return Lc(t)
}
function J2(e, t) {
    if (e === "input" || e === "change")
        return Lc(t)
}
function eO(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var Bn = typeof Object.is == "function" ? Object.is : eO;
function ia(e, t) {
    if (Bn(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    var n = Object.keys(e)
      , r = Object.keys(t);
    if (n.length !== r.length)
        return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!mh.call(t, i) || !Bn(e[i], t[i]))
            return !1
    }
    return !0
}
function Db(e) {
    for (; e && e.firstChild; )
        e = e.firstChild;
    return e
}
function zb(e, t) {
    var n = Db(e);
    e = 0;
    for (var r; n; ) {
        if (n.nodeType === 3) {
            if (r = e + n.textContent.length,
            e <= t && r >= t)
                return {
                    node: n,
                    offset: t - e
                };
            e = r
        }
        e: {
            for (; n; ) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = Db(n)
    }
}
function lw(e, t) {
    return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? lw(e, t.parentNode) : "contains"in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
}
function cw() {
    for (var e = P, t = lc(); t instanceof e.HTMLIFrameElement; ) {
        try {
            var n = typeof t.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (!n)
            break;
        e = t.contentWindow,
        t = lc(e.document)
    }
    return t
}
function wp(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function tO(e) {
    var t = cw()
      , n = e.focusedElem
      , r = e.selectionRange;
    if (t !== n && n && n.ownerDocument && lw(n.ownerDocument.documentElement, n)) {
        if (r !== null && wp(n)) {
            if (t = r.start,
            e = r.end,
            e === void 0 && (e = t),
            "selectionStart"in n)
                n.selectionStart = t,
                n.selectionEnd = Math.min(e, n.value.length);
            else if (e = (t = n.ownerDocument || document) && t.defaultView || P,
            e.getSelection) {
                e = e.getSelection();
                var i = n.textContent.length
                  , o = Math.min(r.start, i);
                r = r.end === void 0 ? o : Math.min(r.end, i),
                !e.extend && o > r && (i = r,
                r = o,
                o = i),
                i = zb(n, o);
                var s = zb(n, r);
                i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(),
                t.setStart(i.node, i.offset),
                e.removeAllRanges(),
                o > r ? (e.addRange(t),
                e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset),
                e.addRange(t)))
            }
        }
        for (t = [],
        e = n; e = e.parentNode; )
            e.nodeType === 1 && t.push({
                element: e,
                left: e.scrollLeft,
                top: e.scrollTop
            });
        for (typeof n.focus == "function" && n.focus(),
        n = 0; n < t.length; n++)
            e = t[n],
            e.element.scrollLeft = e.left,
            e.element.scrollTop = e.top
    }
}
var nO = Rr && "documentMode"in document && 11 >= document.documentMode
  , xo = null
  , Lh = null
  , Gs = null
  , Vh = !1;
function Bb(e, t, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    Vh || xo == null || xo !== lc(r) || (r = xo,
    "selectionStart"in r && wp(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || P).getSelection(),
    r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }),
    Gs && ia(Gs, r) || (Gs = r,
    r = mc(Lh, "onSelect"),
    0 < r.length && (t = new yp("onSelect","select",null,t,n),
    e.push({
        event: t,
        listeners: r
    }),
    t.target = xo)))
}
function jl(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(),
    n["Webkit" + e] = "webkit" + t,
    n["Moz" + e] = "moz" + t,
    n
}
var wo = {
    animationend: jl("Animation", "AnimationEnd"),
    animationiteration: jl("Animation", "AnimationIteration"),
    animationstart: jl("Animation", "AnimationStart"),
    transitionend: jl("Transition", "TransitionEnd")
}
  , nh = {}
  , uw = {};
Rr && (uw = document.createElement("div").style,
"AnimationEvent"in P || (delete wo.animationend.animation,
delete wo.animationiteration.animation,
delete wo.animationstart.animation),
"TransitionEvent"in P || delete wo.transitionend.transition);
function Vc(e) {
    if (nh[e])
        return nh[e];
    if (!wo[e])
        return e;
    var t, n = wo[e];
    for (t in n)
        if (n.hasOwnProperty(t) && t in uw)
            return nh[e] = n[t];
    return e
}
var fw = Vc("animationend")
  , dw = Vc("animationiteration")
  , hw = Vc("animationstart")
  , pw = Vc("transitionend")
  , mw = new Map
  , $b = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ai(e, t) {
    mw.set(e, t),
    Di(t, [e])
}
for (Hl = 0; Hl < $b.length; Hl++)
    Wl = $b[Hl],
    Nb = Wl.toLowerCase(),
    jb = Wl[0].toUpperCase() + Wl.slice(1),
    ai(Nb, "on" + jb);
var Wl, Nb, jb, Hl;
ai(fw, "onAnimationEnd");
ai(dw, "onAnimationIteration");
ai(hw, "onAnimationStart");
ai("dblclick", "onDoubleClick");
ai("focusin", "onFocus");
ai("focusout", "onBlur");
ai(pw, "onTransitionEnd");
Vo("onMouseEnter", ["mouseout", "mouseover"]);
Vo("onMouseLeave", ["mouseout", "mouseover"]);
Vo("onPointerEnter", ["pointerout", "pointerover"]);
Vo("onPointerLeave", ["pointerout", "pointerover"]);
Di("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Di("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Di("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Di("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Di("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Di("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Ns = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , rO = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ns));
function Hb(e, t, n) {
    var r = e.type || "unknown-event";
    e.currentTarget = n,
    r2(r, t, void 0, e),
    e.currentTarget = null
}
function gw(e, t) {
    t = (4 & t) !== 0;
    for (var n = 0; n < e.length; n++) {
        var r = e[n]
          , i = r.event;
        r = r.listeners;
        e: {
            var o = void 0;
            if (t)
                for (var s = r.length - 1; 0 <= s; s--) {
                    var a = r[s]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== o && i.isPropagationStopped())
                        break e;
                    Hb(i, a, c),
                    o = l
                }
            else
                for (s = 0; s < r.length; s++) {
                    if (a = r[s],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== o && i.isPropagationStopped())
                        break e;
                    Hb(i, a, c),
                    o = l
                }
        }
    }
    if (uc)
        throw e = _h,
        uc = !1,
        _h = null,
        e
}
function Le(e, t) {
    var n = t[$h];
    n === void 0 && (n = t[$h] = new Set);
    var r = e + "__bubble";
    n.has(r) || (vw(t, e, 2, !1),
    n.add(r))
}
function rh(e, t, n) {
    var r = 0;
    t && (r |= 4),
    vw(n, e, r, t)
}
var Ul = "_reactListening" + Math.random().toString(36).slice(2);
function oa(e) {
    if (!e[Ul]) {
        e[Ul] = !0,
        Cx.forEach(function(n) {
            n !== "selectionchange" && (rO.has(n) || rh(n, !1, e),
            rh(n, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[Ul] || (t[Ul] = !0,
        rh("selectionchange", !1, t))
    }
}
function vw(e, t, n, r) {
    switch (ew(t)) {
    case 1:
        var i = b2;
        break;
    case 4:
        i = x2;
        break;
    default:
        i = gp
    }
    n = i.bind(null, t, n, e),
    i = void 0,
    !Ph || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0),
    r ? i !== void 0 ? e.addEventListener(t, n, {
        capture: !0,
        passive: i
    }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, {
        passive: i
    }) : e.addEventListener(t, n, !1)
}
function ih(e, t, n, r, i) {
    var o = r;
    if (!(1 & t) && !(2 & t) && r !== null)
        e: for (; ; ) {
            if (r === null)
                return;
            var s = r.tag;
            if (s === 3 || s === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                    break;
                if (s === 4)
                    for (s = r.return; s !== null; ) {
                        var l = s.tag;
                        if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo,
                        l === i || l.nodeType === 8 && l.parentNode === i))
                            return;
                        s = s.return
                    }
                for (; a !== null; ) {
                    if (s = Ei(a),
                    s === null)
                        return;
                    if (l = s.tag,
                    l === 5 || l === 6) {
                        r = o = s;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            r = r.return
        }
    $x(function() {
        var c = o
          , u = dp(n)
          , f = [];
        e: {
            var d = mw.get(e);
            if (d !== void 0) {
                var p = yp
                  , v = e;
                switch (e) {
                case "keypress":
                    if (ec(n) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    p = V2;
                    break;
                case "focusin":
                    v = "focus",
                    p = eh;
                    break;
                case "focusout":
                    v = "blur",
                    p = eh;
                    break;
                case "beforeblur":
                case "afterblur":
                    p = eh;
                    break;
                case "click":
                    if (n.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    p = _b;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    p = k2;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    p = z2;
                    break;
                case fw:
                case dw:
                case hw:
                    p = R2;
                    break;
                case pw:
                    p = $2;
                    break;
                case "scroll":
                    p = w2;
                    break;
                case "wheel":
                    p = j2;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    p = F2;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    p = Ob
                }
                var g = (4 & t) !== 0
                  , b = !g && e === "scroll"
                  , m = g ? d !== null ? d + "Capture" : null : d;
                g = [];
                for (var h, y = c; y !== null; ) {
                    h = y;
                    var w = h.stateNode;
                    if (h.tag === 5 && w !== null && (h = w,
                    m !== null && (w = Js(y, m),
                    w != null && g.push(sa(y, w, h)))),
                    b)
                        break;
                    y = y.return
                }
                0 < g.length && (d = new p(d,v,null,n,u),
                f.push({
                    event: d,
                    listeners: g
                }))
            }
        }
        if (!(7 & t)) {
            if (d = e === "mouseover" || e === "pointerover",
            p = e === "mouseout" || e === "pointerout",
            (!d || n === Eh || !(v = n.relatedTarget || n.fromElement) || !Ei(v) && !v[Er]) && (p || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : P,
            p ? (v = n.relatedTarget || n.toElement,
            p = c,
            v = v ? Ei(v) : null,
            v !== null && (b = zi(v),
            v !== b || v.tag !== 5 && v.tag !== 6) && (v = null)) : (p = null,
            v = c),
            p !== v)) {
                if (g = _b,
                w = "onMouseLeave",
                m = "onMouseEnter",
                y = "mouse",
                e !== "pointerout" && e !== "pointerover" || (g = Ob,
                w = "onPointerLeave",
                m = "onPointerEnter",
                y = "pointer"),
                b = p == null ? d : So(p),
                h = v == null ? d : So(v),
                d = new g(w,y + "leave",p,n,u),
                d.target = b,
                d.relatedTarget = h,
                w = null,
                Ei(u) === c && (g = new g(m,y + "enter",v,n,u),
                g.target = h,
                g.relatedTarget = b,
                w = g),
                b = w,
                p && v)
                    e: {
                        for (g = p,
                        m = v,
                        y = 0,
                        h = g; h; h = go(h))
                            y++;
                        for (h = 0,
                        w = m; w; w = go(w))
                            h++;
                        for (; 0 < y - h; )
                            g = go(g),
                            y--;
                        for (; 0 < h - y; )
                            m = go(m),
                            h--;
                        for (; y--; ) {
                            if (g === m || m !== null && g === m.alternate)
                                break e;
                            g = go(g),
                            m = go(m)
                        }
                        g = null
                    }
                else
                    g = null;
                p !== null && Wb(f, d, p, g, !1),
                v !== null && b !== null && Wb(f, b, v, g, !0)
            }
            if (d = c ? So(c) : P,
            p = d.nodeName && d.nodeName.toLowerCase(),
            p === "select" || p === "input" && d.type === "file")
                var C = Y2;
            else if (Vb(d))
                if (sw)
                    C = J2;
                else {
                    C = Q2;
                    var S = K2
                }
            else
                (p = d.nodeName) && p.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (C = Z2);
            switch (C && (C = C(e, c)) ? ow(f, C, n, u) : (S && S(e, d, c),
            e === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && Sh(d, "number", d.value)),
            S = c ? So(c) : P,
            e) {
            case "focusin":
                (Vb(S) || S.contentEditable === "true") && (xo = S,
                Lh = c,
                Gs = null);
                break;
            case "focusout":
                Gs = Lh = xo = null;
                break;
            case "mousedown":
                Vh = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Vh = !1,
                Bb(f, n, u);
                break;
            case "selectionchange":
                if (nO)
                    break;
            case "keydown":
            case "keyup":
                Bb(f, n, u)
            }
            var T;
            if (xp)
                e: {
                    switch (e) {
                    case "compositionstart":
                        var E = "onCompositionStart";
                        break e;
                    case "compositionend":
                        E = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        E = "onCompositionUpdate";
                        break e
                    }
                    E = void 0
                }
            else
                bo ? rw(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart");
            E && (nw && n.locale !== "ko" && (bo || E !== "onCompositionStart" ? E === "onCompositionEnd" && bo && (T = tw()) : (Yr = u,
            vp = "value"in Yr ? Yr.value : Yr.textContent,
            bo = !0)),
            S = mc(c, E),
            0 < S.length && (E = new Ib(E,e,null,n,u),
            f.push({
                event: E,
                listeners: S
            }),
            T ? E.data = T : (T = iw(n),
            T !== null && (E.data = T)))),
            (T = W2 ? U2(e, n) : G2(e, n)) && (c = mc(c, "onBeforeInput"),
            0 < c.length && (u = new Ib("onBeforeInput","beforeinput",null,n,u),
            f.push({
                event: u,
                listeners: c
            }),
            u.data = T))
        }
        gw(f, t)
    })
}
function sa(e, t, n) {
    return {
        instance: e,
        listener: t,
        currentTarget: n
    }
}
function mc(e, t) {
    for (var n = t + "Capture", r = []; e !== null; ) {
        var i = e
          , o = i.stateNode;
        i.tag === 5 && o !== null && (i = o,
        o = Js(e, n),
        o != null && r.unshift(sa(e, o, i)),
        o = Js(e, t),
        o != null && r.push(sa(e, o, i))),
        e = e.return
    }
    return r
}
function go(e) {
    if (e === null)
        return null;
    do
        e = e.return;
    while (e && e.tag !== 5);
    return e || null
}
function Wb(e, t, n, r, i) {
    for (var o = t._reactName, s = []; n !== null && n !== r; ) {
        var a = n
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === r)
            break;
        a.tag === 5 && c !== null && (a = c,
        i ? (l = Js(n, o),
        l != null && s.unshift(sa(n, l, a))) : i || (l = Js(n, o),
        l != null && s.push(sa(n, l, a)))),
        n = n.return
    }
    s.length !== 0 && e.push({
        event: t,
        listeners: s
    })
}
var iO = /\r\n?/g
  , oO = /\u0000|\uFFFD/g;
function Ub(e) {
    return (typeof e == "string" ? e : "" + e).replace(iO, `
`).replace(oO, "")
}
function Gl(e, t, n) {
    if (t = Ub(t),
    Ub(e) !== t && n)
        throw Error(M(425))
}
function gc() {}
var Ah = null
  , Dh = null;
function zh(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var Bh = typeof setTimeout == "function" ? setTimeout : void 0
  , sO = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Gb = typeof Promise == "function" ? Promise : void 0
  , aO = typeof queueMicrotask == "function" ? queueMicrotask : typeof Gb < "u" ? function(e) {
    return Gb.resolve(null).then(e).catch(lO)
}
: Bh;
function lO(e) {
    setTimeout(function() {
        throw e
    })
}
function oh(e, t) {
    var n = t
      , r = 0;
    do {
        var i = n.nextSibling;
        if (e.removeChild(n),
        i && i.nodeType === 8)
            if (n = i.data,
            n === "/$") {
                if (r === 0) {
                    e.removeChild(i),
                    na(t);
                    return
                }
                r--
            } else
                n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    na(t)
}
function ei(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3)
            break;
        if (t === 8) {
            if (t = e.data,
            t === "$" || t === "$!" || t === "$?")
                break;
            if (t === "/$")
                return null
        }
    }
    return e
}
function qb(e) {
    e = e.previousSibling;
    for (var t = 0; e; ) {
        if (e.nodeType === 8) {
            var n = e.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (t === 0)
                    return e;
                t--
            } else
                n === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var Ho = Math.random().toString(36).slice(2)
  , nr = "__reactFiber$" + Ho
  , aa = "__reactProps$" + Ho
  , Er = "__reactContainer$" + Ho
  , $h = "__reactEvents$" + Ho
  , cO = "__reactListeners$" + Ho
  , uO = "__reactHandles$" + Ho;
function Ei(e) {
    var t = e[nr];
    if (t)
        return t;
    for (var n = e.parentNode; n; ) {
        if (t = n[Er] || n[nr]) {
            if (n = t.alternate,
            t.child !== null || n !== null && n.child !== null)
                for (e = qb(e); e !== null; ) {
                    if (n = e[nr])
                        return n;
                    e = qb(e)
                }
            return t
        }
        e = n,
        n = e.parentNode
    }
    return null
}
function ga(e) {
    return e = e[nr] || e[Er],
    !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function So(e) {
    if (e.tag === 5 || e.tag === 6)
        return e.stateNode;
    throw Error(M(33))
}
function Ac(e) {
    return e[aa] || null
}
var Nh = []
  , ko = -1;
function li(e) {
    return {
        current: e
    }
}
function Ve(e) {
    0 > ko || (e.current = Nh[ko],
    Nh[ko] = null,
    ko--)
}
function Pe(e, t) {
    ko++,
    Nh[ko] = e.current,
    e.current = t
}
var si = {}
  , Pt = li(si)
  , Ut = li(!1)
  , Oi = si;
function Ao(e, t) {
    var n = e.type.contextTypes;
    if (!n)
        return si;
    var r = e.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
        return r.__reactInternalMemoizedMaskedChildContext;
    var i, o = {};
    for (i in n)
        o[i] = t[i];
    return r && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = t,
    e.__reactInternalMemoizedMaskedChildContext = o),
    o
}
function Gt(e) {
    return e = e.childContextTypes,
    e != null
}
function vc() {
    Ve(Ut),
    Ve(Pt)
}
function Xb(e, t, n) {
    if (Pt.current !== si)
        throw Error(M(168));
    Pe(Pt, t),
    Pe(Ut, n)
}
function yw(e, t, n) {
    var r = e.stateNode;
    if (t = t.childContextTypes,
    typeof r.getChildContext != "function")
        return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in t))
            throw Error(M(108, KI(e) || "Unknown", i));
    return je({}, n, r)
}
function yc(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || si,
    Oi = Pt.current,
    Pe(Pt, e),
    Pe(Ut, Ut.current),
    !0
}
function Yb(e, t, n) {
    var r = e.stateNode;
    if (!r)
        throw Error(M(169));
    n ? (e = yw(e, t, Oi),
    r.__reactInternalMemoizedMergedChildContext = e,
    Ve(Ut),
    Ve(Pt),
    Pe(Pt, e)) : Ve(Ut),
    Pe(Ut, n)
}
var Sr = null
  , Dc = !1
  , sh = !1;
function bw(e) {
    Sr === null ? Sr = [e] : Sr.push(e)
}
function fO(e) {
    Dc = !0,
    bw(e)
}
function ci() {
    if (!sh && Sr !== null) {
        sh = !0;
        var e = 0
          , t = Se;
        try {
            var n = Sr;
            for (Se = 1; e < n.length; e++) {
                var r = n[e];
                do
                    r = r(!0);
                while (r !== null)
            }
            Sr = null,
            Dc = !1
        } catch (i) {
            throw Sr !== null && (Sr = Sr.slice(e + 1)),
            Wx(hp, ci),
            i
        } finally {
            Se = t,
            sh = !1
        }
    }
    return null
}
var Co = []
  , To = 0
  , bc = null
  , xc = 0
  , xn = []
  , wn = 0
  , Mi = null
  , kr = 1
  , Cr = "";
function Ti(e, t) {
    Co[To++] = xc,
    Co[To++] = bc,
    bc = e,
    xc = t
}
function xw(e, t, n) {
    xn[wn++] = kr,
    xn[wn++] = Cr,
    xn[wn++] = Mi,
    Mi = e;
    var r = kr;
    e = Cr;
    var i = 32 - Dn(r) - 1;
    r &= ~(1 << i),
    n += 1;
    var o = 32 - Dn(t) + i;
    if (30 < o) {
        var s = i - i % 5;
        o = (r & (1 << s) - 1).toString(32),
        r >>= s,
        i -= s,
        kr = 1 << 32 - Dn(t) + i | n << i | r,
        Cr = o + e
    } else
        kr = 1 << o | n << i | r,
        Cr = e
}
function Sp(e) {
    e.return !== null && (Ti(e, 1),
    xw(e, 1, 0))
}
function kp(e) {
    for (; e === bc; )
        bc = Co[--To],
        Co[To] = null,
        xc = Co[--To],
        Co[To] = null;
    for (; e === Mi; )
        Mi = xn[--wn],
        xn[wn] = null,
        Cr = xn[--wn],
        xn[wn] = null,
        kr = xn[--wn],
        xn[wn] = null
}
var nn = null
  , tn = null
  , ze = !1
  , An = null;
function ww(e, t) {
    var n = Sn(5, null, null, 0);
    n.elementType = "DELETED",
    n.stateNode = t,
    n.return = e,
    t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)
}
function Kb(e, t) {
    switch (e.tag) {
    case 5:
        var n = e.type;
        return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
        t !== null && (e.stateNode = t,
        nn = e,
        tn = ei(t.firstChild),
        !0);
    case 6:
        return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
        t !== null && (e.stateNode = t,
        nn = e,
        tn = null,
        !0);
    case 13:
        return t = t.nodeType !== 8 ? null : t,
        t !== null && (n = Mi !== null ? {
            id: kr,
            overflow: Cr
        } : null,
        e.memoizedState = {
            dehydrated: t,
            treeContext: n,
            retryLane: 1073741824
        },
        n = Sn(18, null, null, 0),
        n.stateNode = t,
        n.return = e,
        e.child = n,
        nn = e,
        tn = null,
        !0);
    default:
        return !1
    }
}
function jh(e) {
    return (1 & e.mode) !== 0 && (128 & e.flags) === 0
}
function Hh(e) {
    if (ze) {
        var t = tn;
        if (t) {
            var n = t;
            if (!Kb(e, t)) {
                if (jh(e))
                    throw Error(M(418));
                t = ei(n.nextSibling);
                var r = nn;
                t && Kb(e, t) ? ww(r, n) : (e.flags = -4097 & e.flags | 2,
                ze = !1,
                nn = e)
            }
        } else {
            if (jh(e))
                throw Error(M(418));
            e.flags = -4097 & e.flags | 2,
            ze = !1,
            nn = e
        }
    }
}
function Qb(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
        e = e.return;
    nn = e
}
function ql(e) {
    if (e !== nn)
        return !1;
    if (!ze)
        return Qb(e),
        ze = !0,
        !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
    t = t !== "head" && t !== "body" && !zh(e.type, e.memoizedProps)),
    t && (t = tn)) {
        if (jh(e))
            throw Sw(),
            Error(M(418));
        for (; t; )
            ww(e, t),
            t = ei(t.nextSibling)
    }
    if (Qb(e),
    e.tag === 13) {
        if (e = e.memoizedState,
        e = e !== null ? e.dehydrated : null,
        !e)
            throw Error(M(317));
        e: {
            for (e = e.nextSibling,
            t = 0; e; ) {
                if (e.nodeType === 8) {
                    var n = e.data;
                    if (n === "/$") {
                        if (t === 0) {
                            tn = ei(e.nextSibling);
                            break e
                        }
                        t--
                    } else
                        n !== "$" && n !== "$!" && n !== "$?" || t++
                }
                e = e.nextSibling
            }
            tn = null
        }
    } else
        tn = nn ? ei(e.stateNode.nextSibling) : null;
    return !0
}
function Sw() {
    for (var e = tn; e; )
        e = ei(e.nextSibling)
}
function Do() {
    tn = nn = null,
    ze = !1
}
function Cp(e) {
    An === null ? An = [e] : An.push(e)
}
var dO = _r.ReactCurrentBatchConfig;
function Ln(e, t) {
    if (e && e.defaultProps) {
        t = je({}, t),
        e = e.defaultProps;
        for (var n in e)
            t[n] === void 0 && (t[n] = e[n]);
        return t
    }
    return t
}
var wc = li(null)
  , Sc = null
  , Ro = null
  , Tp = null;
function Rp() {
    Tp = Ro = Sc = null
}
function Ep(e) {
    var t = wc.current;
    Ve(wc),
    e._currentValue = t
}
function Wh(e, t, n) {
    for (; e !== null; ) {
        var r = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
        r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
        e === n)
            break;
        e = e.return
    }
}
function Mo(e, t) {
    Sc = e,
    Tp = Ro = null,
    e = e.dependencies,
    e !== null && e.firstContext !== null && (e.lanes & t && (Wt = !0),
    e.firstContext = null)
}
function Cn(e) {
    var t = e._currentValue;
    if (Tp !== e)
        if (e = {
            context: e,
            memoizedValue: t,
            next: null
        },
        Ro === null) {
            if (Sc === null)
                throw Error(M(308));
            Ro = e,
            Sc.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else
            Ro = Ro.next = e;
    return t
}
var Fi = null;
function Fp(e) {
    Fi === null ? Fi = [e] : Fi.push(e)
}
function kw(e, t, n, r) {
    var i = t.interleaved;
    return i === null ? (n.next = n,
    Fp(t)) : (n.next = i.next,
    i.next = n),
    t.interleaved = n,
    Fr(e, r)
}
function Fr(e, t) {
    e.lanes |= t;
    var n = e.alternate;
    for (n !== null && (n.lanes |= t),
    n = e,
    e = e.return; e !== null; )
        e.childLanes |= t,
        n = e.alternate,
        n !== null && (n.childLanes |= t),
        n = e,
        e = e.return;
    return n.tag === 3 ? n.stateNode : null
}
var Gr = !1;
function Pp(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function Cw(e, t) {
    e = e.updateQueue,
    t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}
function Tr(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function ti(e, t, n) {
    var r = e.updateQueue;
    if (r === null)
        return null;
    if (r = r.shared,
    2 & ye) {
        var i = r.pending;
        return i === null ? t.next = t : (t.next = i.next,
        i.next = t),
        r.pending = t,
        Fr(e, n)
    }
    return i = r.interleaved,
    i === null ? (t.next = t,
    Fp(r)) : (t.next = i.next,
    i.next = t),
    r.interleaved = t,
    Fr(e, n)
}
function tc(e, t, n) {
    if (t = t.updateQueue,
    t !== null && (t = t.shared,
    (4194240 & n) !== 0)) {
        var r = t.lanes;
        r &= e.pendingLanes,
        n |= r,
        t.lanes = n,
        pp(e, n)
    }
}
function Zb(e, t) {
    var n = e.updateQueue
      , r = e.alternate;
    if (r === null || (r = r.updateQueue,
    n !== r))
        e = n.lastBaseUpdate,
        e === null ? n.firstBaseUpdate = t : e.next = t,
        n.lastBaseUpdate = t;
    else {
        var i = null
          , o = null;
        if (n = n.firstBaseUpdate,
        n !== null) {
            do {
                var s = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                o === null ? i = o = s : o = o.next = s,
                n = n.next
            } while (n !== null);
            o === null ? i = o = t : o = o.next = t
        } else
            i = o = t;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: o,
            shared: r.shared,
            effects: r.effects
        },
        e.updateQueue = n
    }
}
function kc(e, t, n, r) {
    var i = e.updateQueue;
    Gr = !1;
    var o = i.firstBaseUpdate
      , s = i.lastBaseUpdate
      , a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        s === null ? o = c : s.next = c,
        s = l;
        var u = e.alternate;
        u !== null && (u = u.updateQueue,
        a = u.lastBaseUpdate,
        a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c,
        u.lastBaseUpdate = l))
    }
    if (o !== null) {
        var f = i.baseState;
        s = 0,
        u = c = l = null,
        a = o;
        do {
            var d = a.lane
              , p = a.eventTime;
            if ((r & d) === d) {
                u !== null && (u = u.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = e
                      , g = a;
                    switch (d = t,
                    p = n,
                    g.tag) {
                    case 1:
                        if (v = g.payload,
                        typeof v == "function") {
                            f = v.call(p, f, d);
                            break e
                        }
                        f = v;
                        break e;
                    case 3:
                        v.flags = -65537 & v.flags | 128;
                    case 0:
                        if (v = g.payload,
                        d = typeof v == "function" ? v.call(p, f, d) : v,
                        d == null)
                            break e;
                        f = je({}, f, d);
                        break e;
                    case 2:
                        Gr = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (e.flags |= 64,
                d = i.effects,
                d === null ? i.effects = [a] : d.push(a))
            } else
                p = {
                    eventTime: p,
                    lane: d,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                u === null ? (c = u = p,
                l = f) : u = u.next = p,
                s |= d;
            if (a = a.next,
            a === null) {
                if (a = i.shared.pending,
                a === null)
                    break;
                d = a,
                a = d.next,
                d.next = null,
                i.lastBaseUpdate = d,
                i.shared.pending = null
            }
        } while (1);
        if (u === null && (l = f),
        i.baseState = l,
        i.firstBaseUpdate = c,
        i.lastBaseUpdate = u,
        t = i.shared.interleaved,
        t !== null) {
            i = t;
            do
                s |= i.lane,
                i = i.next;
            while (i !== t)
        } else
            o === null && (i.shared.lanes = 0);
        Vi |= s,
        e.lanes = s,
        e.memoizedState = f
    }
}
function Jb(e, t, n) {
    if (e = t.effects,
    t.effects = null,
    e !== null)
        for (t = 0; t < e.length; t++) {
            var r = e[t]
              , i = r.callback;
            if (i !== null) {
                if (r.callback = null,
                r = n,
                typeof i != "function")
                    throw Error(M(191, i));
                i.call(r)
            }
        }
}
var Tw = new kx.Component().refs;
function Uh(e, t, n, r) {
    t = e.memoizedState,
    n = n(r, t),
    n = n == null ? t : je({}, t, n),
    e.memoizedState = n,
    e.lanes === 0 && (e.updateQueue.baseState = n)
}
var zc = {
    isMounted: function(e) {
        return !!(e = e._reactInternals) && zi(e) === e
    },
    enqueueSetState: function(e, t, n) {
        e = e._reactInternals;
        var r = Dt()
          , i = ri(e)
          , o = Tr(r, i);
        o.payload = t,
        n != null && (o.callback = n),
        t = ti(e, o, i),
        t !== null && (zn(t, e, i, r),
        tc(t, e, i))
    },
    enqueueReplaceState: function(e, t, n) {
        e = e._reactInternals;
        var r = Dt()
          , i = ri(e)
          , o = Tr(r, i);
        o.tag = 1,
        o.payload = t,
        n != null && (o.callback = n),
        t = ti(e, o, i),
        t !== null && (zn(t, e, i, r),
        tc(t, e, i))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var n = Dt()
          , r = ri(e)
          , i = Tr(n, r);
        i.tag = 2,
        t != null && (i.callback = t),
        t = ti(e, i, r),
        t !== null && (zn(t, e, r, n),
        tc(t, e, r))
    }
};
function ex(e, t, n, r, i, o, s) {
    return e = e.stateNode,
    typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || !ia(n, r) || !ia(i, o)
}
function Rw(e, t, n) {
    var r = !1
      , i = si
      , o = t.contextType;
    return typeof o == "object" && o !== null ? o = Cn(o) : (i = Gt(t) ? Oi : Pt.current,
    r = t.contextTypes,
    o = (r = r != null) ? Ao(e, i) : si),
    t = new t(n,o),
    e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
    t.updater = zc,
    e.stateNode = t,
    t._reactInternals = e,
    r && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = i,
    e.__reactInternalMemoizedMaskedChildContext = o),
    t
}
function tx(e, t, n, r) {
    e = t.state,
    typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && zc.enqueueReplaceState(t, t.state, null)
}
function Gh(e, t, n, r) {
    var i = e.stateNode;
    i.props = n,
    i.state = e.memoizedState,
    i.refs = Tw,
    Pp(e);
    var o = t.contextType;
    typeof o == "object" && o !== null ? i.context = Cn(o) : (o = Gt(t) ? Oi : Pt.current,
    i.context = Ao(e, o)),
    i.state = e.memoizedState,
    o = t.getDerivedStateFromProps,
    typeof o == "function" && (Uh(e, t, o, n),
    i.state = e.memoizedState),
    typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state,
    typeof i.componentWillMount == "function" && i.componentWillMount(),
    typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
    t !== i.state && zc.enqueueReplaceState(i, i.state, null),
    kc(e, n, i, r),
    i.state = e.memoizedState),
    typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}
function Ls(e, t, n) {
    if (e = n.ref,
    e !== null && typeof e != "function" && typeof e != "object") {
        if (n._owner) {
            if (n = n._owner,
            n) {
                if (n.tag !== 1)
                    throw Error(M(309));
                var r = n.stateNode
            }
            if (!r)
                throw Error(M(147, e));
            var i = r
              , o = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function(s) {
                var a = i.refs;
                a === Tw && (a = i.refs = {}),
                s === null ? delete a[o] : a[o] = s
            }
            ,
            t._stringRef = o,
            t)
        }
        if (typeof e != "string")
            throw Error(M(284));
        if (!n._owner)
            throw Error(M(290, e))
    }
    return e
}
function Xl(e, t) {
    throw e = Object.prototype.toString.call(t),
    Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function nx(e) {
    var t = e._init;
    return t(e._payload)
}
function Ew(e) {
    function t(m, h) {
        if (e) {
            var y = m.deletions;
            y === null ? (m.deletions = [h],
            m.flags |= 16) : y.push(h)
        }
    }
    function n(m, h) {
        if (!e)
            return null;
        for (; h !== null; )
            t(m, h),
            h = h.sibling;
        return null
    }
    function r(m, h) {
        for (m = new Map; h !== null; )
            h.key !== null ? m.set(h.key, h) : m.set(h.index, h),
            h = h.sibling;
        return m
    }
    function i(m, h) {
        return m = ii(m, h),
        m.index = 0,
        m.sibling = null,
        m
    }
    function o(m, h, y) {
        return m.index = y,
        e ? (y = m.alternate,
        y !== null ? (y = y.index,
        y < h ? (m.flags |= 2,
        h) : y) : (m.flags |= 2,
        h)) : (m.flags |= 1048576,
        h)
    }
    function s(m) {
        return e && m.alternate === null && (m.flags |= 2),
        m
    }
    function a(m, h, y, w) {
        return h === null || h.tag !== 6 ? (h = hh(y, m.mode, w),
        h.return = m,
        h) : (h = i(h, y),
        h.return = m,
        h)
    }
    function l(m, h, y, w) {
        var C = y.type;
        return C === yo ? u(m, h, y.props.children, w, y.key) : h !== null && (h.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Ur && nx(C) === h.type) ? (w = i(h, y.props),
        w.ref = Ls(m, h, y),
        w.return = m,
        w) : (w = ac(y.type, y.key, y.props, null, m.mode, w),
        w.ref = Ls(m, h, y),
        w.return = m,
        w)
    }
    function c(m, h, y, w) {
        return h === null || h.tag !== 4 || h.stateNode.containerInfo !== y.containerInfo || h.stateNode.implementation !== y.implementation ? (h = ph(y, m.mode, w),
        h.return = m,
        h) : (h = i(h, y.children || []),
        h.return = m,
        h)
    }
    function u(m, h, y, w, C) {
        return h === null || h.tag !== 7 ? (h = Ii(y, m.mode, w, C),
        h.return = m,
        h) : (h = i(h, y),
        h.return = m,
        h)
    }
    function f(m, h, y) {
        if (typeof h == "string" && h !== "" || typeof h == "number")
            return h = hh("" + h, m.mode, y),
            h.return = m,
            h;
        if (typeof h == "object" && h !== null) {
            switch (h.$$typeof) {
            case Ml:
                return y = ac(h.type, h.key, h.props, null, m.mode, y),
                y.ref = Ls(m, null, h),
                y.return = m,
                y;
            case vo:
                return h = ph(h, m.mode, y),
                h.return = m,
                h;
            case Ur:
                var w = h._init;
                return f(m, w(h._payload), y)
            }
            if (Bs(h) || _s(h))
                return h = Ii(h, m.mode, y, null),
                h.return = m,
                h;
            Xl(m, h)
        }
        return null
    }
    function d(m, h, y, w) {
        var C = h !== null ? h.key : null;
        if (typeof y == "string" && y !== "" || typeof y == "number")
            return C !== null ? null : a(m, h, "" + y, w);
        if (typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
            case Ml:
                return y.key === C ? l(m, h, y, w) : null;
            case vo:
                return y.key === C ? c(m, h, y, w) : null;
            case Ur:
                return C = y._init,
                d(m, h, C(y._payload), w)
            }
            if (Bs(y) || _s(y))
                return C !== null ? null : u(m, h, y, w, null);
            Xl(m, y)
        }
        return null
    }
    function p(m, h, y, w, C) {
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return m = m.get(y) || null,
            a(h, m, "" + w, C);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Ml:
                return m = m.get(w.key === null ? y : w.key) || null,
                l(h, m, w, C);
            case vo:
                return m = m.get(w.key === null ? y : w.key) || null,
                c(h, m, w, C);
            case Ur:
                var S = w._init;
                return p(m, h, y, S(w._payload), C)
            }
            if (Bs(w) || _s(w))
                return m = m.get(y) || null,
                u(h, m, w, C, null);
            Xl(h, w)
        }
        return null
    }
    function v(m, h, y, w) {
        for (var C = null, S = null, T = h, E = h = 0, I = null; T !== null && E < y.length; E++) {
            T.index > E ? (I = T,
            T = null) : I = T.sibling;
            var O = d(m, T, y[E], w);
            if (O === null) {
                T === null && (T = I);
                break
            }
            e && T && O.alternate === null && t(m, T),
            h = o(O, h, E),
            S === null ? C = O : S.sibling = O,
            S = O,
            T = I
        }
        if (E === y.length)
            return n(m, T),
            ze && Ti(m, E),
            C;
        if (T === null) {
            for (; E < y.length; E++)
                T = f(m, y[E], w),
                T !== null && (h = o(T, h, E),
                S === null ? C = T : S.sibling = T,
                S = T);
            return ze && Ti(m, E),
            C
        }
        for (T = r(m, T); E < y.length; E++)
            I = p(T, m, E, y[E], w),
            I !== null && (e && I.alternate !== null && T.delete(I.key === null ? E : I.key),
            h = o(I, h, E),
            S === null ? C = I : S.sibling = I,
            S = I);
        return e && T.forEach(function(B) {
            return t(m, B)
        }),
        ze && Ti(m, E),
        C
    }
    function g(m, h, y, w) {
        var C = _s(y);
        if (typeof C != "function")
            throw Error(M(150));
        if (y = C.call(y),
        y == null)
            throw Error(M(151));
        for (var S = C = null, T = h, E = h = 0, I = null, O = y.next(); T !== null && !O.done; E++,
        O = y.next()) {
            T.index > E ? (I = T,
            T = null) : I = T.sibling;
            var B = d(m, T, O.value, w);
            if (B === null) {
                T === null && (T = I);
                break
            }
            e && T && B.alternate === null && t(m, T),
            h = o(B, h, E),
            S === null ? C = B : S.sibling = B,
            S = B,
            T = I
        }
        if (O.done)
            return n(m, T),
            ze && Ti(m, E),
            C;
        if (T === null) {
            for (; !O.done; E++,
            O = y.next())
                O = f(m, O.value, w),
                O !== null && (h = o(O, h, E),
                S === null ? C = O : S.sibling = O,
                S = O);
            return ze && Ti(m, E),
            C
        }
        for (T = r(m, T); !O.done; E++,
        O = y.next())
            O = p(T, m, E, O.value, w),
            O !== null && (e && O.alternate !== null && T.delete(O.key === null ? E : O.key),
            h = o(O, h, E),
            S === null ? C = O : S.sibling = O,
            S = O);
        return e && T.forEach(function(z) {
            return t(m, z)
        }),
        ze && Ti(m, E),
        C
    }
    function b(m, h, y, w) {
        if (typeof y == "object" && y !== null && y.type === yo && y.key === null && (y = y.props.children),
        typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
            case Ml:
                e: {
                    for (var C = y.key, S = h; S !== null; ) {
                        if (S.key === C) {
                            if (C = y.type,
                            C === yo) {
                                if (S.tag === 7) {
                                    n(m, S.sibling),
                                    h = i(S, y.props.children),
                                    h.return = m,
                                    m = h;
                                    break e
                                }
                            } else if (S.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Ur && nx(C) === S.type) {
                                n(m, S.sibling),
                                h = i(S, y.props),
                                h.ref = Ls(m, S, y),
                                h.return = m,
                                m = h;
                                break e
                            }
                            n(m, S);
                            break
                        }
                        t(m, S),
                        S = S.sibling
                    }
                    y.type === yo ? (h = Ii(y.props.children, m.mode, w, y.key),
                    h.return = m,
                    m = h) : (w = ac(y.type, y.key, y.props, null, m.mode, w),
                    w.ref = Ls(m, h, y),
                    w.return = m,
                    m = w)
                }
                return s(m);
            case vo:
                e: {
                    for (S = y.key; h !== null; ) {
                        if (h.key === S) {
                            if (h.tag === 4 && h.stateNode.containerInfo === y.containerInfo && h.stateNode.implementation === y.implementation) {
                                n(m, h.sibling),
                                h = i(h, y.children || []),
                                h.return = m,
                                m = h;
                                break e
                            }
                            n(m, h);
                            break
                        }
                        t(m, h),
                        h = h.sibling
                    }
                    h = ph(y, m.mode, w),
                    h.return = m,
                    m = h
                }
                return s(m);
            case Ur:
                return S = y._init,
                b(m, h, S(y._payload), w)
            }
            if (Bs(y))
                return v(m, h, y, w);
            if (_s(y))
                return g(m, h, y, w);
            Xl(m, y)
        }
        return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y,
        h !== null && h.tag === 6 ? (n(m, h.sibling),
        h = i(h, y),
        h.return = m,
        m = h) : (n(m, h),
        h = hh(y, m.mode, w),
        h.return = m,
        m = h),
        s(m)) : n(m, h)
    }
    return b
}
var zo = Ew(!0)
  , Fw = Ew(!1)
  , va = {}
  , ir = li(va)
  , la = li(va)
  , ca = li(va);
function Pi(e) {
    if (e === va)
        throw Error(M(174));
    return e
}
function _p(e, t) {
    switch (Pe(ca, t),
    Pe(la, e),
    Pe(ir, va),
    e = t.nodeType,
    e) {
    case 9:
    case 11:
        t = (t = t.documentElement) ? t.namespaceURI : Ch(null, "");
        break;
    default:
        e = e === 8 ? t.parentNode : t,
        t = e.namespaceURI || null,
        e = e.tagName,
        t = Ch(t, e)
    }
    Ve(ir),
    Pe(ir, t)
}
function Bo() {
    Ve(ir),
    Ve(la),
    Ve(ca)
}
function Pw(e) {
    Pi(ca.current);
    var t = Pi(ir.current)
      , n = Ch(t, e.type);
    t !== n && (Pe(la, e),
    Pe(ir, n))
}
function Ip(e) {
    la.current === e && (Ve(ir),
    Ve(la))
}
var $e = li(0);
function Cc(e) {
    for (var t = e; t !== null; ) {
        if (t.tag === 13) {
            var n = t.memoizedState;
            if (n !== null && (n = n.dehydrated,
            n === null || n.data === "$?" || n.data === "$!"))
                return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (128 & t.flags)
                return t
        } else if (t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return null;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
    return null
}
var ah = [];
function Op() {
    for (var e = 0; e < ah.length; e++)
        ah[e]._workInProgressVersionPrimary = null;
    ah.length = 0
}
var nc = _r.ReactCurrentDispatcher
  , lh = _r.ReactCurrentBatchConfig
  , Li = 0
  , Ne = null
  , ot = null
  , ut = null
  , Tc = !1
  , qs = !1
  , ua = 0
  , hO = 0;
function Rt() {
    throw Error(M(321))
}
function Mp(e, t) {
    if (t === null)
        return !1;
    for (var n = 0; n < t.length && n < e.length; n++)
        if (!Bn(e[n], t[n]))
            return !1;
    return !0
}
function Lp(e, t, n, r, i, o) {
    if (Li = o,
    Ne = t,
    t.memoizedState = null,
    t.updateQueue = null,
    t.lanes = 0,
    nc.current = e === null || e.memoizedState === null ? vO : yO,
    e = n(r, i),
    qs) {
        o = 0;
        do {
            if (qs = !1,
            ua = 0,
            25 <= o)
                throw Error(M(301));
            o += 1,
            ut = ot = null,
            t.updateQueue = null,
            nc.current = bO,
            e = n(r, i)
        } while (qs)
    }
    if (nc.current = Rc,
    t = ot !== null && ot.next !== null,
    Li = 0,
    ut = ot = Ne = null,
    Tc = !1,
    t)
        throw Error(M(300));
    return e
}
function Vp() {
    var e = ua !== 0;
    return ua = 0,
    e
}
function tr() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return ut === null ? Ne.memoizedState = ut = e : ut = ut.next = e,
    ut
}
function Tn() {
    if (ot === null) {
        var e = Ne.alternate;
        e = e !== null ? e.memoizedState : null
    } else
        e = ot.next;
    var t = ut === null ? Ne.memoizedState : ut.next;
    if (t !== null)
        ut = t,
        ot = e;
    else {
        if (e === null)
            throw Error(M(310));
        ot = e,
        e = {
            memoizedState: ot.memoizedState,
            baseState: ot.baseState,
            baseQueue: ot.baseQueue,
            queue: ot.queue,
            next: null
        },
        ut === null ? Ne.memoizedState = ut = e : ut = ut.next = e
    }
    return ut
}
function fa(e, t) {
    return typeof t == "function" ? t(e) : t
}
function ch(e) {
    var t = Tn()
      , n = t.queue;
    if (n === null)
        throw Error(M(311));
    n.lastRenderedReducer = e;
    var r = ot
      , i = r.baseQueue
      , o = n.pending;
    if (o !== null) {
        if (i !== null) {
            var s = i.next;
            i.next = o.next,
            o.next = s
        }
        r.baseQueue = i = o,
        n.pending = null
    }
    if (i !== null) {
        o = i.next,
        r = r.baseState;
        var a = s = null
          , l = null
          , c = o;
        do {
            var u = c.lane;
            if ((Li & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                r = c.hasEagerState ? c.eagerState : e(r, c.action);
            else {
                var f = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = f,
                s = r) : l = l.next = f,
                Ne.lanes |= u,
                Vi |= u
            }
            c = c.next
        } while (c !== null && c !== o);
        l === null ? s = r : l.next = a,
        Bn(r, t.memoizedState) || (Wt = !0),
        t.memoizedState = r,
        t.baseState = s,
        t.baseQueue = l,
        n.lastRenderedState = r
    }
    if (e = n.interleaved,
    e !== null) {
        i = e;
        do
            o = i.lane,
            Ne.lanes |= o,
            Vi |= o,
            i = i.next;
        while (i !== e)
    } else
        i === null && (n.lanes = 0);
    return [t.memoizedState, n.dispatch]
}
function uh(e) {
    var t = Tn()
      , n = t.queue;
    if (n === null)
        throw Error(M(311));
    n.lastRenderedReducer = e;
    var r = n.dispatch
      , i = n.pending
      , o = t.memoizedState;
    if (i !== null) {
        n.pending = null;
        var s = i = i.next;
        do
            o = e(o, s.action),
            s = s.next;
        while (s !== i);
        Bn(o, t.memoizedState) || (Wt = !0),
        t.memoizedState = o,
        t.baseQueue === null && (t.baseState = o),
        n.lastRenderedState = o
    }
    return [o, r]
}
function _w() {}
function Iw(e, t) {
    var n = Ne
      , r = Tn()
      , i = t()
      , o = !Bn(r.memoizedState, i);
    if (o && (r.memoizedState = i,
    Wt = !0),
    r = r.queue,
    Ap(Lw.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || o || ut !== null && 1 & ut.memoizedState.tag) {
        if (n.flags |= 2048,
        da(9, Mw.bind(null, n, r, i, t), void 0, null),
        ft === null)
            throw Error(M(349));
        30 & Li || Ow(n, t, i)
    }
    return i
}
function Ow(e, t, n) {
    e.flags |= 16384,
    e = {
        getSnapshot: t,
        value: n
    },
    t = Ne.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    Ne.updateQueue = t,
    t.stores = [e]) : (n = t.stores,
    n === null ? t.stores = [e] : n.push(e))
}
function Mw(e, t, n, r) {
    t.value = n,
    t.getSnapshot = r,
    Vw(t) && Aw(e)
}
function Lw(e, t, n) {
    return n(function() {
        Vw(t) && Aw(e)
    })
}
function Vw(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var n = t();
        return !Bn(e, n)
    } catch {
        return !0
    }
}
function Aw(e) {
    var t = Fr(e, 1);
    t !== null && zn(t, e, 1, -1)
}
function rx(e) {
    var t = tr();
    return typeof e == "function" && (e = e()),
    t.memoizedState = t.baseState = e,
    e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: fa,
        lastRenderedState: e
    },
    t.queue = e,
    e = e.dispatch = gO.bind(null, Ne, e),
    [t.memoizedState, e]
}
function da(e, t, n, r) {
    return e = {
        tag: e,
        create: t,
        destroy: n,
        deps: r,
        next: null
    },
    t = Ne.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    Ne.updateQueue = t,
    t.lastEffect = e.next = e) : (n = t.lastEffect,
    n === null ? t.lastEffect = e.next = e : (r = n.next,
    n.next = e,
    e.next = r,
    t.lastEffect = e)),
    e
}
function Dw() {
    return Tn().memoizedState
}
function rc(e, t, n, r) {
    var i = tr();
    Ne.flags |= e,
    i.memoizedState = da(1 | t, n, void 0, r === void 0 ? null : r)
}
function Bc(e, t, n, r) {
    var i = Tn();
    r = r === void 0 ? null : r;
    var o = void 0;
    if (ot !== null) {
        var s = ot.memoizedState;
        if (o = s.destroy,
        r !== null && Mp(r, s.deps)) {
            i.memoizedState = da(t, n, o, r);
            return
        }
    }
    Ne.flags |= e,
    i.memoizedState = da(1 | t, n, o, r)
}
function ix(e, t) {
    return rc(8390656, 8, e, t)
}
function Ap(e, t) {
    return Bc(2048, 8, e, t)
}
function zw(e, t) {
    return Bc(4, 2, e, t)
}
function Bw(e, t) {
    return Bc(4, 4, e, t)
}
function $w(e, t) {
    return typeof t == "function" ? (e = e(),
    t(e),
    function() {
        t(null)
    }
    ) : t != null ? (e = e(),
    t.current = e,
    function() {
        t.current = null
    }
    ) : void 0
}
function Nw(e, t, n) {
    return n = n != null ? n.concat([e]) : null,
    Bc(4, 4, $w.bind(null, t, e), n)
}
function Dp() {}
function jw(e, t) {
    var n = Tn();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && Mp(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
    e)
}
function Hw(e, t) {
    var n = Tn();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && Mp(t, r[1]) ? r[0] : (e = e(),
    n.memoizedState = [e, t],
    e)
}
function Ww(e, t, n) {
    return 21 & Li ? (Bn(n, t) || (n = qx(),
    Ne.lanes |= n,
    Vi |= n,
    e.baseState = !0),
    t) : (e.baseState && (e.baseState = !1,
    Wt = !0),
    e.memoizedState = n)
}
function pO(e, t) {
    var n = Se;
    Se = n !== 0 && 4 > n ? n : 4,
    e(!0);
    var r = lh.transition;
    lh.transition = {};
    try {
        e(!1),
        t()
    } finally {
        Se = n,
        lh.transition = r
    }
}
function Uw() {
    return Tn().memoizedState
}
function mO(e, t, n) {
    var r = ri(e);
    if (n = {
        lane: r,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Gw(e))
        qw(t, n);
    else if (n = kw(e, t, n, r),
    n !== null) {
        var i = Dt();
        zn(n, e, r, i),
        Xw(n, t, r)
    }
}
function gO(e, t, n) {
    var r = ri(e)
      , i = {
        lane: r,
        action: n,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Gw(e))
        qw(t, i);
    else {
        var o = e.alternate;
        if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer,
        o !== null))
            try {
                var s = t.lastRenderedState
                  , a = o(s, n);
                if (i.hasEagerState = !0,
                i.eagerState = a,
                Bn(a, s)) {
                    var l = t.interleaved;
                    l === null ? (i.next = i,
                    Fp(t)) : (i.next = l.next,
                    l.next = i),
                    t.interleaved = i;
                    return
                }
            } catch {}
        n = kw(e, t, i, r),
        n !== null && (i = Dt(),
        zn(n, e, r, i),
        Xw(n, t, r))
    }
}
function Gw(e) {
    var t = e.alternate;
    return e === Ne || t !== null && t === Ne
}
function qw(e, t) {
    qs = Tc = !0;
    var n = e.pending;
    n === null ? t.next = t : (t.next = n.next,
    n.next = t),
    e.pending = t
}
function Xw(e, t, n) {
    if (4194240 & n) {
        var r = t.lanes;
        r &= e.pendingLanes,
        n |= r,
        t.lanes = n,
        pp(e, n)
    }
}
var Rc = {
    readContext: Cn,
    useCallback: Rt,
    useContext: Rt,
    useEffect: Rt,
    useImperativeHandle: Rt,
    useInsertionEffect: Rt,
    useLayoutEffect: Rt,
    useMemo: Rt,
    useReducer: Rt,
    useRef: Rt,
    useState: Rt,
    useDebugValue: Rt,
    useDeferredValue: Rt,
    useTransition: Rt,
    useMutableSource: Rt,
    useSyncExternalStore: Rt,
    useId: Rt,
    unstable_isNewReconciler: !1
}
  , vO = {
    readContext: Cn,
    useCallback: function(e, t) {
        return tr().memoizedState = [e, t === void 0 ? null : t],
        e
    },
    useContext: Cn,
    useEffect: ix,
    useImperativeHandle: function(e, t, n) {
        return n = n != null ? n.concat([e]) : null,
        rc(4194308, 4, $w.bind(null, t, e), n)
    },
    useLayoutEffect: function(e, t) {
        return rc(4194308, 4, e, t)
    },
    useInsertionEffect: function(e, t) {
        return rc(4, 2, e, t)
    },
    useMemo: function(e, t) {
        var n = tr();
        return t = t === void 0 ? null : t,
        e = e(),
        n.memoizedState = [e, t],
        e
    },
    useReducer: function(e, t, n) {
        var r = tr();
        return t = n !== void 0 ? n(t) : t,
        r.memoizedState = r.baseState = t,
        e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: e,
            lastRenderedState: t
        },
        r.queue = e,
        e = e.dispatch = mO.bind(null, Ne, e),
        [r.memoizedState, e]
    },
    useRef: function(e) {
        var t = tr();
        return e = {
            current: e
        },
        t.memoizedState = e
    },
    useState: rx,
    useDebugValue: Dp,
    useDeferredValue: function(e) {
        return tr().memoizedState = e
    },
    useTransition: function() {
        var e = rx(!1)
          , t = e[0];
        return e = pO.bind(null, e[1]),
        tr().memoizedState = e,
        [t, e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(e, t, n) {
        var r = Ne
          , i = tr();
        if (ze) {
            if (n === void 0)
                throw Error(M(407));
            n = n()
        } else {
            if (n = t(),
            ft === null)
                throw Error(M(349));
            30 & Li || Ow(r, t, n)
        }
        i.memoizedState = n;
        var o = {
            value: n,
            getSnapshot: t
        };
        return i.queue = o,
        ix(Lw.bind(null, r, o, e), [e]),
        r.flags |= 2048,
        da(9, Mw.bind(null, r, o, n, t), void 0, null),
        n
    },
    useId: function() {
        var e = tr()
          , t = ft.identifierPrefix;
        if (ze) {
            var n = Cr
              , r = kr;
            n = (r & ~(1 << 32 - Dn(r) - 1)).toString(32) + n,
            t = ":" + t + "R" + n,
            n = ua++,
            0 < n && (t += "H" + n.toString(32)),
            t += ":"
        } else
            n = hO++,
            t = ":" + t + "r" + n.toString(32) + ":";
        return e.memoizedState = t
    },
    unstable_isNewReconciler: !1
}
  , yO = {
    readContext: Cn,
    useCallback: jw,
    useContext: Cn,
    useEffect: Ap,
    useImperativeHandle: Nw,
    useInsertionEffect: zw,
    useLayoutEffect: Bw,
    useMemo: Hw,
    useReducer: ch,
    useRef: Dw,
    useState: function() {
        return ch(fa)
    },
    useDebugValue: Dp,
    useDeferredValue: function(e) {
        var t = Tn();
        return Ww(t, ot.memoizedState, e)
    },
    useTransition: function() {
        var e = ch(fa)[0]
          , t = Tn().memoizedState;
        return [e, t]
    },
    useMutableSource: _w,
    useSyncExternalStore: Iw,
    useId: Uw,
    unstable_isNewReconciler: !1
}
  , bO = {
    readContext: Cn,
    useCallback: jw,
    useContext: Cn,
    useEffect: Ap,
    useImperativeHandle: Nw,
    useInsertionEffect: zw,
    useLayoutEffect: Bw,
    useMemo: Hw,
    useReducer: uh,
    useRef: Dw,
    useState: function() {
        return uh(fa)
    },
    useDebugValue: Dp,
    useDeferredValue: function(e) {
        var t = Tn();
        return ot === null ? t.memoizedState = e : Ww(t, ot.memoizedState, e)
    },
    useTransition: function() {
        var e = uh(fa)[0]
          , t = Tn().memoizedState;
        return [e, t]
    },
    useMutableSource: _w,
    useSyncExternalStore: Iw,
    useId: Uw,
    unstable_isNewReconciler: !1
};
function $o(e, t) {
    try {
        var n = ""
          , r = t;
        do
            n += YI(r),
            r = r.return;
        while (r);
        var i = n
    } catch (o) {
        i = `
Error generating stack: ` + o.message + `
` + o.stack
    }
    return {
        value: e,
        source: t,
        stack: i,
        digest: null
    }
}
function fh(e, t, n) {
    return {
        value: e,
        source: null,
        stack: n ?? null,
        digest: t ?? null
    }
}
function qh(e, t) {
    try {
        console.error(t.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var xO = typeof WeakMap == "function" ? WeakMap : Map;
function Yw(e, t, n) {
    n = Tr(-1, n),
    n.tag = 3,
    n.payload = {
        element: null
    };
    var r = t.value;
    return n.callback = function() {
        Fc || (Fc = !0,
        np = r),
        qh(e, t)
    }
    ,
    n
}
function Kw(e, t, n) {
    n = Tr(-1, n),
    n.tag = 3;
    var r = e.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = t.value;
        n.payload = function() {
            return r(i)
        }
        ,
        n.callback = function() {
            qh(e, t)
        }
    }
    var o = e.stateNode;
    return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function() {
        qh(e, t),
        typeof r != "function" && (ni === null ? ni = new Set([this]) : ni.add(this));
        var s = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: s !== null ? s : ""
        })
    }
    ),
    n
}
function ox(e, t, n) {
    var r = e.pingCache;
    if (r === null) {
        r = e.pingCache = new xO;
        var i = new Set;
        r.set(t, i)
    } else
        i = r.get(t),
        i === void 0 && (i = new Set,
        r.set(t, i));
    i.has(n) || (i.add(n),
    e = LO.bind(null, e, t, n),
    t.then(e, e))
}
function sx(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState,
        t = t === null || t.dehydrated !== null),
        t)
            return e;
        e = e.return
    } while (e !== null);
    return null
}
function ax(e, t, n, r, i) {
    return 1 & e.mode ? (e.flags |= 65536,
    e.lanes = i,
    e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
    n.flags |= 131072,
    n.flags &= -52805,
    n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Tr(-1, 1),
    t.tag = 2,
    ti(n, t, 1))),
    n.lanes |= 1),
    e)
}
var wO = _r.ReactCurrentOwner
  , Wt = !1;
function At(e, t, n, r) {
    t.child = e === null ? Fw(t, null, n, r) : zo(t, e.child, n, r)
}
function lx(e, t, n, r, i) {
    n = n.render;
    var o = t.ref;
    return Mo(t, i),
    r = Lp(e, t, n, r, o, i),
    n = Vp(),
    e !== null && !Wt ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~i,
    Pr(e, t, i)) : (ze && n && Sp(t),
    t.flags |= 1,
    At(e, t, r, i),
    t.child)
}
function cx(e, t, n, r, i) {
    if (e === null) {
        var o = n.type;
        return typeof o == "function" && !Up(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15,
        t.type = o,
        Qw(e, t, o, r, i)) : (e = ac(n.type, null, r, t, t.mode, i),
        e.ref = t.ref,
        e.return = t,
        t.child = e)
    }
    if (o = e.child,
    !(e.lanes & i)) {
        var s = o.memoizedProps;
        if (n = n.compare,
        n = n !== null ? n : ia,
        n(s, r) && e.ref === t.ref)
            return Pr(e, t, i)
    }
    return t.flags |= 1,
    e = ii(o, r),
    e.ref = t.ref,
    e.return = t,
    t.child = e
}
function Qw(e, t, n, r, i) {
    if (e !== null) {
        var o = e.memoizedProps;
        if (ia(o, r) && e.ref === t.ref) {
            if (Wt = !1,
            t.pendingProps = r = o,
            (e.lanes & i) === 0)
                return t.lanes = e.lanes,
                Pr(e, t, i);
            131072 & e.flags && (Wt = !0)
        }
    }
    return Xh(e, t, n, r, i)
}
function Zw(e, t, n) {
    var r = t.pendingProps
      , i = r.children
      , o = e !== null ? e.memoizedState : null;
    if (r.mode === "hidden")
        if (!(1 & t.mode))
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Pe(Fo, en),
            en |= n;
        else {
            if (!(1073741824 & n))
                return e = o !== null ? o.baseLanes | n : n,
                t.lanes = t.childLanes = 1073741824,
                t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                },
                t.updateQueue = null,
                Pe(Fo, en),
                en |= e,
                null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            r = o !== null ? o.baseLanes : n,
            Pe(Fo, en),
            en |= r
        }
    else
        o !== null ? (r = o.baseLanes | n,
        t.memoizedState = null) : r = n,
        Pe(Fo, en),
        en |= r;
    return At(e, t, i, n),
    t.child
}
function Jw(e, t) {
    var n = t.ref;
    (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512,
    t.flags |= 2097152)
}
function Xh(e, t, n, r, i) {
    var o = Gt(n) ? Oi : Pt.current;
    return o = Ao(t, o),
    Mo(t, i),
    n = Lp(e, t, n, r, o, i),
    r = Vp(),
    e !== null && !Wt ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~i,
    Pr(e, t, i)) : (ze && r && Sp(t),
    t.flags |= 1,
    At(e, t, n, i),
    t.child)
}
function ux(e, t, n, r, i) {
    if (Gt(n)) {
        var o = !0;
        yc(t)
    } else
        o = !1;
    if (Mo(t, i),
    t.stateNode === null)
        ic(e, t),
        Rw(t, n, r),
        Gh(t, n, r, i),
        r = !0;
    else if (e === null) {
        var s = t.stateNode
          , a = t.memoizedProps;
        s.props = a;
        var l = s.context
          , c = n.contextType;
        typeof c == "object" && c !== null ? c = Cn(c) : (c = Gt(n) ? Oi : Pt.current,
        c = Ao(t, c));
        var u = n.getDerivedStateFromProps
          , f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function";
        f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && tx(t, s, r, c),
        Gr = !1;
        var d = t.memoizedState;
        s.state = d,
        kc(t, r, s, i),
        l = t.memoizedState,
        a !== r || d !== l || Ut.current || Gr ? (typeof u == "function" && (Uh(t, n, u, r),
        l = t.memoizedState),
        (a = Gr || ex(t, n, a, r, d, l, c)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(),
        typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()),
        typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
        t.memoizedProps = r,
        t.memoizedState = l),
        s.props = r,
        s.state = l,
        s.context = c,
        r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308),
        r = !1)
    } else {
        s = t.stateNode,
        Cw(e, t),
        a = t.memoizedProps,
        c = t.type === t.elementType ? a : Ln(t.type, a),
        s.props = c,
        f = t.pendingProps,
        d = s.context,
        l = n.contextType,
        typeof l == "object" && l !== null ? l = Cn(l) : (l = Gt(n) ? Oi : Pt.current,
        l = Ao(t, l));
        var p = n.getDerivedStateFromProps;
        (u = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && tx(t, s, r, l),
        Gr = !1,
        d = t.memoizedState,
        s.state = d,
        kc(t, r, s, i);
        var v = t.memoizedState;
        a !== f || d !== v || Ut.current || Gr ? (typeof p == "function" && (Uh(t, n, p, r),
        v = t.memoizedState),
        (c = Gr || ex(t, n, c, r, d, v, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, v, l),
        typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, v, l)),
        typeof s.componentDidUpdate == "function" && (t.flags |= 4),
        typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        t.memoizedProps = r,
        t.memoizedState = v),
        s.props = r,
        s.state = v,
        s.context = l,
        r = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
        r = !1)
    }
    return Yh(e, t, n, r, o, i)
}
function Yh(e, t, n, r, i, o) {
    Jw(e, t);
    var s = (128 & t.flags) !== 0;
    if (!r && !s)
        return i && Yb(t, n, !1),
        Pr(e, t, o);
    r = t.stateNode,
    wO.current = t;
    var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return t.flags |= 1,
    e !== null && s ? (t.child = zo(t, e.child, null, o),
    t.child = zo(t, null, a, o)) : At(e, t, a, o),
    t.memoizedState = r.state,
    i && Yb(t, n, !0),
    t.child
}
function eS(e) {
    var t = e.stateNode;
    t.pendingContext ? Xb(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Xb(e, t.context, !1),
    _p(e, t.containerInfo)
}
function fx(e, t, n, r, i) {
    return Do(),
    Cp(i),
    t.flags |= 256,
    At(e, t, n, r),
    t.child
}
var Kh = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Qh(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}
function tS(e, t, n) {
    var r, i = t.pendingProps, o = $e.current, s = !1, a = (128 & t.flags) !== 0;
    if ((r = a) || (r = (e === null || e.memoizedState !== null) && (2 & o) !== 0),
    r ? (s = !0,
    t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1),
    Pe($e, 1 & o),
    e === null)
        return Hh(t),
        e = t.memoizedState,
        e !== null && (e = e.dehydrated,
        e !== null) ? (1 & t.mode ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
        null) : (a = i.children,
        e = i.fallback,
        s ? (i = t.mode,
        s = t.child,
        a = {
            mode: "hidden",
            children: a
        },
        !(1 & i) && s !== null ? (s.childLanes = 0,
        s.pendingProps = a) : s = jc(a, i, 0, null),
        e = Ii(e, i, n, null),
        s.return = t,
        e.return = t,
        s.sibling = e,
        t.child = s,
        t.child.memoizedState = Qh(n),
        t.memoizedState = Kh,
        e) : zp(t, a));
    if (o = e.memoizedState,
    o !== null && (r = o.dehydrated,
    r !== null))
        return SO(e, t, a, i, r, o, n);
    if (s) {
        s = i.fallback,
        a = t.mode,
        o = e.child,
        r = o.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(1 & a) && t.child !== o ? (i = t.child,
        i.childLanes = 0,
        i.pendingProps = l,
        t.deletions = null) : (i = ii(o, l),
        i.subtreeFlags = 14680064 & o.subtreeFlags),
        r !== null ? s = ii(r, s) : (s = Ii(s, a, n, null),
        s.flags |= 2),
        s.return = t,
        i.return = t,
        i.sibling = s,
        t.child = i,
        i = s,
        s = t.child,
        a = e.child.memoizedState,
        a = a === null ? Qh(n) : {
            baseLanes: a.baseLanes | n,
            cachePool: null,
            transitions: a.transitions
        },
        s.memoizedState = a,
        s.childLanes = e.childLanes & ~n,
        t.memoizedState = Kh,
        i
    }
    return s = e.child,
    e = s.sibling,
    i = ii(s, {
        mode: "visible",
        children: i.children
    }),
    !(1 & t.mode) && (i.lanes = n),
    i.return = t,
    i.sibling = null,
    e !== null && (n = t.deletions,
    n === null ? (t.deletions = [e],
    t.flags |= 16) : n.push(e)),
    t.child = i,
    t.memoizedState = null,
    i
}
function zp(e, t) {
    return t = jc({
        mode: "visible",
        children: t
    }, e.mode, 0, null),
    t.return = e,
    e.child = t
}
function Yl(e, t, n, r) {
    return r !== null && Cp(r),
    zo(t, e.child, null, n),
    e = zp(t, t.pendingProps.children),
    e.flags |= 2,
    t.memoizedState = null,
    e
}
function SO(e, t, n, r, i, o, s) {
    if (n)
        return 256 & t.flags ? (t.flags &= -257,
        r = fh(Error(M(422))),
        Yl(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child,
        t.flags |= 128,
        null) : (o = r.fallback,
        i = t.mode,
        r = jc({
            mode: "visible",
            children: r.children
        }, i, 0, null),
        o = Ii(o, i, s, null),
        o.flags |= 2,
        r.return = t,
        o.return = t,
        r.sibling = o,
        t.child = r,
        1 & t.mode && zo(t, e.child, null, s),
        t.child.memoizedState = Qh(s),
        t.memoizedState = Kh,
        o);
    if (!(1 & t.mode))
        return Yl(e, t, s, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset,
        r)
            var a = r.dgst;
        return r = a,
        o = Error(M(419)),
        r = fh(o, r, void 0),
        Yl(e, t, s, r)
    }
    if (a = (s & e.childLanes) !== 0,
    Wt || a) {
        if (r = ft,
        r !== null) {
            switch (s & -s) {
            case 4:
                i = 2;
                break;
            case 16:
                i = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                i = 32;
                break;
            case 536870912:
                i = 268435456;
                break;
            default:
                i = 0
            }
            i = i & (r.suspendedLanes | s) ? 0 : i,
            i !== 0 && i !== o.retryLane && (o.retryLane = i,
            Fr(e, i),
            zn(r, e, i, -1))
        }
        return Wp(),
        r = fh(Error(M(421))),
        Yl(e, t, s, r)
    }
    return i.data === "$?" ? (t.flags |= 128,
    t.child = e.child,
    t = VO.bind(null, e),
    i._reactRetry = t,
    null) : (e = o.treeContext,
    tn = ei(i.nextSibling),
    nn = t,
    ze = !0,
    An = null,
    e !== null && (xn[wn++] = kr,
    xn[wn++] = Cr,
    xn[wn++] = Mi,
    kr = e.id,
    Cr = e.overflow,
    Mi = t),
    t = zp(t, r.children),
    t.flags |= 4096,
    t)
}
function dx(e, t, n) {
    e.lanes |= t;
    var r = e.alternate;
    r !== null && (r.lanes |= t),
    Wh(e.return, t, n)
}
function dh(e, t, n, r, i) {
    var o = e.memoizedState;
    o === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (o.isBackwards = t,
    o.rendering = null,
    o.renderingStartTime = 0,
    o.last = r,
    o.tail = n,
    o.tailMode = i)
}
function nS(e, t, n) {
    var r = t.pendingProps
      , i = r.revealOrder
      , o = r.tail;
    if (At(e, t, r.children, n),
    r = $e.current,
    2 & r)
        r = 1 & r | 2,
        t.flags |= 128;
    else {
        if (e !== null && 128 & e.flags)
            e: for (e = t.child; e !== null; ) {
                if (e.tag === 13)
                    e.memoizedState !== null && dx(e, n, t);
                else if (e.tag === 19)
                    dx(e, n, t);
                else if (e.child !== null) {
                    e.child.return = e,
                    e = e.child;
                    continue
                }
                if (e === t)
                    break e;
                for (; e.sibling === null; ) {
                    if (e.return === null || e.return === t)
                        break e;
                    e = e.return
                }
                e.sibling.return = e.return,
                e = e.sibling
            }
        r &= 1
    }
    if (Pe($e, r),
    !(1 & t.mode))
        t.memoizedState = null;
    else
        switch (i) {
        case "forwards":
            for (n = t.child,
            i = null; n !== null; )
                e = n.alternate,
                e !== null && Cc(e) === null && (i = n),
                n = n.sibling;
            n = i,
            n === null ? (i = t.child,
            t.child = null) : (i = n.sibling,
            n.sibling = null),
            dh(t, !1, i, n, o);
            break;
        case "backwards":
            for (n = null,
            i = t.child,
            t.child = null; i !== null; ) {
                if (e = i.alternate,
                e !== null && Cc(e) === null) {
                    t.child = i;
                    break
                }
                e = i.sibling,
                i.sibling = n,
                n = i,
                i = e
            }
            dh(t, !0, n, null, o);
            break;
        case "together":
            dh(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
        }
    return t.child
}
function ic(e, t) {
    !(1 & t.mode) && e !== null && (e.alternate = null,
    t.alternate = null,
    t.flags |= 2)
}
function Pr(e, t, n) {
    if (e !== null && (t.dependencies = e.dependencies),
    Vi |= t.lanes,
    !(n & t.childLanes))
        return null;
    if (e !== null && t.child !== e.child)
        throw Error(M(153));
    if (t.child !== null) {
        for (e = t.child,
        n = ii(e, e.pendingProps),
        t.child = n,
        n.return = t; e.sibling !== null; )
            e = e.sibling,
            n = n.sibling = ii(e, e.pendingProps),
            n.return = t;
        n.sibling = null
    }
    return t.child
}
function kO(e, t, n) {
    switch (t.tag) {
    case 3:
        eS(t),
        Do();
        break;
    case 5:
        Pw(t);
        break;
    case 1:
        Gt(t.type) && yc(t);
        break;
    case 4:
        _p(t, t.stateNode.containerInfo);
        break;
    case 10:
        var r = t.type._context
          , i = t.memoizedProps.value;
        Pe(wc, r._currentValue),
        r._currentValue = i;
        break;
    case 13:
        if (r = t.memoizedState,
        r !== null)
            return r.dehydrated !== null ? (Pe($e, 1 & $e.current),
            t.flags |= 128,
            null) : n & t.child.childLanes ? tS(e, t, n) : (Pe($e, 1 & $e.current),
            e = Pr(e, t, n),
            e !== null ? e.sibling : null);
        Pe($e, 1 & $e.current);
        break;
    case 19:
        if (r = (n & t.childLanes) !== 0,
        128 & e.flags) {
            if (r)
                return nS(e, t, n);
            t.flags |= 128
        }
        if (i = t.memoizedState,
        i !== null && (i.rendering = null,
        i.tail = null,
        i.lastEffect = null),
        Pe($e, $e.current),
        r)
            break;
        return null;
    case 22:
    case 23:
        return t.lanes = 0,
        Zw(e, t, n)
    }
    return Pr(e, t, n)
}
var rS, Zh, iS, oS;
rS = function(e, t) {
    for (var n = t.child; n !== null; ) {
        if (n.tag === 5 || n.tag === 6)
            e.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === t)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === t)
                return;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
}
;
Zh = function() {}
;
iS = function(e, t, n, r) {
    var i = e.memoizedProps;
    if (i !== r) {
        e = t.stateNode,
        Pi(ir.current);
        var o = null;
        switch (n) {
        case "input":
            i = xh(e, i),
            r = xh(e, r),
            o = [];
            break;
        case "select":
            i = je({}, i, {
                value: void 0
            }),
            r = je({}, r, {
                value: void 0
            }),
            o = [];
            break;
        case "textarea":
            i = kh(e, i),
            r = kh(e, r),
            o = [];
            break;
        default:
            typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = gc)
        }
        Th(n, r);
        var s;
        n = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (s in a)
                        a.hasOwnProperty(s) && (n || (n = {}),
                        n[s] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Qs.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
        for (c in r) {
            var l = r[c];
            if (a = i?.[c],
            r.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (s in a)
                            !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}),
                            n[s] = "");
                        for (s in l)
                            l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}),
                            n[s] = l[s])
                    } else
                        n || (o || (o = []),
                        o.push(c, n)),
                        n = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Qs.hasOwnProperty(c) ? (l != null && c === "onScroll" && Le("scroll", e),
                    o || a === l || (o = [])) : (o = o || []).push(c, l))
        }
        n && (o = o || []).push("style", n);
        var c = o;
        (t.updateQueue = c) && (t.flags |= 4)
    }
}
;
oS = function(e, t, n, r) {
    n !== r && (t.flags |= 4)
}
;
function Vs(e, t) {
    if (!ze)
        switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var n = null; t !== null; )
                t.alternate !== null && (n = t),
                t = t.sibling;
            n === null ? e.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = e.tail;
            for (var r = null; n !== null; )
                n.alternate !== null && (r = n),
                n = n.sibling;
            r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
        }
}
function Et(e) {
    var t = e.alternate !== null && e.alternate.child === e.child
      , n = 0
      , r = 0;
    if (t)
        for (var i = e.child; i !== null; )
            n |= i.lanes | i.childLanes,
            r |= 14680064 & i.subtreeFlags,
            r |= 14680064 & i.flags,
            i.return = e,
            i = i.sibling;
    else
        for (i = e.child; i !== null; )
            n |= i.lanes | i.childLanes,
            r |= i.subtreeFlags,
            r |= i.flags,
            i.return = e,
            i = i.sibling;
    return e.subtreeFlags |= r,
    e.childLanes = n,
    t
}
function CO(e, t, n) {
    var r = t.pendingProps;
    switch (kp(t),
    t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Et(t),
        null;
    case 1:
        return Gt(t.type) && vc(),
        Et(t),
        null;
    case 3:
        return r = t.stateNode,
        Bo(),
        Ve(Ut),
        Ve(Pt),
        Op(),
        r.pendingContext && (r.context = r.pendingContext,
        r.pendingContext = null),
        e !== null && e.child !== null || (ql(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024,
        An !== null && (op(An),
        An = null))),
        Zh(e, t),
        Et(t),
        null;
    case 5:
        Ip(t);
        var i = Pi(ca.current);
        if (n = t.type,
        e !== null && t.stateNode != null)
            iS(e, t, n, r, i),
            e.ref !== t.ref && (t.flags |= 512,
            t.flags |= 2097152);
        else {
            if (!r) {
                if (t.stateNode === null)
                    throw Error(M(166));
                return Et(t),
                null
            }
            if (e = Pi(ir.current),
            ql(t)) {
                r = t.stateNode,
                n = t.type;
                var o = t.memoizedProps;
                switch (r[nr] = t,
                r[aa] = o,
                e = (1 & t.mode) !== 0,
                n) {
                case "dialog":
                    Le("cancel", r),
                    Le("close", r);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Le("load", r);
                    break;
                case "video":
                case "audio":
                    for (i = 0; i < Ns.length; i++)
                        Le(Ns[i], r);
                    break;
                case "source":
                    Le("error", r);
                    break;
                case "img":
                case "image":
                case "link":
                    Le("error", r),
                    Le("load", r);
                    break;
                case "details":
                    Le("toggle", r);
                    break;
                case "input":
                    xb(r, o),
                    Le("invalid", r);
                    break;
                case "select":
                    r._wrapperState = {
                        wasMultiple: !!o.multiple
                    },
                    Le("invalid", r);
                    break;
                case "textarea":
                    Sb(r, o),
                    Le("invalid", r)
                }
                Th(n, o),
                i = null;
                for (var s in o)
                    if (o.hasOwnProperty(s)) {
                        var a = o[s];
                        s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && Gl(r.textContent, a, e),
                        i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && Gl(r.textContent, a, e),
                        i = ["children", "" + a]) : Qs.hasOwnProperty(s) && a != null && s === "onScroll" && Le("scroll", r)
                    }
                switch (n) {
                case "input":
                    Ll(r),
                    wb(r, o, !0);
                    break;
                case "textarea":
                    Ll(r),
                    kb(r);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof o.onClick == "function" && (r.onclick = gc)
                }
                r = i,
                t.updateQueue = r,
                r !== null && (t.flags |= 4)
            } else {
                s = i.nodeType === 9 ? i : i.ownerDocument,
                e === "http://www.w3.org/1999/xhtml" && (e = Ox(n)),
                e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"),
                e.innerHTML = "<script><\/script>",
                e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, {
                    is: r.is
                }) : (e = s.createElement(n),
                n === "select" && (s = e,
                r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n),
                e[nr] = t,
                e[aa] = r,
                rS(e, t, !1, !1),
                t.stateNode = e;
                e: {
                    switch (s = Rh(n, r),
                    n) {
                    case "dialog":
                        Le("cancel", e),
                        Le("close", e),
                        i = r;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Le("load", e),
                        i = r;
                        break;
                    case "video":
                    case "audio":
                        for (i = 0; i < Ns.length; i++)
                            Le(Ns[i], e);
                        i = r;
                        break;
                    case "source":
                        Le("error", e),
                        i = r;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Le("error", e),
                        Le("load", e),
                        i = r;
                        break;
                    case "details":
                        Le("toggle", e),
                        i = r;
                        break;
                    case "input":
                        xb(e, r),
                        i = xh(e, r),
                        Le("invalid", e);
                        break;
                    case "option":
                        i = r;
                        break;
                    case "select":
                        e._wrapperState = {
                            wasMultiple: !!r.multiple
                        },
                        i = je({}, r, {
                            value: void 0
                        }),
                        Le("invalid", e);
                        break;
                    case "textarea":
                        Sb(e, r),
                        i = kh(e, r),
                        Le("invalid", e);
                        break;
                    default:
                        i = r
                    }
                    Th(n, i),
                    a = i;
                    for (o in a)
                        if (a.hasOwnProperty(o)) {
                            var l = a[o];
                            o === "style" ? Vx(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && Mx(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Zs(e, l) : typeof l == "number" && Zs(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (Qs.hasOwnProperty(o) ? l != null && o === "onScroll" && Le("scroll", e) : l != null && lp(e, o, l, s))
                        }
                    switch (n) {
                    case "input":
                        Ll(e),
                        wb(e, r, !1);
                        break;
                    case "textarea":
                        Ll(e),
                        kb(e);
                        break;
                    case "option":
                        r.value != null && e.setAttribute("value", "" + oi(r.value));
                        break;
                    case "select":
                        e.multiple = !!r.multiple,
                        o = r.value,
                        o != null ? Po(e, !!r.multiple, o, !1) : r.defaultValue != null && Po(e, !!r.multiple, r.defaultValue, !0);
                        break;
                    default:
                        typeof i.onClick == "function" && (e.onclick = gc)
                    }
                    switch (n) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        r = !!r.autoFocus;
                        break e;
                    case "img":
                        r = !0;
                        break e;
                    default:
                        r = !1
                    }
                }
                r && (t.flags |= 4)
            }
            t.ref !== null && (t.flags |= 512,
            t.flags |= 2097152)
        }
        return Et(t),
        null;
    case 6:
        if (e && t.stateNode != null)
            oS(e, t, e.memoizedProps, r);
        else {
            if (typeof r != "string" && t.stateNode === null)
                throw Error(M(166));
            if (n = Pi(ca.current),
            Pi(ir.current),
            ql(t)) {
                if (r = t.stateNode,
                n = t.memoizedProps,
                r[nr] = t,
                (o = r.nodeValue !== n) && (e = nn,
                e !== null))
                    switch (e.tag) {
                    case 3:
                        Gl(r.nodeValue, n, (1 & e.mode) !== 0);
                        break;
                    case 5:
                        e.memoizedProps.suppressHydrationWarning !== !0 && Gl(r.nodeValue, n, (1 & e.mode) !== 0)
                    }
                o && (t.flags |= 4)
            } else
                r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r),
                r[nr] = t,
                t.stateNode = r
        }
        return Et(t),
        null;
    case 13:
        if (Ve($e),
        r = t.memoizedState,
        e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            if (ze && tn !== null && 1 & t.mode && !(128 & t.flags))
                Sw(),
                Do(),
                t.flags |= 98560,
                o = !1;
            else if (o = ql(t),
            r !== null && r.dehydrated !== null) {
                if (e === null) {
                    if (!o)
                        throw Error(M(318));
                    if (o = t.memoizedState,
                    o = o !== null ? o.dehydrated : null,
                    !o)
                        throw Error(M(317));
                    o[nr] = t
                } else
                    Do(),
                    !(128 & t.flags) && (t.memoizedState = null),
                    t.flags |= 4;
                Et(t),
                o = !1
            } else
                An !== null && (op(An),
                An = null),
                o = !0;
            if (!o)
                return 65536 & t.flags ? t : null
        }
        return 128 & t.flags ? (t.lanes = n,
        t) : (r = r !== null,
        r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192,
        1 & t.mode && (e === null || 1 & $e.current ? st === 0 && (st = 3) : Wp())),
        t.updateQueue !== null && (t.flags |= 4),
        Et(t),
        null);
    case 4:
        return Bo(),
        Zh(e, t),
        e === null && oa(t.stateNode.containerInfo),
        Et(t),
        null;
    case 10:
        return Ep(t.type._context),
        Et(t),
        null;
    case 17:
        return Gt(t.type) && vc(),
        Et(t),
        null;
    case 19:
        if (Ve($e),
        o = t.memoizedState,
        o === null)
            return Et(t),
            null;
        if (r = (128 & t.flags) !== 0,
        s = o.rendering,
        s === null)
            if (r)
                Vs(o, !1);
            else {
                if (st !== 0 || e !== null && 128 & e.flags)
                    for (e = t.child; e !== null; ) {
                        if (s = Cc(e),
                        s !== null) {
                            for (t.flags |= 128,
                            Vs(o, !1),
                            r = s.updateQueue,
                            r !== null && (t.updateQueue = r,
                            t.flags |= 4),
                            t.subtreeFlags = 0,
                            r = n,
                            n = t.child; n !== null; )
                                o = n,
                                e = r,
                                o.flags &= 14680066,
                                s = o.alternate,
                                s === null ? (o.childLanes = 0,
                                o.lanes = e,
                                o.child = null,
                                o.subtreeFlags = 0,
                                o.memoizedProps = null,
                                o.memoizedState = null,
                                o.updateQueue = null,
                                o.dependencies = null,
                                o.stateNode = null) : (o.childLanes = s.childLanes,
                                o.lanes = s.lanes,
                                o.child = s.child,
                                o.subtreeFlags = 0,
                                o.deletions = null,
                                o.memoizedProps = s.memoizedProps,
                                o.memoizedState = s.memoizedState,
                                o.updateQueue = s.updateQueue,
                                o.type = s.type,
                                e = s.dependencies,
                                o.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }),
                                n = n.sibling;
                            return Pe($e, 1 & $e.current | 2),
                            t.child
                        }
                        e = e.sibling
                    }
                o.tail !== null && Ze() > No && (t.flags |= 128,
                r = !0,
                Vs(o, !1),
                t.lanes = 4194304)
            }
        else {
            if (!r)
                if (e = Cc(s),
                e !== null) {
                    if (t.flags |= 128,
                    r = !0,
                    n = e.updateQueue,
                    n !== null && (t.updateQueue = n,
                    t.flags |= 4),
                    Vs(o, !0),
                    o.tail === null && o.tailMode === "hidden" && !s.alternate && !ze)
                        return Et(t),
                        null
                } else
                    2 * Ze() - o.renderingStartTime > No && n !== 1073741824 && (t.flags |= 128,
                    r = !0,
                    Vs(o, !1),
                    t.lanes = 4194304);
            o.isBackwards ? (s.sibling = t.child,
            t.child = s) : (n = o.last,
            n !== null ? n.sibling = s : t.child = s,
            o.last = s)
        }
        return o.tail !== null ? (t = o.tail,
        o.rendering = t,
        o.tail = t.sibling,
        o.renderingStartTime = Ze(),
        t.sibling = null,
        n = $e.current,
        Pe($e, r ? 1 & n | 2 : 1 & n),
        t) : (Et(t),
        null);
    case 22:
    case 23:
        return Hp(),
        r = t.memoizedState !== null,
        e !== null && e.memoizedState !== null !== r && (t.flags |= 8192),
        r && 1 & t.mode ? 1073741824 & en && (Et(t),
        6 & t.subtreeFlags && (t.flags |= 8192)) : Et(t),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(M(156, t.tag))
}
function TO(e, t) {
    switch (kp(t),
    t.tag) {
    case 1:
        return Gt(t.type) && vc(),
        e = t.flags,
        65536 & e ? (t.flags = -65537 & e | 128,
        t) : null;
    case 3:
        return Bo(),
        Ve(Ut),
        Ve(Pt),
        Op(),
        e = t.flags,
        65536 & e && !(128 & e) ? (t.flags = -65537 & e | 128,
        t) : null;
    case 5:
        return Ip(t),
        null;
    case 13:
        if (Ve($e),
        e = t.memoizedState,
        e !== null && e.dehydrated !== null) {
            if (t.alternate === null)
                throw Error(M(340));
            Do()
        }
        return e = t.flags,
        65536 & e ? (t.flags = -65537 & e | 128,
        t) : null;
    case 19:
        return Ve($e),
        null;
    case 4:
        return Bo(),
        null;
    case 10:
        return Ep(t.type._context),
        null;
    case 22:
    case 23:
        return Hp(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Kl = !1
  , Ft = !1
  , RO = typeof WeakSet == "function" ? WeakSet : Set
  , N = null;
function Eo(e, t) {
    var n = e.ref;
    if (n !== null)
        if (typeof n == "function")
            try {
                n(null)
            } catch (r) {
                qe(e, t, r)
            }
        else
            n.current = null
}
function sS(e, t, n) {
    try {
        n()
    } catch (r) {
        qe(e, t, r)
    }
}
var hx = !1;
function EO(e, t) {
    if (Ah = hc,
    e = cw(),
    wp(e)) {
        if ("selectionStart"in e)
            var n = {
                start: e.selectionStart,
                end: e.selectionEnd
            };
        else
            e: {
                n = (n = e.ownerDocument) && n.defaultView || P;
                var r = n.getSelection && n.getSelection();
                if (r && r.rangeCount !== 0) {
                    n = r.anchorNode;
                    var i = r.anchorOffset
                      , o = r.focusNode;
                    r = r.focusOffset;
                    try {
                        n.nodeType,
                        o.nodeType
                    } catch {
                        n = null;
                        break e
                    }
                    var s = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , u = 0
                      , f = e
                      , d = null;
                    t: for (; ; ) {
                        for (var p; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i),
                        f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r),
                        f.nodeType === 3 && (s += f.nodeValue.length),
                        (p = f.firstChild) !== null; )
                            d = f,
                            f = p;
                        for (; ; ) {
                            if (f === e)
                                break t;
                            if (d === n && ++c === i && (a = s),
                            d === o && ++u === r && (l = s),
                            (p = f.nextSibling) !== null)
                                break;
                            f = d,
                            d = f.parentNode
                        }
                        f = p
                    }
                    n = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    n = null
            }
        n = n || {
            start: 0,
            end: 0
        }
    } else
        n = null;
    for (Dh = {
        focusedElem: e,
        selectionRange: n
    },
    hc = !1,
    N = t; N !== null; )
        if (t = N,
        e = t.child,
        (1028 & t.subtreeFlags) !== 0 && e !== null)
            e.return = t,
            N = e;
        else
            for (; N !== null; ) {
                t = N;
                try {
                    var v = t.alternate;
                    if (1024 & t.flags)
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (v !== null) {
                                var g = v.memoizedProps
                                  , b = v.memoizedState
                                  , m = t.stateNode
                                  , h = m.getSnapshotBeforeUpdate(t.elementType === t.type ? g : Ln(t.type, g), b);
                                m.__reactInternalSnapshotBeforeUpdate = h
                            }
                            break;
                        case 3:
                            var y = t.stateNode.containerInfo;
                            y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(M(163))
                        }
                } catch (w) {
                    qe(t, t.return, w)
                }
                if (e = t.sibling,
                e !== null) {
                    e.return = t.return,
                    N = e;
                    break
                }
                N = t.return
            }
    return v = hx,
    hx = !1,
    v
}
function Xs(e, t, n) {
    var r = t.updateQueue;
    if (r = r !== null ? r.lastEffect : null,
    r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & e) === e) {
                var o = i.destroy;
                i.destroy = void 0,
                o !== void 0 && sS(t, n, o)
            }
            i = i.next
        } while (i !== r)
    }
}
function $c(e, t) {
    if (t = t.updateQueue,
    t = t !== null ? t.lastEffect : null,
    t !== null) {
        var n = t = t.next;
        do {
            if ((n.tag & e) === e) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== t)
    }
}
function Jh(e) {
    var t = e.ref;
    if (t !== null) {
        var n = e.stateNode;
        switch (e.tag) {
        case 5:
            e = n;
            break;
        default:
            e = n
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}
function aS(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null,
    aS(t)),
    e.child = null,
    e.deletions = null,
    e.sibling = null,
    e.tag === 5 && (t = e.stateNode,
    t !== null && (delete t[nr],
    delete t[aa],
    delete t[$h],
    delete t[cO],
    delete t[uO])),
    e.stateNode = null,
    e.return = null,
    e.dependencies = null,
    e.memoizedProps = null,
    e.memoizedState = null,
    e.pendingProps = null,
    e.stateNode = null,
    e.updateQueue = null
}
function lS(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function px(e) {
    e: for (; ; ) {
        for (; e.sibling === null; ) {
            if (e.return === null || lS(e.return))
                return null;
            e = e.return
        }
        for (e.sibling.return = e.return,
        e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
            if (2 & e.flags || e.child === null || e.tag === 4)
                continue e;
            e.child.return = e,
            e = e.child
        }
        if (!(2 & e.flags))
            return e.stateNode
    }
}
function ep(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6)
        e = e.stateNode,
        t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode,
        t.insertBefore(e, n)) : (t = n,
        t.appendChild(e)),
        n = n._reactRootContainer,
        n != null || t.onclick !== null || (t.onclick = gc));
    else if (r !== 4 && (e = e.child,
    e !== null))
        for (ep(e, t, n),
        e = e.sibling; e !== null; )
            ep(e, t, n),
            e = e.sibling
}
function tp(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6)
        e = e.stateNode,
        t ? n.insertBefore(e, t) : n.appendChild(e);
    else if (r !== 4 && (e = e.child,
    e !== null))
        for (tp(e, t, n),
        e = e.sibling; e !== null; )
            tp(e, t, n),
            e = e.sibling
}
var bt = null
  , Vn = !1;
function Wr(e, t, n) {
    for (n = n.child; n !== null; )
        cS(e, t, n),
        n = n.sibling
}
function cS(e, t, n) {
    if (rr && typeof rr.onCommitFiberUnmount == "function")
        try {
            rr.onCommitFiberUnmount(Oc, n)
        } catch {}
    switch (n.tag) {
    case 5:
        Ft || Eo(n, t);
    case 6:
        var r = bt
          , i = Vn;
        bt = null,
        Wr(e, t, n),
        bt = r,
        Vn = i,
        bt !== null && (Vn ? (e = bt,
        n = n.stateNode,
        e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : bt.removeChild(n.stateNode));
        break;
    case 18:
        bt !== null && (Vn ? (e = bt,
        n = n.stateNode,
        e.nodeType === 8 ? oh(e.parentNode, n) : e.nodeType === 1 && oh(e, n),
        na(e)) : oh(bt, n.stateNode));
        break;
    case 4:
        r = bt,
        i = Vn,
        bt = n.stateNode.containerInfo,
        Vn = !0,
        Wr(e, t, n),
        bt = r,
        Vn = i;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!Ft && (r = n.updateQueue,
        r !== null && (r = r.lastEffect,
        r !== null))) {
            i = r = r.next;
            do {
                var o = i
                  , s = o.destroy;
                o = o.tag,
                s !== void 0 && (2 & o || 4 & o) && sS(n, t, s),
                i = i.next
            } while (i !== r)
        }
        Wr(e, t, n);
        break;
    case 1:
        if (!Ft && (Eo(n, t),
        r = n.stateNode,
        typeof r.componentWillUnmount == "function"))
            try {
                r.props = n.memoizedProps,
                r.state = n.memoizedState,
                r.componentWillUnmount()
            } catch (a) {
                qe(n, t, a)
            }
        Wr(e, t, n);
        break;
    case 21:
        Wr(e, t, n);
        break;
    case 22:
        1 & n.mode ? (Ft = (r = Ft) || n.memoizedState !== null,
        Wr(e, t, n),
        Ft = r) : Wr(e, t, n);
        break;
    default:
        Wr(e, t, n)
    }
}
function mx(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var n = e.stateNode;
        n === null && (n = e.stateNode = new RO),
        t.forEach(function(r) {
            var i = AO.bind(null, e, r);
            n.has(r) || (n.add(r),
            r.then(i, i))
        })
    }
}
function Mn(e, t) {
    var n = t.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var o = e
                  , s = t
                  , a = s;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        bt = a.stateNode,
                        Vn = !1;
                        break e;
                    case 3:
                        bt = a.stateNode.containerInfo,
                        Vn = !0;
                        break e;
                    case 4:
                        bt = a.stateNode.containerInfo,
                        Vn = !0;
                        break e
                    }
                    a = a.return
                }
                if (bt === null)
                    throw Error(M(160));
                cS(o, s, i),
                bt = null,
                Vn = !1;
                var l = i.alternate;
                l !== null && (l.return = null),
                i.return = null
            } catch (c) {
                qe(i, t, c)
            }
        }
    if (12854 & t.subtreeFlags)
        for (t = t.child; t !== null; )
            uS(t, e),
            t = t.sibling
}
function uS(e, t) {
    var n = e.alternate
      , r = e.flags;
    switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Mn(t, e),
        er(e),
        4 & r) {
            try {
                Xs(3, e, e.return),
                $c(3, e)
            } catch (g) {
                qe(e, e.return, g)
            }
            try {
                Xs(5, e, e.return)
            } catch (g) {
                qe(e, e.return, g)
            }
        }
        break;
    case 1:
        Mn(t, e),
        er(e),
        512 & r && n !== null && Eo(n, n.return);
        break;
    case 5:
        if (Mn(t, e),
        er(e),
        512 & r && n !== null && Eo(n, n.return),
        32 & e.flags) {
            var i = e.stateNode;
            try {
                Zs(i, "")
            } catch (g) {
                qe(e, e.return, g)
            }
        }
        if (4 & r && (i = e.stateNode,
        i != null)) {
            var o = e.memoizedProps
              , s = n !== null ? n.memoizedProps : o
              , a = e.type
              , l = e.updateQueue;
            if (e.updateQueue = null,
            l !== null)
                try {
                    a === "input" && o.type === "radio" && o.name != null && _x(i, o),
                    Rh(a, s);
                    var c = Rh(a, o);
                    for (s = 0; s < l.length; s += 2) {
                        var u = l[s]
                          , f = l[s + 1];
                        u === "style" ? Vx(i, f) : u === "dangerouslySetInnerHTML" ? Mx(i, f) : u === "children" ? Zs(i, f) : lp(i, u, f, c)
                    }
                    switch (a) {
                    case "input":
                        wh(i, o);
                        break;
                    case "textarea":
                        Ix(i, o);
                        break;
                    case "select":
                        var d = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!o.multiple;
                        var p = o.value;
                        p != null ? Po(i, !!o.multiple, p, !1) : d !== !!o.multiple && (o.defaultValue != null ? Po(i, !!o.multiple, o.defaultValue, !0) : Po(i, !!o.multiple, o.multiple ? [] : "", !1))
                    }
                    i[aa] = o
                } catch (g) {
                    qe(e, e.return, g)
                }
        }
        break;
    case 6:
        if (Mn(t, e),
        er(e),
        4 & r) {
            if (e.stateNode === null)
                throw Error(M(162));
            i = e.stateNode,
            o = e.memoizedProps;
            try {
                i.nodeValue = o
            } catch (g) {
                qe(e, e.return, g)
            }
        }
        break;
    case 3:
        if (Mn(t, e),
        er(e),
        4 & r && n !== null && n.memoizedState.isDehydrated)
            try {
                na(t.containerInfo)
            } catch (g) {
                qe(e, e.return, g)
            }
        break;
    case 4:
        Mn(t, e),
        er(e);
        break;
    case 13:
        Mn(t, e),
        er(e),
        i = e.child,
        8192 & i.flags && (o = i.memoizedState !== null,
        i.stateNode.isHidden = o,
        !o || i.alternate !== null && i.alternate.memoizedState !== null || (Np = Ze())),
        4 & r && mx(e);
        break;
    case 22:
        if (u = n !== null && n.memoizedState !== null,
        1 & e.mode ? (Ft = (c = Ft) || u,
        Mn(t, e),
        Ft = c) : Mn(t, e),
        er(e),
        8192 & r) {
            if (c = e.memoizedState !== null,
            (e.stateNode.isHidden = c) && !u && 1 & e.mode)
                for (N = e,
                u = e.child; u !== null; ) {
                    for (f = N = u; N !== null; ) {
                        switch (d = N,
                        p = d.child,
                        d.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Xs(4, d, d.return);
                            break;
                        case 1:
                            Eo(d, d.return);
                            var v = d.stateNode;
                            if (typeof v.componentWillUnmount == "function") {
                                r = d,
                                n = d.return;
                                try {
                                    t = r,
                                    v.props = t.memoizedProps,
                                    v.state = t.memoizedState,
                                    v.componentWillUnmount()
                                } catch (g) {
                                    qe(r, n, g)
                                }
                            }
                            break;
                        case 5:
                            Eo(d, d.return);
                            break;
                        case 22:
                            if (d.memoizedState !== null) {
                                vx(f);
                                continue
                            }
                        }
                        p !== null ? (p.return = d,
                        N = p) : vx(f)
                    }
                    u = u.sibling
                }
            e: for (u = null,
            f = e; ; ) {
                if (f.tag === 5) {
                    if (u === null) {
                        u = f;
                        try {
                            i = f.stateNode,
                            c ? (o = i.style,
                            typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode,
                            l = f.memoizedProps.style,
                            s = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = Lx("display", s))
                        } catch (g) {
                            qe(e, e.return, g)
                        }
                    }
                } else if (f.tag === 6) {
                    if (u === null)
                        try {
                            f.stateNode.nodeValue = c ? "" : f.memoizedProps
                        } catch (g) {
                            qe(e, e.return, g)
                        }
                } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) {
                    f.child.return = f,
                    f = f.child;
                    continue
                }
                if (f === e)
                    break e;
                for (; f.sibling === null; ) {
                    if (f.return === null || f.return === e)
                        break e;
                    u === f && (u = null),
                    f = f.return
                }
                u === f && (u = null),
                f.sibling.return = f.return,
                f = f.sibling
            }
        }
        break;
    case 19:
        Mn(t, e),
        er(e),
        4 & r && mx(e);
        break;
    case 21:
        break;
    default:
        Mn(t, e),
        er(e)
    }
}
function er(e) {
    var t = e.flags;
    if (2 & t) {
        try {
            e: {
                for (var n = e.return; n !== null; ) {
                    if (lS(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(M(160))
            }
            switch (r.tag) {
            case 5:
                var i = r.stateNode;
                32 & r.flags && (Zs(i, ""),
                r.flags &= -33);
                var o = px(e);
                tp(e, o, i);
                break;
            case 3:
            case 4:
                var s = r.stateNode.containerInfo
                  , a = px(e);
                ep(e, a, s);
                break;
            default:
                throw Error(M(161))
            }
        } catch (l) {
            qe(e, e.return, l)
        }
        e.flags &= -3
    }
    4096 & t && (e.flags &= -4097)
}
function FO(e, t, n) {
    N = e,
    fS(e, t, n)
}
function fS(e, t, n) {
    for (var r = (1 & e.mode) !== 0; N !== null; ) {
        var i = N
          , o = i.child;
        if (i.tag === 22 && r) {
            var s = i.memoizedState !== null || Kl;
            if (!s) {
                var a = i.alternate
                  , l = a !== null && a.memoizedState !== null || Ft;
                a = Kl;
                var c = Ft;
                if (Kl = s,
                (Ft = l) && !c)
                    for (N = i; N !== null; )
                        s = N,
                        l = s.child,
                        s.tag === 22 && s.memoizedState !== null ? yx(i) : l !== null ? (l.return = s,
                        N = l) : yx(i);
                for (; o !== null; )
                    N = o,
                    fS(o, t, n),
                    o = o.sibling;
                N = i,
                Kl = a,
                Ft = c
            }
            gx(e, t, n)
        } else
            8772 & i.subtreeFlags && o !== null ? (o.return = i,
            N = o) : gx(e, t, n)
    }
}
function gx(e) {
    for (; N !== null; ) {
        var t = N;
        if (8772 & t.flags) {
            var n = t.alternate;
            try {
                if (8772 & t.flags)
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Ft || $c(5, t);
                        break;
                    case 1:
                        var r = t.stateNode;
                        if (4 & t.flags && !Ft)
                            if (n === null)
                                r.componentDidMount();
                            else {
                                var i = t.elementType === t.type ? n.memoizedProps : Ln(t.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var o = t.updateQueue;
                        o !== null && Jb(t, o, r);
                        break;
                    case 3:
                        var s = t.updateQueue;
                        if (s !== null) {
                            if (n = null,
                            t.child !== null)
                                switch (t.child.tag) {
                                case 5:
                                    n = t.child.stateNode;
                                    break;
                                case 1:
                                    n = t.child.stateNode
                                }
                            Jb(t, s, n)
                        }
                        break;
                    case 5:
                        var a = t.stateNode;
                        if (n === null && 4 & t.flags) {
                            n = a;
                            var l = t.memoizedProps;
                            switch (t.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && n.focus();
                                break;
                            case "img":
                                l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var c = t.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var f = u.dehydrated;
                                    f !== null && na(f)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(M(163))
                    }
                Ft || 512 & t.flags && Jh(t)
            } catch (d) {
                qe(t, t.return, d)
            }
        }
        if (t === e) {
            N = null;
            break
        }
        if (n = t.sibling,
        n !== null) {
            n.return = t.return,
            N = n;
            break
        }
        N = t.return
    }
}
function vx(e) {
    for (; N !== null; ) {
        var t = N;
        if (t === e) {
            N = null;
            break
        }
        var n = t.sibling;
        if (n !== null) {
            n.return = t.return,
            N = n;
            break
        }
        N = t.return
    }
}
function yx(e) {
    for (; N !== null; ) {
        var t = N;
        try {
            switch (t.tag) {
            case 0:
            case 11:
            case 15:
                var n = t.return;
                try {
                    $c(4, t)
                } catch (l) {
                    qe(t, n, l)
                }
                break;
            case 1:
                var r = t.stateNode;
                if (typeof r.componentDidMount == "function") {
                    var i = t.return;
                    try {
                        r.componentDidMount()
                    } catch (l) {
                        qe(t, i, l)
                    }
                }
                var o = t.return;
                try {
                    Jh(t)
                } catch (l) {
                    qe(t, o, l)
                }
                break;
            case 5:
                var s = t.return;
                try {
                    Jh(t)
                } catch (l) {
                    qe(t, s, l)
                }
            }
        } catch (l) {
            qe(t, t.return, l)
        }
        if (t === e) {
            N = null;
            break
        }
        var a = t.sibling;
        if (a !== null) {
            a.return = t.return,
            N = a;
            break
        }
        N = t.return
    }
}
var PO = Math.ceil
  , Ec = _r.ReactCurrentDispatcher
  , Bp = _r.ReactCurrentOwner
  , kn = _r.ReactCurrentBatchConfig
  , ye = 0
  , ft = null
  , tt = null
  , xt = 0
  , en = 0
  , Fo = li(0)
  , st = 0
  , ha = null
  , Vi = 0
  , Nc = 0
  , $p = 0
  , Ys = null
  , Ht = null
  , Np = 0
  , No = 1 / 0
  , wr = null
  , Fc = !1
  , np = null
  , ni = null
  , Ql = !1
  , Kr = null
  , Pc = 0
  , Ks = 0
  , rp = null
  , oc = -1
  , sc = 0;
function Dt() {
    return 6 & ye ? Ze() : oc !== -1 ? oc : oc = Ze()
}
function ri(e) {
    return 1 & e.mode ? 2 & ye && xt !== 0 ? xt & -xt : dO.transition !== null ? (sc === 0 && (sc = qx()),
    sc) : (e = Se,
    e !== 0 || (e = P.event,
    e = e === void 0 ? 16 : ew(e.type)),
    e) : 1
}
function zn(e, t, n, r) {
    if (50 < Ks)
        throw Ks = 0,
        rp = null,
        Error(M(185));
    pa(e, n, r),
    2 & ye && e === ft || (e === ft && (!(2 & ye) && (Nc |= n),
    st === 4 && Xr(e, xt)),
    qt(e, r),
    n === 1 && ye === 0 && !(1 & t.mode) && (No = Ze() + 500,
    Dc && ci()))
}
function qt(e, t) {
    var n = e.callbackNode;
    p2(e, t);
    var r = dc(e, e === ft ? xt : 0);
    if (r === 0)
        n !== null && Rb(n),
        e.callbackNode = null,
        e.callbackPriority = 0;
    else if (t = r & -r,
    e.callbackPriority !== t) {
        if (n != null && Rb(n),
        t === 1)
            e.tag === 0 ? fO(bx.bind(null, e)) : bw(bx.bind(null, e)),
            aO(function() {
                !(6 & ye) && ci()
            }),
            n = null;
        else {
            switch (Xx(r)) {
            case 1:
                n = hp;
                break;
            case 4:
                n = Ux;
                break;
            case 16:
                n = fc;
                break;
            case 536870912:
                n = Gx;
                break;
            default:
                n = fc
            }
            n = bS(n, dS.bind(null, e))
        }
        e.callbackPriority = t,
        e.callbackNode = n
    }
}
function dS(e, t) {
    if (oc = -1,
    sc = 0,
    6 & ye)
        throw Error(M(327));
    var n = e.callbackNode;
    if (Lo() && e.callbackNode !== n)
        return null;
    var r = dc(e, e === ft ? xt : 0);
    if (r === 0)
        return null;
    if (30 & r || r & e.expiredLanes || t)
        t = _c(e, r);
    else {
        t = r;
        var i = ye;
        ye |= 2;
        var o = pS();
        ft === e && xt === t || (wr = null,
        No = Ze() + 500,
        _i(e, t));
        do
            try {
                OO();
                break
            } catch (a) {
                hS(e, a)
            }
        while (1);
        Rp(),
        Ec.current = o,
        ye = i,
        tt !== null ? t = 0 : (ft = null,
        xt = 0,
        t = st)
    }
    if (t !== 0) {
        if (t === 2 && (i = Ih(e),
        i !== 0 && (r = i,
        t = ip(e, i))),
        t === 1)
            throw n = ha,
            _i(e, 0),
            Xr(e, r),
            qt(e, Ze()),
            n;
        if (t === 6)
            Xr(e, r);
        else {
            if (i = e.current.alternate,
            !(30 & r) && !_O(i) && (t = _c(e, r),
            t === 2 && (o = Ih(e),
            o !== 0 && (r = o,
            t = ip(e, o))),
            t === 1))
                throw n = ha,
                _i(e, 0),
                Xr(e, r),
                qt(e, Ze()),
                n;
            switch (e.finishedWork = i,
            e.finishedLanes = r,
            t) {
            case 0:
            case 1:
                throw Error(M(345));
            case 2:
                Ri(e, Ht, wr);
                break;
            case 3:
                if (Xr(e, r),
                (130023424 & r) === r && (t = Np + 500 - Ze(),
                10 < t)) {
                    if (dc(e, 0) !== 0)
                        break;
                    if (i = e.suspendedLanes,
                    (i & r) !== r) {
                        Dt(),
                        e.pingedLanes |= e.suspendedLanes & i;
                        break
                    }
                    e.timeoutHandle = Bh(Ri.bind(null, e, Ht, wr), t);
                    break
                }
                Ri(e, Ht, wr);
                break;
            case 4:
                if (Xr(e, r),
                (4194240 & r) === r)
                    break;
                for (t = e.eventTimes,
                i = -1; 0 < r; ) {
                    var s = 31 - Dn(r);
                    o = 1 << s,
                    s = t[s],
                    s > i && (i = s),
                    r &= ~o
                }
                if (r = i,
                r = Ze() - r,
                r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * PO(r / 1960)) - r,
                10 < r) {
                    e.timeoutHandle = Bh(Ri.bind(null, e, Ht, wr), r);
                    break
                }
                Ri(e, Ht, wr);
                break;
            case 5:
                Ri(e, Ht, wr);
                break;
            default:
                throw Error(M(329))
            }
        }
    }
    return qt(e, Ze()),
    e.callbackNode === n ? dS.bind(null, e) : null
}
function ip(e, t) {
    var n = Ys;
    return e.current.memoizedState.isDehydrated && (_i(e, t).flags |= 256),
    e = _c(e, t),
    e !== 2 && (t = Ht,
    Ht = n,
    t !== null && op(t)),
    e
}
function op(e) {
    Ht === null ? Ht = e : Ht.push.apply(Ht, e)
}
function _O(e) {
    for (var t = e; ; ) {
        if (16384 & t.flags) {
            var n = t.updateQueue;
            if (n !== null && (n = n.stores,
            n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r]
                      , o = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!Bn(o(), i))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = t.child,
        16384 & t.subtreeFlags && n !== null)
            n.return = t,
            t = n;
        else {
            if (t === e)
                break;
            for (; t.sibling === null; ) {
                if (t.return === null || t.return === e)
                    return !0;
                t = t.return
            }
            t.sibling.return = t.return,
            t = t.sibling
        }
    }
    return !0
}
function Xr(e, t) {
    for (t &= ~$p,
    t &= ~Nc,
    e.suspendedLanes |= t,
    e.pingedLanes &= ~t,
    e = e.expirationTimes; 0 < t; ) {
        var n = 31 - Dn(t)
          , r = 1 << n;
        e[n] = -1,
        t &= ~r
    }
}
function bx(e) {
    if (6 & ye)
        throw Error(M(327));
    Lo();
    var t = dc(e, 0);
    if (!(1 & t))
        return qt(e, Ze()),
        null;
    var n = _c(e, t);
    if (e.tag !== 0 && n === 2) {
        var r = Ih(e);
        r !== 0 && (t = r,
        n = ip(e, r))
    }
    if (n === 1)
        throw n = ha,
        _i(e, 0),
        Xr(e, t),
        qt(e, Ze()),
        n;
    if (n === 6)
        throw Error(M(345));
    return e.finishedWork = e.current.alternate,
    e.finishedLanes = t,
    Ri(e, Ht, wr),
    qt(e, Ze()),
    null
}
function jp(e, t) {
    var n = ye;
    ye |= 1;
    try {
        return e(t)
    } finally {
        ye = n,
        ye === 0 && (No = Ze() + 500,
        Dc && ci())
    }
}
function Ai(e) {
    Kr !== null && Kr.tag === 0 && !(6 & ye) && Lo();
    var t = ye;
    ye |= 1;
    var n = kn.transition
      , r = Se;
    try {
        if (kn.transition = null,
        Se = 1,
        e)
            return e()
    } finally {
        Se = r,
        kn.transition = n,
        ye = t,
        !(6 & ye) && ci()
    }
}
function Hp() {
    en = Fo.current,
    Ve(Fo)
}
function _i(e, t) {
    e.finishedWork = null,
    e.finishedLanes = 0;
    var n = e.timeoutHandle;
    if (n !== -1 && (e.timeoutHandle = -1,
    sO(n)),
    tt !== null)
        for (n = tt.return; n !== null; ) {
            var r = n;
            switch (kp(r),
            r.tag) {
            case 1:
                r = r.type.childContextTypes,
                r != null && vc();
                break;
            case 3:
                Bo(),
                Ve(Ut),
                Ve(Pt),
                Op();
                break;
            case 5:
                Ip(r);
                break;
            case 4:
                Bo();
                break;
            case 13:
                Ve($e);
                break;
            case 19:
                Ve($e);
                break;
            case 10:
                Ep(r.type._context);
                break;
            case 22:
            case 23:
                Hp()
            }
            n = n.return
        }
    if (ft = e,
    tt = e = ii(e.current, null),
    xt = en = t,
    st = 0,
    ha = null,
    $p = Nc = Vi = 0,
    Ht = Ys = null,
    Fi !== null) {
        for (t = 0; t < Fi.length; t++)
            if (n = Fi[t],
            r = n.interleaved,
            r !== null) {
                n.interleaved = null;
                var i = r.next
                  , o = n.pending;
                if (o !== null) {
                    var s = o.next;
                    o.next = i,
                    r.next = s
                }
                n.pending = r
            }
        Fi = null
    }
    return e
}
function hS(e, t) {
    do {
        var n = tt;
        try {
            if (Rp(),
            nc.current = Rc,
            Tc) {
                for (var r = Ne.memoizedState; r !== null; ) {
                    var i = r.queue;
                    i !== null && (i.pending = null),
                    r = r.next
                }
                Tc = !1
            }
            if (Li = 0,
            ut = ot = Ne = null,
            qs = !1,
            ua = 0,
            Bp.current = null,
            n === null || n.return === null) {
                st = 1,
                ha = t,
                tt = null;
                break
            }
            e: {
                var o = e
                  , s = n.return
                  , a = n
                  , l = t;
                if (t = xt,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , u = a
                      , f = u.tag;
                    if (!(1 & u.mode) && (f === 0 || f === 11 || f === 15)) {
                        var d = u.alternate;
                        d ? (u.updateQueue = d.updateQueue,
                        u.memoizedState = d.memoizedState,
                        u.lanes = d.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var p = sx(s);
                    if (p !== null) {
                        p.flags &= -257,
                        ax(p, s, a, o, t),
                        1 & p.mode && ox(o, c, t),
                        t = p,
                        l = c;
                        var v = t.updateQueue;
                        if (v === null) {
                            var g = new Set;
                            g.add(l),
                            t.updateQueue = g
                        } else
                            v.add(l);
                        break e
                    }
                    if (!(1 & t)) {
                        ox(o, c, t),
                        Wp();
                        break e
                    }
                    l = Error(M(426))
                } else if (ze && 1 & a.mode) {
                    var b = sx(s);
                    if (b !== null) {
                        !(65536 & b.flags) && (b.flags |= 256),
                        ax(b, s, a, o, t),
                        Cp($o(l, a));
                        break e
                    }
                }
                o = l = $o(l, a),
                st !== 4 && (st = 2),
                Ys === null ? Ys = [o] : Ys.push(o),
                o = s;
                do {
                    switch (o.tag) {
                    case 3:
                        o.flags |= 65536,
                        t &= -t,
                        o.lanes |= t;
                        var m = Yw(o, l, t);
                        Zb(o, m);
                        break e;
                    case 1:
                        a = l;
                        var h = o.type
                          , y = o.stateNode;
                        if (!(128 & o.flags) && (typeof h.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (ni === null || !ni.has(y)))) {
                            o.flags |= 65536,
                            t &= -t,
                            o.lanes |= t;
                            var w = Kw(o, a, t);
                            Zb(o, w);
                            break e
                        }
                    }
                    o = o.return
                } while (o !== null)
            }
            gS(n)
        } catch (C) {
            t = C,
            tt === n && n !== null && (tt = n = n.return);
            continue
        }
        break
    } while (1)
}
function pS() {
    var e = Ec.current;
    return Ec.current = Rc,
    e === null ? Rc : e
}
function Wp() {
    st !== 0 && st !== 3 && st !== 2 || (st = 4),
    ft === null || !(268435455 & Vi) && !(268435455 & Nc) || Xr(ft, xt)
}
function _c(e, t) {
    var n = ye;
    ye |= 2;
    var r = pS();
    ft === e && xt === t || (wr = null,
    _i(e, t));
    do
        try {
            IO();
            break
        } catch (i) {
            hS(e, i)
        }
    while (1);
    if (Rp(),
    ye = n,
    Ec.current = r,
    tt !== null)
        throw Error(M(261));
    return ft = null,
    xt = 0,
    st
}
function IO() {
    for (; tt !== null; )
        mS(tt)
}
function OO() {
    for (; tt !== null && !o2(); )
        mS(tt)
}
function mS(e) {
    var t = yS(e.alternate, e, en);
    e.memoizedProps = e.pendingProps,
    t === null ? gS(e) : tt = t,
    Bp.current = null
}
function gS(e) {
    var t = e;
    do {
        var n = t.alternate;
        if (e = t.return,
        32768 & t.flags) {
            if (n = TO(n, t),
            n !== null) {
                n.flags &= 32767,
                tt = n;
                return
            }
            if (e === null) {
                st = 6,
                tt = null;
                return
            }
            e.flags |= 32768,
            e.subtreeFlags = 0,
            e.deletions = null
        } else if (n = CO(n, t, en),
        n !== null) {
            tt = n;
            return
        }
        if (t = t.sibling,
        t !== null) {
            tt = t;
            return
        }
        tt = t = e
    } while (t !== null);
    st === 0 && (st = 5)
}
function Ri(e, t, n) {
    var r = Se
      , i = kn.transition;
    try {
        kn.transition = null,
        Se = 1,
        MO(e, t, n, r)
    } finally {
        kn.transition = i,
        Se = r
    }
    return null
}
function MO(e, t, n, r) {
    do
        Lo();
    while (Kr !== null);
    if (6 & ye)
        throw Error(M(327));
    n = e.finishedWork;
    var i = e.finishedLanes;
    if (n === null)
        return null;
    if (e.finishedWork = null,
    e.finishedLanes = 0,
    n === e.current)
        throw Error(M(177));
    e.callbackNode = null,
    e.callbackPriority = 0;
    var o = n.lanes | n.childLanes;
    if (m2(e, o),
    e === ft && (tt = ft = null,
    xt = 0),
    !(2064 & n.subtreeFlags) && !(2064 & n.flags) || Ql || (Ql = !0,
    bS(fc, function() {
        return Lo(),
        null
    })),
    o = (15990 & n.flags) !== 0,
    15990 & n.subtreeFlags || o) {
        o = kn.transition,
        kn.transition = null;
        var s = Se;
        Se = 1;
        var a = ye;
        ye |= 4,
        Bp.current = null,
        EO(e, n),
        uS(n, e),
        tO(Dh),
        hc = !!Ah,
        Dh = Ah = null,
        e.current = n,
        FO(n, e, i),
        s2(),
        ye = a,
        Se = s,
        kn.transition = o
    } else
        e.current = n;
    if (Ql && (Ql = !1,
    Kr = e,
    Pc = i),
    o = e.pendingLanes,
    o === 0 && (ni = null),
    c2(n.stateNode, r),
    qt(e, Ze()),
    t !== null)
        for (r = e.onRecoverableError,
        n = 0; n < t.length; n++)
            i = t[n],
            r(i.value, {
                componentStack: i.stack,
                digest: i.digest
            });
    if (Fc)
        throw Fc = !1,
        e = np,
        np = null,
        e;
    return 1 & Pc && e.tag !== 0 && Lo(),
    o = e.pendingLanes,
    1 & o ? e === rp ? Ks++ : (Ks = 0,
    rp = e) : Ks = 0,
    ci(),
    null
}
function Lo() {
    if (Kr !== null) {
        var e = Xx(Pc)
          , t = kn.transition
          , n = Se;
        try {
            if (kn.transition = null,
            Se = 16 > e ? 16 : e,
            Kr === null)
                var r = !1;
            else {
                if (e = Kr,
                Kr = null,
                Pc = 0,
                6 & ye)
                    throw Error(M(331));
                var i = ye;
                for (ye |= 4,
                N = e.current; N !== null; ) {
                    var o = N
                      , s = o.child;
                    if (16 & N.flags) {
                        var a = o.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (N = c; N !== null; ) {
                                    var u = N;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Xs(8, u, o)
                                    }
                                    var f = u.child;
                                    if (f !== null)
                                        f.return = u,
                                        N = f;
                                    else
                                        for (; N !== null; ) {
                                            u = N;
                                            var d = u.sibling
                                              , p = u.return;
                                            if (aS(u),
                                            u === c) {
                                                N = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = p,
                                                N = d;
                                                break
                                            }
                                            N = p
                                        }
                                }
                            }
                            var v = o.alternate;
                            if (v !== null) {
                                var g = v.child;
                                if (g !== null) {
                                    v.child = null;
                                    do {
                                        var b = g.sibling;
                                        g.sibling = null,
                                        g = b
                                    } while (g !== null)
                                }
                            }
                            N = o
                        }
                    }
                    if (2064 & o.subtreeFlags && s !== null)
                        s.return = o,
                        N = s;
                    else
                        e: for (; N !== null; ) {
                            if (o = N,
                            2048 & o.flags)
                                switch (o.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Xs(9, o, o.return)
                                }
                            var m = o.sibling;
                            if (m !== null) {
                                m.return = o.return,
                                N = m;
                                break e
                            }
                            N = o.return
                        }
                }
                var h = e.current;
                for (N = h; N !== null; ) {
                    s = N;
                    var y = s.child;
                    if (2064 & s.subtreeFlags && y !== null)
                        y.return = s,
                        N = y;
                    else
                        e: for (s = h; N !== null; ) {
                            if (a = N,
                            2048 & a.flags)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        $c(9, a)
                                    }
                                } catch (C) {
                                    qe(a, a.return, C)
                                }
                            if (a === s) {
                                N = null;
                                break e
                            }
                            var w = a.sibling;
                            if (w !== null) {
                                w.return = a.return,
                                N = w;
                                break e
                            }
                            N = a.return
                        }
                }
                if (ye = i,
                ci(),
                rr && typeof rr.onPostCommitFiberRoot == "function")
                    try {
                        rr.onPostCommitFiberRoot(Oc, e)
                    } catch {}
                r = !0
            }
            return r
        } finally {
            Se = n,
            kn.transition = t
        }
    }
    return !1
}
function xx(e, t, n) {
    t = $o(n, t),
    t = Yw(e, t, 1),
    e = ti(e, t, 1),
    t = Dt(),
    e !== null && (pa(e, 1, t),
    qt(e, t))
}
function qe(e, t, n) {
    if (e.tag === 3)
        xx(e, e, n);
    else
        for (; t !== null; ) {
            if (t.tag === 3) {
                xx(t, e, n);
                break
            }
            if (t.tag === 1) {
                var r = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (ni === null || !ni.has(r))) {
                    e = $o(n, e),
                    e = Kw(t, e, 1),
                    t = ti(t, e, 1),
                    e = Dt(),
                    t !== null && (pa(t, 1, e),
                    qt(t, e));
                    break
                }
            }
            t = t.return
        }
}
function LO(e, t, n) {
    var r = e.pingCache;
    r !== null && r.delete(t),
    t = Dt(),
    e.pingedLanes |= e.suspendedLanes & n,
    ft === e && (xt & n) === n && (st === 4 || st === 3 && (130023424 & xt) === xt && 500 > Ze() - Np ? _i(e, 0) : $p |= n),
    qt(e, t)
}
function vS(e, t) {
    t === 0 && (1 & e.mode ? (t = Dl,
    Dl <<= 1,
    !(130023424 & Dl) && (Dl = 4194304)) : t = 1);
    var n = Dt();
    e = Fr(e, t),
    e !== null && (pa(e, t, n),
    qt(e, n))
}
function VO(e) {
    var t = e.memoizedState
      , n = 0;
    t !== null && (n = t.retryLane),
    vS(e, n)
}
function AO(e, t) {
    var n = 0;
    switch (e.tag) {
    case 13:
        var r = e.stateNode
          , i = e.memoizedState;
        i !== null && (n = i.retryLane);
        break;
    case 19:
        r = e.stateNode;
        break;
    default:
        throw Error(M(314))
    }
    r !== null && r.delete(t),
    vS(e, n)
}
var yS;
yS = function(e, t, n) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Ut.current)
            Wt = !0;
        else {
            if (!(e.lanes & n) && !(128 & t.flags))
                return Wt = !1,
                kO(e, t, n);
            Wt = (131072 & e.flags) !== 0
        }
    else
        Wt = !1,
        ze && 1048576 & t.flags && xw(t, xc, t.index);
    switch (t.lanes = 0,
    t.tag) {
    case 2:
        var r = t.type;
        ic(e, t),
        e = t.pendingProps;
        var i = Ao(t, Pt.current);
        Mo(t, n),
        i = Lp(null, t, r, e, i, n);
        var o = Vp();
        return t.flags |= 1,
        typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1,
        t.memoizedState = null,
        t.updateQueue = null,
        Gt(r) ? (o = !0,
        yc(t)) : o = !1,
        t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        Pp(t),
        i.updater = zc,
        t.stateNode = i,
        i._reactInternals = t,
        Gh(t, r, e, n),
        t = Yh(null, t, r, !0, o, n)) : (t.tag = 0,
        ze && o && Sp(t),
        At(null, t, i, n),
        t = t.child),
        t;
    case 16:
        r = t.elementType;
        e: {
            switch (ic(e, t),
            e = t.pendingProps,
            i = r._init,
            r = i(r._payload),
            t.type = r,
            i = t.tag = zO(r),
            e = Ln(r, e),
            i) {
            case 0:
                t = Xh(null, t, r, e, n);
                break e;
            case 1:
                t = ux(null, t, r, e, n);
                break e;
            case 11:
                t = lx(null, t, r, e, n);
                break e;
            case 14:
                t = cx(null, t, r, Ln(r.type, e), n);
                break e
            }
            throw Error(M(306, r, ""))
        }
        return t;
    case 0:
        return r = t.type,
        i = t.pendingProps,
        i = t.elementType === r ? i : Ln(r, i),
        Xh(e, t, r, i, n);
    case 1:
        return r = t.type,
        i = t.pendingProps,
        i = t.elementType === r ? i : Ln(r, i),
        ux(e, t, r, i, n);
    case 3:
        e: {
            if (eS(t),
            e === null)
                throw Error(M(387));
            r = t.pendingProps,
            o = t.memoizedState,
            i = o.element,
            Cw(e, t),
            kc(t, r, null, n);
            var s = t.memoizedState;
            if (r = s.element,
            o.isDehydrated) {
                if (o = {
                    element: r,
                    isDehydrated: !1,
                    cache: s.cache,
                    pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                    transitions: s.transitions
                },
                t.updateQueue.baseState = o,
                t.memoizedState = o,
                256 & t.flags) {
                    i = $o(Error(M(423)), t),
                    t = fx(e, t, r, n, i);
                    break e
                }
                if (r !== i) {
                    i = $o(Error(M(424)), t),
                    t = fx(e, t, r, n, i);
                    break e
                }
                for (tn = ei(t.stateNode.containerInfo.firstChild),
                nn = t,
                ze = !0,
                An = null,
                n = Fw(t, null, r, n),
                t.child = n; n; )
                    n.flags = -3 & n.flags | 4096,
                    n = n.sibling
            } else {
                if (Do(),
                r === i) {
                    t = Pr(e, t, n);
                    break e
                }
                At(e, t, r, n)
            }
            t = t.child
        }
        return t;
    case 5:
        return Pw(t),
        e === null && Hh(t),
        r = t.type,
        i = t.pendingProps,
        o = e !== null ? e.memoizedProps : null,
        s = i.children,
        zh(r, i) ? s = null : o !== null && zh(r, o) && (t.flags |= 32),
        Jw(e, t),
        At(e, t, s, n),
        t.child;
    case 6:
        return e === null && Hh(t),
        null;
    case 13:
        return tS(e, t, n);
    case 4:
        return _p(t, t.stateNode.containerInfo),
        r = t.pendingProps,
        e === null ? t.child = zo(t, null, r, n) : At(e, t, r, n),
        t.child;
    case 11:
        return r = t.type,
        i = t.pendingProps,
        i = t.elementType === r ? i : Ln(r, i),
        lx(e, t, r, i, n);
    case 7:
        return At(e, t, t.pendingProps, n),
        t.child;
    case 8:
        return At(e, t, t.pendingProps.children, n),
        t.child;
    case 12:
        return At(e, t, t.pendingProps.children, n),
        t.child;
    case 10:
        e: {
            if (r = t.type._context,
            i = t.pendingProps,
            o = t.memoizedProps,
            s = i.value,
            Pe(wc, r._currentValue),
            r._currentValue = s,
            o !== null)
                if (Bn(o.value, s)) {
                    if (o.children === i.children && !Ut.current) {
                        t = Pr(e, t, n);
                        break e
                    }
                } else
                    for (o = t.child,
                    o !== null && (o.return = t); o !== null; ) {
                        var a = o.dependencies;
                        if (a !== null) {
                            s = o.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === r) {
                                    if (o.tag === 1) {
                                        l = Tr(-1, n & -n),
                                        l.tag = 2;
                                        var c = o.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var u = c.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            c.pending = l
                                        }
                                    }
                                    o.lanes |= n,
                                    l = o.alternate,
                                    l !== null && (l.lanes |= n),
                                    Wh(o.return, n, t),
                                    a.lanes |= n;
                                    break
                                }
                                l = l.next
                            }
                        } else if (o.tag === 10)
                            s = o.type === t.type ? null : o.child;
                        else if (o.tag === 18) {
                            if (s = o.return,
                            s === null)
                                throw Error(M(341));
                            s.lanes |= n,
                            a = s.alternate,
                            a !== null && (a.lanes |= n),
                            Wh(s, n, t),
                            s = o.sibling
                        } else
                            s = o.child;
                        if (s !== null)
                            s.return = o;
                        else
                            for (s = o; s !== null; ) {
                                if (s === t) {
                                    s = null;
                                    break
                                }
                                if (o = s.sibling,
                                o !== null) {
                                    o.return = s.return,
                                    s = o;
                                    break
                                }
                                s = s.return
                            }
                        o = s
                    }
            At(e, t, i.children, n),
            t = t.child
        }
        return t;
    case 9:
        return i = t.type,
        r = t.pendingProps.children,
        Mo(t, n),
        i = Cn(i),
        r = r(i),
        t.flags |= 1,
        At(e, t, r, n),
        t.child;
    case 14:
        return r = t.type,
        i = Ln(r, t.pendingProps),
        i = Ln(r.type, i),
        cx(e, t, r, i, n);
    case 15:
        return Qw(e, t, t.type, t.pendingProps, n);
    case 17:
        return r = t.type,
        i = t.pendingProps,
        i = t.elementType === r ? i : Ln(r, i),
        ic(e, t),
        t.tag = 1,
        Gt(r) ? (e = !0,
        yc(t)) : e = !1,
        Mo(t, n),
        Rw(t, r, i),
        Gh(t, r, i, n),
        Yh(null, t, r, !0, e, n);
    case 19:
        return nS(e, t, n);
    case 22:
        return Zw(e, t, n)
    }
    throw Error(M(156, t.tag))
}
;
function bS(e, t) {
    return Wx(e, t)
}
function DO(e, t, n, r) {
    this.tag = e,
    this.key = n,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = t,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = r,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Sn(e, t, n, r) {
    return new DO(e,t,n,r)
}
function Up(e) {
    return e = e.prototype,
    !(!e || !e.isReactComponent)
}
function zO(e) {
    if (typeof e == "function")
        return Up(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof,
        e === up)
            return 11;
        if (e === fp)
            return 14
    }
    return 2
}
function ii(e, t) {
    var n = e.alternate;
    return n === null ? (n = Sn(e.tag, t, e.key, e.mode),
    n.elementType = e.elementType,
    n.type = e.type,
    n.stateNode = e.stateNode,
    n.alternate = e,
    e.alternate = n) : (n.pendingProps = t,
    n.type = e.type,
    n.flags = 0,
    n.subtreeFlags = 0,
    n.deletions = null),
    n.flags = 14680064 & e.flags,
    n.childLanes = e.childLanes,
    n.lanes = e.lanes,
    n.child = e.child,
    n.memoizedProps = e.memoizedProps,
    n.memoizedState = e.memoizedState,
    n.updateQueue = e.updateQueue,
    t = e.dependencies,
    n.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    },
    n.sibling = e.sibling,
    n.index = e.index,
    n.ref = e.ref,
    n
}
function ac(e, t, n, r, i, o) {
    var s = 2;
    if (r = e,
    typeof e == "function")
        Up(e) && (s = 1);
    else if (typeof e == "string")
        s = 5;
    else
        e: switch (e) {
        case yo:
            return Ii(n.children, i, o, t);
        case cp:
            s = 8,
            i |= 8;
            break;
        case gh:
            return e = Sn(12, n, t, 2 | i),
            e.elementType = gh,
            e.lanes = o,
            e;
        case vh:
            return e = Sn(13, n, t, i),
            e.elementType = vh,
            e.lanes = o,
            e;
        case yh:
            return e = Sn(19, n, t, i),
            e.elementType = yh,
            e.lanes = o,
            e;
        case Ex:
            return jc(n, i, o, t);
        default:
            if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                case Tx:
                    s = 10;
                    break e;
                case Rx:
                    s = 9;
                    break e;
                case up:
                    s = 11;
                    break e;
                case fp:
                    s = 14;
                    break e;
                case Ur:
                    s = 16,
                    r = null;
                    break e
                }
            throw Error(M(130, e == null ? e : typeof e, ""))
        }
    return t = Sn(s, n, t, i),
    t.elementType = e,
    t.type = r,
    t.lanes = o,
    t
}
function Ii(e, t, n, r) {
    return e = Sn(7, e, r, t),
    e.lanes = n,
    e
}
function jc(e, t, n, r) {
    return e = Sn(22, e, r, t),
    e.elementType = Ex,
    e.lanes = n,
    e.stateNode = {
        isHidden: !1
    },
    e
}
function hh(e, t, n) {
    return e = Sn(6, e, null, t),
    e.lanes = n,
    e
}
function ph(e, t, n) {
    return t = Sn(4, e.children !== null ? e.children : [], e.key, t),
    t.lanes = n,
    t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    },
    t
}
function BO(e, t, n, r, i) {
    this.tag = t,
    this.containerInfo = e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Qd(0),
    this.expirationTimes = Qd(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Qd(0),
    this.identifierPrefix = r,
    this.onRecoverableError = i,
    this.mutableSourceEagerHydrationData = null
}
function Gp(e, t, n, r, i, o, s, a, l) {
    return e = new BO(e,t,n,a,l),
    t === 1 ? (t = 1,
    o === !0 && (t |= 8)) : t = 0,
    o = Sn(3, null, null, t),
    e.current = o,
    o.stateNode = e,
    o.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Pp(o),
    e
}
function $O(e, t, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: vo,
        key: r == null ? null : "" + r,
        children: e,
        containerInfo: t,
        implementation: n
    }
}
function xS(e) {
    if (!e)
        return si;
    e = e._reactInternals;
    e: {
        if (zi(e) !== e || e.tag !== 1)
            throw Error(M(170));
        var t = e;
        do {
            switch (t.tag) {
            case 3:
                t = t.stateNode.context;
                break e;
            case 1:
                if (Gt(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            t = t.return
        } while (t !== null);
        throw Error(M(171))
    }
    if (e.tag === 1) {
        var n = e.type;
        if (Gt(n))
            return yw(e, n, t)
    }
    return t
}
function wS(e, t, n, r, i, o, s, a, l) {
    return e = Gp(n, r, !0, e, i, o, s, a, l),
    e.context = xS(null),
    n = e.current,
    r = Dt(),
    i = ri(n),
    o = Tr(r, i),
    o.callback = t ?? null,
    ti(n, o, i),
    e.current.lanes = i,
    pa(e, i, r),
    qt(e, r),
    e
}
function Hc(e, t, n, r) {
    var i = t.current
      , o = Dt()
      , s = ri(i);
    return n = xS(n),
    t.context === null ? t.context = n : t.pendingContext = n,
    t = Tr(o, s),
    t.payload = {
        element: e
    },
    r = r === void 0 ? null : r,
    r !== null && (t.callback = r),
    e = ti(i, t, s),
    e !== null && (zn(e, i, s, o),
    tc(e, i, s)),
    s
}
function Ic(e) {
    if (e = e.current,
    !e.child)
        return null;
    switch (e.child.tag) {
    case 5:
        return e.child.stateNode;
    default:
        return e.child.stateNode
    }
}
function wx(e, t) {
    if (e = e.memoizedState,
    e !== null && e.dehydrated !== null) {
        var n = e.retryLane;
        e.retryLane = n !== 0 && n < t ? n : t
    }
}
function qp(e, t) {
    wx(e, t),
    (e = e.alternate) && wx(e, t)
}
function NO() {
    return null
}
var SS = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
}
;
function Xp(e) {
    this._internalRoot = e
}
Wc.prototype.render = Xp.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null)
        throw Error(M(409));
    Hc(e, t, null, null)
}
;
Wc.prototype.unmount = Xp.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        Ai(function() {
            Hc(null, e, null, null)
        }),
        t[Er] = null
    }
}
;
function Wc(e) {
    this._internalRoot = e
}
Wc.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = Qx();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var n = 0; n < qr.length && t !== 0 && t < qr[n].priority; n++)
            ;
        qr.splice(n, 0, e),
        n === 0 && Jx(e)
    }
}
;
function Yp(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function Uc(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function Sx() {}
function jO(e, t, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var o = r;
            r = function() {
                var c = Ic(s);
                o.call(c)
            }
        }
        var s = wS(t, r, e, 0, null, !1, !1, "", Sx);
        return e._reactRootContainer = s,
        e[Er] = s.current,
        oa(e.nodeType === 8 ? e.parentNode : e),
        Ai(),
        s
    }
    for (; i = e.lastChild; )
        e.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var c = Ic(l);
            a.call(c)
        }
    }
    var l = Gp(e, 0, !1, null, null, !1, !1, "", Sx);
    return e._reactRootContainer = l,
    e[Er] = l.current,
    oa(e.nodeType === 8 ? e.parentNode : e),
    Ai(function() {
        Hc(t, l, n, r)
    }),
    l
}
function Gc(e, t, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
        var s = o;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = Ic(s);
                a.call(l)
            }
        }
        Hc(t, s, e, i)
    } else
        s = jO(n, t, e, i, r);
    return Ic(s)
}
Yx = function(e) {
    switch (e.tag) {
    case 3:
        var t = e.stateNode;
        if (t.current.memoizedState.isDehydrated) {
            var n = $s(t.pendingLanes);
            n !== 0 && (pp(t, 1 | n),
            qt(t, Ze()),
            !(6 & ye) && (No = Ze() + 500,
            ci()))
        }
        break;
    case 13:
        Ai(function() {
            var r = Fr(e, 1);
            if (r !== null) {
                var i = Dt();
                zn(r, e, 1, i)
            }
        }),
        qp(e, 1)
    }
}
;
mp = function(e) {
    if (e.tag === 13) {
        var t = Fr(e, 134217728);
        if (t !== null) {
            var n = Dt();
            zn(t, e, 134217728, n)
        }
        qp(e, 134217728)
    }
}
;
Kx = function(e) {
    if (e.tag === 13) {
        var t = ri(e)
          , n = Fr(e, t);
        if (n !== null) {
            var r = Dt();
            zn(n, e, t, r)
        }
        qp(e, t)
    }
}
;
Qx = function() {
    return Se
}
;
Zx = function(e, t) {
    var n = Se;
    try {
        return Se = e,
        t()
    } finally {
        Se = n
    }
}
;
Fh = function(e, t, n) {
    switch (t) {
    case "input":
        if (wh(e, n),
        t = n.name,
        n.type === "radio" && t != null) {
            for (n = e; n.parentNode; )
                n = n.parentNode;
            for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
            t = 0; t < n.length; t++) {
                var r = n[t];
                if (r !== e && r.form === e.form) {
                    var i = Ac(r);
                    if (!i)
                        throw Error(M(90));
                    Px(r),
                    wh(r, i)
                }
            }
        }
        break;
    case "textarea":
        Ix(e, n);
        break;
    case "select":
        t = n.value,
        t != null && Po(e, !!n.multiple, t, !1)
    }
}
;
zx = jp;
Bx = Ai;
var HO = {
    usingClientEntryPoint: !1,
    Events: [ga, So, Ac, Ax, Dx, jp]
}
  , As = {
    findFiberByHostInstance: Ei,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , WO = {
    bundleType: As.bundleType,
    version: As.version,
    rendererPackageName: As.rendererPackageName,
    rendererConfig: As.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: _r.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(e) {
        return e = jx(e),
        e === null ? null : e.stateNode
    },
    findFiberByHostInstance: As.findFiberByHostInstance || NO,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Ds = __REACT_DEVTOOLS_GLOBAL_HOOK__,
!Ds.isDisabled && Ds.supportsFiber))
    try {
        Oc = Ds.inject(WO),
        rr = Ds
    } catch {}
var Ds;
on.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = HO;
on.createPortal = function(e, t) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Yp(t))
        throw Error(M(200));
    return $O(e, t, null, n)
}
;
on.createRoot = function(e, t) {
    if (!Yp(e))
        throw Error(M(299));
    var n = !1
      , r = ""
      , i = SS;
    return t != null && (t.unstable_strictMode === !0 && (n = !0),
    t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    t = Gp(e, 1, !1, null, null, n, !1, r, i),
    e[Er] = t.current,
    oa(e.nodeType === 8 ? e.parentNode : e),
    new Xp(t)
}
;
on.findDOMNode = function(e) {
    if (e == null)
        return null;
    if (e.nodeType === 1)
        return e;
    var t = e._reactInternals;
    if (t === void 0)
        throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","),
        Error(M(268, e)));
    return e = jx(t),
    e = e === null ? null : e.stateNode,
    e
}
;
on.flushSync = function(e) {
    return Ai(e)
}
;
on.hydrate = function(e, t, n) {
    if (!Uc(t))
        throw Error(M(200));
    return Gc(null, e, t, !0, n)
}
;
on.hydrateRoot = function(e, t, n) {
    if (!Yp(e))
        throw Error(M(405));
    var r = n != null && n.hydratedSources || null
      , i = !1
      , o = ""
      , s = SS;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0),
    n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
    n.onRecoverableError !== void 0 && (s = n.onRecoverableError)),
    t = wS(t, null, e, 1, n ?? null, i, !1, o, s),
    e[Er] = t.current,
    oa(e),
    r)
        for (e = 0; e < r.length; e++)
            n = r[e],
            i = n._getVersion,
            i = i(n._source),
            t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
    return new Wc(t)
}
;
on.render = function(e, t, n) {
    if (!Uc(t))
        throw Error(M(200));
    return Gc(null, e, t, !1, n)
}
;
on.unmountComponentAtNode = function(e) {
    if (!Uc(e))
        throw Error(M(40));
    return !!e._reactRootContainer && (Ai(function() {
        Gc(null, null, e, !1, function() {
            e._reactRootContainer = null,
            e[Er] = null
        })
    }),
    !0)
}
;
on.unstable_batchedUpdates = jp;
on.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
    if (!Uc(n))
        throw Error(M(200));
    if (e == null || e._reactInternals === void 0)
        throw Error(M(38));
    return Gc(e, t, n, !1, r)
}
;
on.version = "18.2.0-next-9e3b772b8-20220608";
function kS() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function")
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(kS)
        } catch (e) {
            console.error(e)
        }
}
kS();
var an = on
  , CS = an
  , UO = an.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , GO = an.createPortal
  , qO = an.createRoot
  , XO = an.findDOMNode
  , YO = an.flushSync
  , KO = an.hydrate
  , QO = an.hydrateRoot
  , ZO = an.render
  , JO = an.unmountComponentAtNode
  , eM = an.unstable_batchedUpdates
  , tM = an.unstable_renderSubtreeIntoContainer
  , nM = an.version;
var iM = pn({
    "../../../node_modules/hsluv/dist/hsluv.cjs"(e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Hsluv = void 0;
        var t = class {
            constructor() {
                this.hex = "#000000",
                this.rgb_r = 0,
                this.rgb_g = 0,
                this.rgb_b = 0,
                this.xyz_x = 0,
                this.xyz_y = 0,
                this.xyz_z = 0,
                this.luv_l = 0,
                this.luv_u = 0,
                this.luv_v = 0,
                this.lch_l = 0,
                this.lch_c = 0,
                this.lch_h = 0,
                this.hsluv_h = 0,
                this.hsluv_s = 0,
                this.hsluv_l = 0,
                this.hpluv_h = 0,
                this.hpluv_p = 0,
                this.hpluv_l = 0,
                this.r0s = 0,
                this.r0i = 0,
                this.r1s = 0,
                this.r1i = 0,
                this.g0s = 0,
                this.g0i = 0,
                this.g1s = 0,
                this.g1i = 0,
                this.b0s = 0,
                this.b0i = 0,
                this.b1s = 0,
                this.b1i = 0
            }
            static fromLinear(n) {
                return n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055
            }
            static toLinear(n) {
                return n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92
            }
            static yToL(n) {
                return n <= t.epsilon ? n / t.refY * t.kappa : 116 * Math.pow(n / t.refY, 1 / 3) - 16
            }
            static lToY(n) {
                return n <= 8 ? t.refY * n / t.kappa : t.refY * Math.pow((n + 16) / 116, 3)
            }
            static rgbChannelToHex(n) {
                let r = Math.round(n * 255)
                  , i = r % 16
                  , o = (r - i) / 16 | 0;
                return t.hexChars.charAt(o) + t.hexChars.charAt(i)
            }
            static hexToRgbChannel(n, r) {
                let i = t.hexChars.indexOf(n.charAt(r))
                  , o = t.hexChars.indexOf(n.charAt(r + 1));
                return (i * 16 + o) / 255
            }
            static distanceFromOriginAngle(n, r, i) {
                let o = r / (Math.sin(i) - n * Math.cos(i));
                return o < 0 ? 1 / 0 : o
            }
            static distanceFromOrigin(n, r) {
                return Math.abs(r) / Math.sqrt(Math.pow(n, 2) + 1)
            }
            static min6(n, r, i, o, s, a) {
                return Math.min(n, Math.min(r, Math.min(i, Math.min(o, Math.min(s, a)))))
            }
            rgbToHex() {
                this.hex = "#",
                this.hex += t.rgbChannelToHex(this.rgb_r),
                this.hex += t.rgbChannelToHex(this.rgb_g),
                this.hex += t.rgbChannelToHex(this.rgb_b)
            }
            hexToRgb() {
                this.hex = this.hex.toLowerCase(),
                this.rgb_r = t.hexToRgbChannel(this.hex, 1),
                this.rgb_g = t.hexToRgbChannel(this.hex, 3),
                this.rgb_b = t.hexToRgbChannel(this.hex, 5)
            }
            xyzToRgb() {
                this.rgb_r = t.fromLinear(t.m_r0 * this.xyz_x + t.m_r1 * this.xyz_y + t.m_r2 * this.xyz_z),
                this.rgb_g = t.fromLinear(t.m_g0 * this.xyz_x + t.m_g1 * this.xyz_y + t.m_g2 * this.xyz_z),
                this.rgb_b = t.fromLinear(t.m_b0 * this.xyz_x + t.m_b1 * this.xyz_y + t.m_b2 * this.xyz_z)
            }
            rgbToXyz() {
                let n = t.toLinear(this.rgb_r)
                  , r = t.toLinear(this.rgb_g)
                  , i = t.toLinear(this.rgb_b);
                this.xyz_x = .41239079926595 * n + .35758433938387 * r + .18048078840183 * i,
                this.xyz_y = .21263900587151 * n + .71516867876775 * r + .072192315360733 * i,
                this.xyz_z = .019330818715591 * n + .11919477979462 * r + .95053215224966 * i
            }
            xyzToLuv() {
                let n = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z
                  , r = 4 * this.xyz_x
                  , i = 9 * this.xyz_y;
                n !== 0 ? (r /= n,
                i /= n) : (r = NaN,
                i = NaN),
                this.luv_l = t.yToL(this.xyz_y),
                this.luv_l === 0 ? (this.luv_u = 0,
                this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (r - t.refU),
                this.luv_v = 13 * this.luv_l * (i - t.refV))
            }
            luvToXyz() {
                if (this.luv_l === 0) {
                    this.xyz_x = 0,
                    this.xyz_y = 0,
                    this.xyz_z = 0;
                    return
                }
                let n = this.luv_u / (13 * this.luv_l) + t.refU
                  , r = this.luv_v / (13 * this.luv_l) + t.refV;
                this.xyz_y = t.lToY(this.luv_l),
                this.xyz_x = 0 - 9 * this.xyz_y * n / ((n - 4) * r - n * r),
                this.xyz_z = (9 * this.xyz_y - 15 * r * this.xyz_y - r * this.xyz_x) / (3 * r)
            }
            luvToLch() {
                if (this.lch_l = this.luv_l,
                this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v),
                this.lch_c < 1e-8)
                    this.lch_h = 0;
                else {
                    let n = Math.atan2(this.luv_v, this.luv_u);
                    this.lch_h = n * 180 / Math.PI,
                    this.lch_h < 0 && (this.lch_h = 360 + this.lch_h)
                }
            }
            lchToLuv() {
                let n = this.lch_h / 180 * Math.PI;
                this.luv_l = this.lch_l,
                this.luv_u = Math.cos(n) * this.lch_c,
                this.luv_v = Math.sin(n) * this.lch_c
            }
            calculateBoundingLines(n) {
                let r = Math.pow(n + 16, 3) / 1560896
                  , i = r > t.epsilon ? r : n / t.kappa
                  , o = i * (284517 * t.m_r0 - 94839 * t.m_r2)
                  , s = i * (838422 * t.m_r2 + 769860 * t.m_r1 + 731718 * t.m_r0)
                  , a = i * (632260 * t.m_r2 - 126452 * t.m_r1)
                  , l = i * (284517 * t.m_g0 - 94839 * t.m_g2)
                  , c = i * (838422 * t.m_g2 + 769860 * t.m_g1 + 731718 * t.m_g0)
                  , u = i * (632260 * t.m_g2 - 126452 * t.m_g1)
                  , f = i * (284517 * t.m_b0 - 94839 * t.m_b2)
                  , d = i * (838422 * t.m_b2 + 769860 * t.m_b1 + 731718 * t.m_b0)
                  , p = i * (632260 * t.m_b2 - 126452 * t.m_b1);
                this.r0s = o / a,
                this.r0i = s * n / a,
                this.r1s = o / (a + 126452),
                this.r1i = (s - 769860) * n / (a + 126452),
                this.g0s = l / u,
                this.g0i = c * n / u,
                this.g1s = l / (u + 126452),
                this.g1i = (c - 769860) * n / (u + 126452),
                this.b0s = f / p,
                this.b0i = d * n / p,
                this.b1s = f / (p + 126452),
                this.b1i = (d - 769860) * n / (p + 126452)
            }
            calcMaxChromaHpluv() {
                let n = t.distanceFromOrigin(this.r0s, this.r0i)
                  , r = t.distanceFromOrigin(this.r1s, this.r1i)
                  , i = t.distanceFromOrigin(this.g0s, this.g0i)
                  , o = t.distanceFromOrigin(this.g1s, this.g1i)
                  , s = t.distanceFromOrigin(this.b0s, this.b0i)
                  , a = t.distanceFromOrigin(this.b1s, this.b1i);
                return t.min6(n, r, i, o, s, a)
            }
            calcMaxChromaHsluv(n) {
                let r = n / 360 * Math.PI * 2
                  , i = t.distanceFromOriginAngle(this.r0s, this.r0i, r)
                  , o = t.distanceFromOriginAngle(this.r1s, this.r1i, r)
                  , s = t.distanceFromOriginAngle(this.g0s, this.g0i, r)
                  , a = t.distanceFromOriginAngle(this.g1s, this.g1i, r)
                  , l = t.distanceFromOriginAngle(this.b0s, this.b0i, r)
                  , c = t.distanceFromOriginAngle(this.b1s, this.b1i, r);
                return t.min6(i, o, s, a, l, c)
            }
            hsluvToLch() {
                if (this.hsluv_l > 99.9999999)
                    this.lch_l = 100,
                    this.lch_c = 0;
                else if (this.hsluv_l < 1e-8)
                    this.lch_l = 0,
                    this.lch_c = 0;
                else {
                    this.lch_l = this.hsluv_l,
                    this.calculateBoundingLines(this.hsluv_l);
                    let n = this.calcMaxChromaHsluv(this.hsluv_h);
                    this.lch_c = n / 100 * this.hsluv_s
                }
                this.lch_h = this.hsluv_h
            }
            lchToHsluv() {
                if (this.lch_l > 99.9999999)
                    this.hsluv_s = 0,
                    this.hsluv_l = 100;
                else if (this.lch_l < 1e-8)
                    this.hsluv_s = 0,
                    this.hsluv_l = 0;
                else {
                    this.calculateBoundingLines(this.lch_l);
                    let n = this.calcMaxChromaHsluv(this.lch_h);
                    this.hsluv_s = this.lch_c / n * 100,
                    this.hsluv_l = this.lch_l
                }
                this.hsluv_h = this.lch_h
            }
            hpluvToLch() {
                if (this.hpluv_l > 99.9999999)
                    this.lch_l = 100,
                    this.lch_c = 0;
                else if (this.hpluv_l < 1e-8)
                    this.lch_l = 0,
                    this.lch_c = 0;
                else {
                    this.lch_l = this.hpluv_l,
                    this.calculateBoundingLines(this.hpluv_l);
                    let n = this.calcMaxChromaHpluv();
                    this.lch_c = n / 100 * this.hpluv_p
                }
                this.lch_h = this.hpluv_h
            }
            lchToHpluv() {
                if (this.lch_l > 99.9999999)
                    this.hpluv_p = 0,
                    this.hpluv_l = 100;
                else if (this.lch_l < 1e-8)
                    this.hpluv_p = 0,
                    this.hpluv_l = 0;
                else {
                    this.calculateBoundingLines(this.lch_l);
                    let n = this.calcMaxChromaHpluv();
                    this.hpluv_p = this.lch_c / n * 100,
                    this.hpluv_l = this.lch_l
                }
                this.hpluv_h = this.lch_h
            }
            hsluvToRgb() {
                this.hsluvToLch(),
                this.lchToLuv(),
                this.luvToXyz(),
                this.xyzToRgb()
            }
            hpluvToRgb() {
                this.hpluvToLch(),
                this.lchToLuv(),
                this.luvToXyz(),
                this.xyzToRgb()
            }
            hsluvToHex() {
                this.hsluvToRgb(),
                this.rgbToHex()
            }
            hpluvToHex() {
                this.hpluvToRgb(),
                this.rgbToHex()
            }
            rgbToHsluv() {
                this.rgbToXyz(),
                this.xyzToLuv(),
                this.luvToLch(),
                this.lchToHpluv(),
                this.lchToHsluv()
            }
            rgbToHpluv() {
                this.rgbToXyz(),
                this.xyzToLuv(),
                this.luvToLch(),
                this.lchToHpluv(),
                this.lchToHpluv()
            }
            hexToHsluv() {
                this.hexToRgb(),
                this.rgbToHsluv()
            }
            hexToHpluv() {
                this.hexToRgb(),
                this.rgbToHpluv()
            }
        }
        ;
        e.Hsluv = t,
        t.hexChars = "0123456789abcdef",
        t.refY = 1,
        t.refU = .19783000664283,
        t.refV = .46831999493879,
        t.kappa = 903.2962962,
        t.epsilon = .0088564516,
        t.m_r0 = 3.240969941904521,
        t.m_r1 = -1.537383177570093,
        t.m_r2 = -.498610760293,
        t.m_g0 = -.96924363628087,
        t.m_g1 = 1.87596750150772,
        t.m_g2 = .041555057407175,
        t.m_b0 = .055630079696993,
        t.m_b1 = -.20397695888897,
        t.m_b2 = 1.056971514242878
    }
})
  , oM = pn({
    "../../../node_modules/eventemitter3/index.js"(e, t) {
        "use strict";
        var n = Object.prototype.hasOwnProperty
          , r = "~";
        function i() {}
        Object.create && (i.prototype = Object.create(null),
        new i().__proto__ || (r = !1));
        function o(c, u, f) {
            this.fn = c,
            this.context = u,
            this.once = f || !1
        }
        function s(c, u, f, d, p) {
            if (typeof f != "function")
                throw new TypeError("The listener must be a function");
            var v = new o(f,d || c,p)
              , g = r ? r + u : u;
            return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], v] : c._events[g].push(v) : (c._events[g] = v,
            c._eventsCount++),
            c
        }
        function a(c, u) {
            --c._eventsCount === 0 ? c._events = new i : delete c._events[u]
        }
        function l() {
            this._events = new i,
            this._eventsCount = 0
        }
        l.prototype.eventNames = function() {
            var u = [], f, d;
            if (this._eventsCount === 0)
                return u;
            for (d in f = this._events)
                n.call(f, d) && u.push(r ? d.slice(1) : d);
            return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u
        }
        ,
        l.prototype.listeners = function(u) {
            var f = r ? r + u : u
              , d = this._events[f];
            if (!d)
                return [];
            if (d.fn)
                return [d.fn];
            for (var p = 0, v = d.length, g = new Array(v); p < v; p++)
                g[p] = d[p].fn;
            return g
        }
        ,
        l.prototype.listenerCount = function(u) {
            var f = r ? r + u : u
              , d = this._events[f];
            return d ? d.fn ? 1 : d.length : 0
        }
        ,
        l.prototype.emit = function(u, f, d, p, v, g) {
            var b = r ? r + u : u;
            if (!this._events[b])
                return !1;
            var m = this._events[b], h = arguments.length, y, w;
            if (m.fn) {
                switch (m.once && this.removeListener(u, m.fn, void 0, !0),
                h) {
                case 1:
                    return m.fn.call(m.context),
                    !0;
                case 2:
                    return m.fn.call(m.context, f),
                    !0;
                case 3:
                    return m.fn.call(m.context, f, d),
                    !0;
                case 4:
                    return m.fn.call(m.context, f, d, p),
                    !0;
                case 5:
                    return m.fn.call(m.context, f, d, p, v),
                    !0;
                case 6:
                    return m.fn.call(m.context, f, d, p, v, g),
                    !0
                }
                for (w = 1,
                y = new Array(h - 1); w < h; w++)
                    y[w - 1] = arguments[w];
                m.fn.apply(m.context, y)
            } else {
                var C = m.length, S;
                for (w = 0; w < C; w++)
                    switch (m[w].once && this.removeListener(u, m[w].fn, void 0, !0),
                    h) {
                    case 1:
                        m[w].fn.call(m[w].context);
                        break;
                    case 2:
                        m[w].fn.call(m[w].context, f);
                        break;
                    case 3:
                        m[w].fn.call(m[w].context, f, d);
                        break;
                    case 4:
                        m[w].fn.call(m[w].context, f, d, p);
                        break;
                    default:
                        if (!y)
                            for (S = 1,
                            y = new Array(h - 1); S < h; S++)
                                y[S - 1] = arguments[S];
                        m[w].fn.apply(m[w].context, y)
                    }
            }
            return !0
        }
        ,
        l.prototype.on = function(u, f, d) {
            return s(this, u, f, d, !1)
        }
        ,
        l.prototype.once = function(u, f, d) {
            return s(this, u, f, d, !0)
        }
        ,
        l.prototype.removeListener = function(u, f, d, p) {
            var v = r ? r + u : u;
            if (!this._events[v])
                return this;
            if (!f)
                return a(this, v),
                this;
            var g = this._events[v];
            if (g.fn)
                g.fn === f && (!p || g.once) && (!d || g.context === d) && a(this, v);
            else {
                for (var b = 0, m = [], h = g.length; b < h; b++)
                    (g[b].fn !== f || p && !g[b].once || d && g[b].context !== d) && m.push(g[b]);
                m.length ? this._events[v] = m.length === 1 ? m[0] : m : a(this, v)
            }
            return this
        }
        ,
        l.prototype.removeAllListeners = function(u) {
            var f;
            return u ? (f = r ? r + u : u,
            this._events[f] && a(this, f)) : (this._events = new i,
            this._eventsCount = 0),
            this
        }
        ,
        l.prototype.off = l.prototype.removeListener,
        l.prototype.addListener = l.prototype.on,
        l.prefixed = r,
        l.EventEmitter = l,
        typeof t < "u" && (t.exports = l)
    }
})
  , Bm = pn({
    "../../../node_modules/process/browser.js"(e, t) {
        var n = t.exports = {}, r, i;
        function o() {
            throw new Error("setTimeout has not been defined")
        }
        function s() {
            throw new Error("clearTimeout has not been defined")
        }
        (function() {
            try {
                typeof setTimeout == "function" ? r = setTimeout : r = o
            } catch {
                r = o
            }
            try {
                typeof clearTimeout == "function" ? i = clearTimeout : i = s
            } catch {
                i = s
            }
        }
        )();
        function a(m) {
            if (r === setTimeout)
                return setTimeout(m, 0);
            if ((r === o || !r) && setTimeout)
                return r = setTimeout,
                setTimeout(m, 0);
            try {
                return r(m, 0)
            } catch {
                try {
                    return r.call(null, m, 0)
                } catch {
                    return r.call(this, m, 0)
                }
            }
        }
        function l(m) {
            if (i === clearTimeout)
                return clearTimeout(m);
            if ((i === s || !i) && clearTimeout)
                return i = clearTimeout,
                clearTimeout(m);
            try {
                return i(m)
            } catch {
                try {
                    return i.call(null, m)
                } catch {
                    return i.call(this, m)
                }
            }
        }
        var c = [], u = !1, f, d = -1;
        function p() {
            !u || !f || (u = !1,
            f.length ? c = f.concat(c) : d = -1,
            c.length && v())
        }
        function v() {
            if (!u) {
                var m = a(p);
                u = !0;
                for (var h = c.length; h; ) {
                    for (f = c,
                    c = []; ++d < h; )
                        f && f[d].run();
                    d = -1,
                    h = c.length
                }
                f = null,
                u = !1,
                l(m)
            }
        }
        n.nextTick = function(m) {
            var h = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var y = 1; y < arguments.length; y++)
                    h[y - 1] = arguments[y];
            c.push(new g(m,h)),
            c.length === 1 && !u && a(v)
        }
        ;
        function g(m, h) {
            this.fun = m,
            this.array = h
        }
        g.prototype.run = function() {
            this.fun.apply(null, this.array)
        }
        ,
        n.title = "browser",
        n.browser = !0,
        n.env = {},
        n.argv = [],
        n.version = "",
        n.versions = {};
        function b() {}
        n.on = b,
        n.addListener = b,
        n.once = b,
        n.off = b,
        n.removeListener = b,
        n.removeAllListeners = b,
        n.emit = b,
        n.prependListener = b,
        n.prependOnceListener = b,
        n.listeners = function(m) {
            return []
        }
        ,
        n.binding = function(m) {
            throw new Error("process.binding is not supported")
        }
        ,
        n.cwd = function() {
            return "/"
        }
        ,
        n.chdir = function(m) {
            throw new Error("process.chdir is not supported")
        }
        ,
        n.umask = function() {
            return 0
        }
    }
})
  , sM = pn({
    "../../../node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js"(e, t) {
        (function(n, r) {
            typeof e == "object" && typeof t < "u" ? r(e) : typeof define == "function" && define.amd ? define(["exports"], r) : (n = typeof globalThis < "u" ? globalThis : n || self,
            r(n.ResizeObserver = {}))
        }
        )(e, function(n) {
            "use strict";
            var r = [], i = function() {
                return r.some(function(F) {
                    return F.activeTargets.length > 0
                })
            }, o = function() {
                return r.some(function(F) {
                    return F.skippedTargets.length > 0
                })
            }, s = "ResizeObserver loop completed with undelivered notifications.", a = function() {
                var F;
                typeof ErrorEvent == "function" ? F = new ErrorEvent("error",{
                    message: s
                }) : (F = document.createEvent("Event"),
                F.initEvent("error", !1, !1),
                F.message = s),
                P.dispatchEvent(F)
            }, l;
            (function(F) {
                F.BORDER_BOX = "border-box",
                F.CONTENT_BOX = "content-box",
                F.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box"
            }
            )(l || (l = {}));
            var c = function(F) {
                return Object.freeze(F)
            }, u = function() {
                function F(_, L) {
                    this.inlineSize = _,
                    this.blockSize = L,
                    c(this)
                }
                return F
            }(), f = function() {
                function F(_, L, G, ge) {
                    return this.x = _,
                    this.y = L,
                    this.width = G,
                    this.height = ge,
                    this.top = this.y,
                    this.left = this.x,
                    this.bottom = this.top + this.height,
                    this.right = this.left + this.width,
                    c(this)
                }
                return F.prototype.toJSON = function() {
                    var _ = this
                      , L = _.x
                      , G = _.y
                      , ge = _.top
                      , _t = _.right
                      , gt = _.bottom
                      , Qe = _.left
                      , dr = _.width
                      , Kt = _.height;
                    return {
                        x: L,
                        y: G,
                        top: ge,
                        right: _t,
                        bottom: gt,
                        left: Qe,
                        width: dr,
                        height: Kt
                    }
                }
                ,
                F.fromRect = function(_) {
                    return new F(_.x,_.y,_.width,_.height)
                }
                ,
                F
            }(), d = function(F) {
                return F instanceof SVGElement && "getBBox"in F
            }, p = function(F) {
                if (d(F)) {
                    var _ = F.getBBox()
                      , L = _.width
                      , G = _.height;
                    return !L && !G
                }
                var ge = F
                  , _t = ge.offsetWidth
                  , gt = ge.offsetHeight;
                return !(_t || gt || F.getClientRects().length)
            }, v = function(F) {
                var _, L;
                if (F instanceof Element)
                    return !0;
                var G = (L = (_ = F) === null || _ === void 0 ? void 0 : _.ownerDocument) === null || L === void 0 ? void 0 : L.defaultView;
                return !!(G && F instanceof G.Element)
            }, g = function(F) {
                switch (F.tagName) {
                case "INPUT":
                    if (F.type !== "image")
                        break;
                case "VIDEO":
                case "AUDIO":
                case "EMBED":
                case "OBJECT":
                case "CANVAS":
                case "IFRAME":
                case "IMG":
                    return !0
                }
                return !1
            }, b = typeof P < "u" ? P : {}, m = new WeakMap, h = /auto|scroll/, y = /^tb|vertical/, w = /msie|trident/i.test(b.navigator && b.navigator.userAgent), C = function(F) {
                return parseFloat(F || "0")
            }, S = function(F, _, L) {
                return F === void 0 && (F = 0),
                _ === void 0 && (_ = 0),
                L === void 0 && (L = !1),
                new u((L ? _ : F) || 0,(L ? F : _) || 0)
            }, T = c({
                devicePixelContentBoxSize: S(),
                borderBoxSize: S(),
                contentBoxSize: S(),
                contentRect: new f(0,0,0,0)
            }), E = function(F, _) {
                if (_ === void 0 && (_ = !1),
                m.has(F) && !_)
                    return m.get(F);
                if (p(F))
                    return m.set(F, T),
                    T;
                var L = getComputedStyle(F)
                  , G = d(F) && F.ownerSVGElement && F.getBBox()
                  , ge = !w && L.boxSizing === "border-box"
                  , _t = y.test(L.writingMode || "")
                  , gt = !G && h.test(L.overflowY || "")
                  , Qe = !G && h.test(L.overflowX || "")
                  , dr = G ? 0 : C(L.paddingTop)
                  , Kt = G ? 0 : C(L.paddingRight)
                  , mi = G ? 0 : C(L.paddingBottom)
                  , Qi = G ? 0 : C(L.paddingLeft)
                  , OT = G ? 0 : C(L.borderTopWidth)
                  , MT = G ? 0 : C(L.borderRightWidth)
                  , LT = G ? 0 : C(L.borderBottomWidth)
                  , VT = G ? 0 : C(L.borderLeftWidth)
                  , gg = Qi + Kt
                  , vg = dr + mi
                  , Xu = VT + MT
                  , Yu = OT + LT
                  , yg = Qe ? F.offsetHeight - Yu - F.clientHeight : 0
                  , bg = gt ? F.offsetWidth - Xu - F.clientWidth : 0
                  , AT = ge ? gg + Xu : 0
                  , DT = ge ? vg + Yu : 0
                  , ja = G ? G.width : C(L.width) - AT - bg
                  , Ha = G ? G.height : C(L.height) - DT - yg
                  , zT = ja + gg + bg + Xu
                  , BT = Ha + vg + yg + Yu
                  , xg = c({
                    devicePixelContentBoxSize: S(Math.round(ja * devicePixelRatio), Math.round(Ha * devicePixelRatio), _t),
                    borderBoxSize: S(zT, BT, _t),
                    contentBoxSize: S(ja, Ha, _t),
                    contentRect: new f(Qi,dr,ja,Ha)
                });
                return m.set(F, xg),
                xg
            }, I = function(F, _, L) {
                var G = E(F, L)
                  , ge = G.borderBoxSize
                  , _t = G.contentBoxSize
                  , gt = G.devicePixelContentBoxSize;
                switch (_) {
                case l.DEVICE_PIXEL_CONTENT_BOX:
                    return gt;
                case l.BORDER_BOX:
                    return ge;
                default:
                    return _t
                }
            }, O = function() {
                function F(_) {
                    var L = E(_);
                    this.target = _,
                    this.contentRect = L.contentRect,
                    this.borderBoxSize = c([L.borderBoxSize]),
                    this.contentBoxSize = c([L.contentBoxSize]),
                    this.devicePixelContentBoxSize = c([L.devicePixelContentBoxSize])
                }
                return F
            }(), B = function(F) {
                if (p(F))
                    return 1 / 0;
                for (var _ = 0, L = F.parentNode; L; )
                    _ += 1,
                    L = L.parentNode;
                return _
            }, z = function() {
                var F = 1 / 0
                  , _ = [];
                r.forEach(function(gt) {
                    if (gt.activeTargets.length !== 0) {
                        var Qe = [];
                        gt.activeTargets.forEach(function(Kt) {
                            var mi = new O(Kt.target)
                              , Qi = B(Kt.target);
                            Qe.push(mi),
                            Kt.lastReportedSize = I(Kt.target, Kt.observedBox),
                            Qi < F && (F = Qi)
                        }),
                        _.push(function() {
                            gt.callback.call(gt.observer, Qe, gt.observer)
                        }),
                        gt.activeTargets.splice(0, gt.activeTargets.length)
                    }
                });
                for (var L = 0, G = _; L < G.length; L++) {
                    var ge = G[L];
                    ge()
                }
                return F
            }, j = function(F) {
                r.forEach(function(L) {
                    L.activeTargets.splice(0, L.activeTargets.length),
                    L.skippedTargets.splice(0, L.skippedTargets.length),
                    L.observationTargets.forEach(function(ge) {
                        ge.isActive() && (B(ge.target) > F ? L.activeTargets.push(ge) : L.skippedTargets.push(ge))
                    })
                })
            }, J = function() {
                var F = 0;
                for (j(F); i(); )
                    F = z(),
                    j(F);
                return o() && a(),
                F > 0
            }, H, fe = [], ie = function() {
                return fe.splice(0).forEach(function(F) {
                    return F()
                })
            }, q = function(F) {
                if (!H) {
                    var _ = 0
                      , L = document.createTextNode("")
                      , G = {
                        characterData: !0
                    };
                    new MutationObserver(function() {
                        return ie()
                    }
                    ).observe(L, G),
                    H = function() {
                        L.textContent = "" + (_ ? _-- : _++)
                    }
                }
                fe.push(F),
                H()
            }, re = function(F) {
                q(function() {
                    requestAnimationFrame(F)
                })
            }, U = 0, pe = function() {
                return !!U
            }, me = 250, ae = {
                attributes: !0,
                characterData: !0,
                childList: !0,
                subtree: !0
            }, X = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], Ye = function(F) {
                return F === void 0 && (F = 0),
                Date.now() + F
            }, Ce = !1, Ke = function() {
                function F() {
                    var _ = this;
                    this.stopped = !0,
                    this.listener = function() {
                        return _.schedule()
                    }
                }
                return F.prototype.run = function(_) {
                    var L = this;
                    if (_ === void 0 && (_ = me),
                    !Ce) {
                        Ce = !0;
                        var G = Ye(_);
                        re(function() {
                            var ge = !1;
                            try {
                                ge = J()
                            } finally {
                                if (Ce = !1,
                                _ = G - Ye(),
                                !pe())
                                    return;
                                ge ? L.run(1e3) : _ > 0 ? L.run(_) : L.start()
                            }
                        })
                    }
                }
                ,
                F.prototype.schedule = function() {
                    this.stop(),
                    this.run()
                }
                ,
                F.prototype.observe = function() {
                    var _ = this
                      , L = function() {
                        return _.observer && _.observer.observe(document.body, ae)
                    };
                    document.body ? L() : b.addEventListener("DOMContentLoaded", L)
                }
                ,
                F.prototype.start = function() {
                    var _ = this;
                    this.stopped && (this.stopped = !1,
                    this.observer = new MutationObserver(this.listener),
                    this.observe(),
                    X.forEach(function(L) {
                        return b.addEventListener(L, _.listener, !0)
                    }))
                }
                ,
                F.prototype.stop = function() {
                    var _ = this;
                    this.stopped || (this.observer && this.observer.disconnect(),
                    X.forEach(function(L) {
                        return b.removeEventListener(L, _.listener, !0)
                    }),
                    this.stopped = !0)
                }
                ,
                F
            }(), Ee = new Ke, dn = function(F) {
                !U && F > 0 && Ee.start(),
                U += F,
                !U && Ee.stop()
            }, St = function(F) {
                return !d(F) && !g(F) && getComputedStyle(F).display === "inline"
            }, Hn = function() {
                function F(_, L) {
                    this.target = _,
                    this.observedBox = L || l.CONTENT_BOX,
                    this.lastReportedSize = {
                        inlineSize: 0,
                        blockSize: 0
                    }
                }
                return F.prototype.isActive = function() {
                    var _ = I(this.target, this.observedBox, !0);
                    return St(this.target) && (this.lastReportedSize = _),
                    this.lastReportedSize.inlineSize !== _.inlineSize || this.lastReportedSize.blockSize !== _.blockSize
                }
                ,
                F
            }(), ce = function() {
                function F(_, L) {
                    this.activeTargets = [],
                    this.skippedTargets = [],
                    this.observationTargets = [],
                    this.observer = _,
                    this.callback = L
                }
                return F
            }(), Yt = new WeakMap, lt = function(F, _) {
                for (var L = 0; L < F.length; L += 1)
                    if (F[L].target === _)
                        return L;
                return -1
            }, hn = function() {
                function F() {}
                return F.connect = function(_, L) {
                    var G = new ce(_,L);
                    Yt.set(_, G)
                }
                ,
                F.observe = function(_, L, G) {
                    var ge = Yt.get(_)
                      , _t = ge.observationTargets.length === 0;
                    lt(ge.observationTargets, L) < 0 && (_t && r.push(ge),
                    ge.observationTargets.push(new Hn(L,G && G.box)),
                    dn(1),
                    Ee.schedule())
                }
                ,
                F.unobserve = function(_, L) {
                    var G = Yt.get(_)
                      , ge = lt(G.observationTargets, L)
                      , _t = G.observationTargets.length === 1;
                    ge >= 0 && (_t && r.splice(r.indexOf(G), 1),
                    G.observationTargets.splice(ge, 1),
                    dn(-1))
                }
                ,
                F.disconnect = function(_) {
                    var L = this
                      , G = Yt.get(_);
                    G.observationTargets.slice().forEach(function(ge) {
                        return L.unobserve(_, ge.target)
                    }),
                    G.activeTargets.splice(0, G.activeTargets.length)
                }
                ,
                F
            }(), Na = function() {
                function F(_) {
                    if (arguments.length === 0)
                        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
                    if (typeof _ != "function")
                        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
                    hn.connect(this, _)
                }
                return F.prototype.observe = function(_, L) {
                    if (arguments.length === 0)
                        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
                    if (!v(_))
                        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
                    hn.observe(this, _, L)
                }
                ,
                F.prototype.unobserve = function(_) {
                    if (arguments.length === 0)
                        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
                    if (!v(_))
                        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
                    hn.unobserve(this, _)
                }
                ,
                F.prototype.disconnect = function() {
                    hn.disconnect(this)
                }
                ,
                F.toString = function() {
                    return "function ResizeObserver () { [polyfill code] }"
                }
                ,
                F
            }();
            n.ResizeObserver = Na,
            n.ResizeObserverEntry = O,
            n.ResizeObserverSize = u,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }
})
  , aM = pn({
    "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) {
        "use strict";
        var t = typeof Symbol == "function" && Symbol.for
          , n = t ? Symbol.for("react.element") : 60103
          , r = t ? Symbol.for("react.portal") : 60106
          , i = t ? Symbol.for("react.fragment") : 60107
          , o = t ? Symbol.for("react.strict_mode") : 60108
          , s = t ? Symbol.for("react.profiler") : 60114
          , a = t ? Symbol.for("react.provider") : 60109
          , l = t ? Symbol.for("react.context") : 60110
          , c = t ? Symbol.for("react.async_mode") : 60111
          , u = t ? Symbol.for("react.concurrent_mode") : 60111
          , f = t ? Symbol.for("react.forward_ref") : 60112
          , d = t ? Symbol.for("react.suspense") : 60113
          , p = t ? Symbol.for("react.suspense_list") : 60120
          , v = t ? Symbol.for("react.memo") : 60115
          , g = t ? Symbol.for("react.lazy") : 60116
          , b = t ? Symbol.for("react.block") : 60121
          , m = t ? Symbol.for("react.fundamental") : 60117
          , h = t ? Symbol.for("react.responder") : 60118
          , y = t ? Symbol.for("react.scope") : 60119;
        function w(S) {
            if (typeof S == "object" && S !== null) {
                var T = S.$$typeof;
                switch (T) {
                case n:
                    switch (S = S.type,
                    S) {
                    case c:
                    case u:
                    case i:
                    case s:
                    case o:
                    case d:
                        return S;
                    default:
                        switch (S = S && S.$$typeof,
                        S) {
                        case l:
                        case f:
                        case g:
                        case v:
                        case a:
                            return S;
                        default:
                            return T
                        }
                    }
                case r:
                    return T
                }
            }
        }
        function C(S) {
            return w(S) === u
        }
        e.AsyncMode = c,
        e.ConcurrentMode = u,
        e.ContextConsumer = l,
        e.ContextProvider = a,
        e.Element = n,
        e.ForwardRef = f,
        e.Fragment = i,
        e.Lazy = g,
        e.Memo = v,
        e.Portal = r,
        e.Profiler = s,
        e.StrictMode = o,
        e.Suspense = d,
        e.isAsyncMode = function(S) {
            return C(S) || w(S) === c
        }
        ,
        e.isConcurrentMode = C,
        e.isContextConsumer = function(S) {
            return w(S) === l
        }
        ,
        e.isContextProvider = function(S) {
            return w(S) === a
        }
        ,
        e.isElement = function(S) {
            return typeof S == "object" && S !== null && S.$$typeof === n
        }
        ,
        e.isForwardRef = function(S) {
            return w(S) === f
        }
        ,
        e.isFragment = function(S) {
            return w(S) === i
        }
        ,
        e.isLazy = function(S) {
            return w(S) === g
        }
        ,
        e.isMemo = function(S) {
            return w(S) === v
        }
        ,
        e.isPortal = function(S) {
            return w(S) === r
        }
        ,
        e.isProfiler = function(S) {
            return w(S) === s
        }
        ,
        e.isStrictMode = function(S) {
            return w(S) === o
        }
        ,
        e.isSuspense = function(S) {
            return w(S) === d
        }
        ,
        e.isValidElementType = function(S) {
            return typeof S == "string" || typeof S == "function" || S === i || S === u || S === s || S === o || S === d || S === p || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === v || S.$$typeof === a || S.$$typeof === l || S.$$typeof === f || S.$$typeof === m || S.$$typeof === h || S.$$typeof === y || S.$$typeof === b)
        }
        ,
        e.typeOf = w
    }
})
  , lM = pn({
    "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) {
        "use strict";
        t.exports = aM()
    }
})
  , Au = pn({
    "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) {
        "use strict";
        var n = lM()
          , r = {
            childContextTypes: !0,
            contextType: !0,
            contextTypes: !0,
            defaultProps: !0,
            displayName: !0,
            getDefaultProps: !0,
            getDerivedStateFromError: !0,
            getDerivedStateFromProps: !0,
            mixins: !0,
            propTypes: !0,
            type: !0
        }
          , i = {
            name: !0,
            length: !0,
            prototype: !0,
            caller: !0,
            callee: !0,
            arguments: !0,
            arity: !0
        }
          , o = {
            $$typeof: !0,
            render: !0,
            defaultProps: !0,
            displayName: !0,
            propTypes: !0
        }
          , s = {
            $$typeof: !0,
            compare: !0,
            defaultProps: !0,
            displayName: !0,
            propTypes: !0,
            type: !0
        }
          , a = {};
        a[n.ForwardRef] = o,
        a[n.Memo] = s;
        function l(b) {
            return n.isMemo(b) ? s : a[b.$$typeof] || r
        }
        var c = Object.defineProperty
          , u = Object.getOwnPropertyNames
          , f = Object.getOwnPropertySymbols
          , d = Object.getOwnPropertyDescriptor
          , p = Object.getPrototypeOf
          , v = Object.prototype;
        function g(b, m, h) {
            if (typeof m != "string") {
                if (v) {
                    var y = p(m);
                    y && y !== v && g(b, y, h)
                }
                var w = u(m);
                f && (w = w.concat(f(m)));
                for (var C = l(b), S = l(m), T = 0; T < w.length; ++T) {
                    var E = w[T];
                    if (!i[E] && !(h && h[E]) && !(S && S[E]) && !(C && C[E])) {
                        var I = d(m, E);
                        try {
                            c(b, E, I)
                        } catch {}
                    }
                }
            }
            return b
        }
        t.exports = g
    }
})
  , cM = pn({
    "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) {
        (function() {
            function n(m, h) {
                document.addEventListener ? m.addEventListener("scroll", h, !1) : m.attachEvent("scroll", h)
            }
            function r(m) {
                document.body ? m() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function h() {
                    document.removeEventListener("DOMContentLoaded", h),
                    m()
                }) : document.attachEvent("onreadystatechange", function h() {
                    (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", h),
                    m())
                })
            }
            function i(m) {
                this.a = document.createElement("div"),
                this.a.setAttribute("aria-hidden", "true"),
                this.a.appendChild(document.createTextNode(m)),
                this.b = document.createElement("span"),
                this.c = document.createElement("span"),
                this.h = document.createElement("span"),
                this.f = document.createElement("span"),
                this.g = -1,
                this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
                this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",
                this.b.appendChild(this.h),
                this.c.appendChild(this.f),
                this.a.appendChild(this.b),
                this.a.appendChild(this.c)
            }
            function o(m, h) {
                m.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + h + ";"
            }
            function s(m) {
                var h = m.a.offsetWidth
                  , y = h + 100;
                return m.f.style.width = y + "px",
                m.c.scrollLeft = y,
                m.b.scrollLeft = m.b.scrollWidth + 100,
                m.g !== h ? (m.g = h,
                !0) : !1
            }
            function a(m, h) {
                function y() {
                    var C = w;
                    s(C) && C.a.parentNode && h(C.g)
                }
                var w = m;
                n(m.b, y),
                n(m.c, y),
                s(m)
            }
            function l(m, h) {
                var y = h || {};
                this.family = m,
                this.style = y.style || "normal",
                this.weight = y.weight || "normal",
                this.stretch = y.stretch || "normal"
            }
            var c = null
              , u = null
              , f = null
              , d = null;
            function p() {
                if (u === null)
                    if (v() && /Apple/.test(P.navigator.vendor)) {
                        var m = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(P.navigator.userAgent);
                        u = !!m && 603 > parseInt(m[1], 10)
                    } else
                        u = !1;
                return u
            }
            function v() {
                return d === null && (d = !!document.fonts),
                d
            }
            function g() {
                if (f === null) {
                    var m = document.createElement("div");
                    try {
                        m.style.font = "condensed 100px sans-serif"
                    } catch {}
                    f = m.style.font !== ""
                }
                return f
            }
            function b(m, h) {
                return [m.style, m.weight, g() ? m.stretch : "", "100px", h].join(" ")
            }
            l.prototype.load = function(m, h) {
                var y = this
                  , w = m || "BESbswy"
                  , C = 0
                  , S = h || 3e3
                  , T = new Date().getTime();
                return new Promise(function(E, I) {
                    if (v() && !p()) {
                        var O = new Promise(function(z, j) {
                            function J() {
                                new Date().getTime() - T >= S ? j(Error("" + S + "ms timeout exceeded")) : document.fonts.load(b(y, '"' + y.family + '"'), w).then(function(H) {
                                    1 <= H.length ? z() : setTimeout(J, 25)
                                }, j)
                            }
                            J()
                        }
                        )
                          , B = new Promise(function(z, j) {
                            C = setTimeout(function() {
                                j(Error("" + S + "ms timeout exceeded"))
                            }, S)
                        }
                        );
                        Promise.race([B, O]).then(function() {
                            clearTimeout(C),
                            E(y)
                        }, I)
                    } else
                        r(function() {
                            function z() {
                                var X;
                                (X = ie != -1 && q != -1 || ie != -1 && re != -1 || q != -1 && re != -1) && ((X = ie != q && ie != re && q != re) || (c === null && (X = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(P.navigator.userAgent),
                                c = !!X && (536 > parseInt(X[1], 10) || parseInt(X[1], 10) === 536 && 11 >= parseInt(X[2], 10))),
                                X = c && (ie == U && q == U && re == U || ie == pe && q == pe && re == pe || ie == me && q == me && re == me)),
                                X = !X),
                                X && (ae.parentNode && ae.parentNode.removeChild(ae),
                                clearTimeout(C),
                                E(y))
                            }
                            function j() {
                                if (new Date().getTime() - T >= S)
                                    ae.parentNode && ae.parentNode.removeChild(ae),
                                    I(Error("" + S + "ms timeout exceeded"));
                                else {
                                    var X = document.hidden;
                                    (X === !0 || X === void 0) && (ie = J.a.offsetWidth,
                                    q = H.a.offsetWidth,
                                    re = fe.a.offsetWidth,
                                    z()),
                                    C = setTimeout(j, 50)
                                }
                            }
                            var J = new i(w)
                              , H = new i(w)
                              , fe = new i(w)
                              , ie = -1
                              , q = -1
                              , re = -1
                              , U = -1
                              , pe = -1
                              , me = -1
                              , ae = document.createElement("div");
                            ae.dir = "ltr",
                            o(J, b(y, "sans-serif")),
                            o(H, b(y, "serif")),
                            o(fe, b(y, "monospace")),
                            ae.appendChild(J.a),
                            ae.appendChild(H.a),
                            ae.appendChild(fe.a),
                            document.body.appendChild(ae),
                            U = J.a.offsetWidth,
                            pe = H.a.offsetWidth,
                            me = fe.a.offsetWidth,
                            j(),
                            a(J, function(X) {
                                ie = X,
                                z()
                            }),
                            o(J, b(y, '"' + y.family + '",sans-serif')),
                            a(H, function(X) {
                                q = X,
                                z()
                            }),
                            o(H, b(y, '"' + y.family + '",serif')),
                            a(fe, function(X) {
                                re = X,
                                z()
                            }),
                            o(fe, b(y, '"' + y.family + '",monospace'))
                        })
                }
                )
            }
            ,
            typeof t == "object" ? t.exports = l : (P.FontFaceObserver = l,
            P.FontFaceObserver.prototype.load = l.prototype.load)
        }
        )()
    }
});
function Sm(e, t) {
    let n = {
        style: t
    };
    return x.isValidElement(e) ? x.cloneElement(e, n) : x.createElement(e, n)
}
var uM = class extends Error {
}
  , ou = class extends Error {
}
  , fM = class extends we {
    constructor(e) {
        super(e),
        this.state = {
            error: void 0,
            forceUpdateKey: e.forceUpdateKey
        }
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    static getDerivedStateFromProps(e, t) {
        if (e.forceUpdateKey !== t.forceUpdateKey) {
            let n = {
                forceUpdateKey: e.forceUpdateKey
            };
            return t.error && (n.error = void 0),
            n
        }
        return null
    }
    render() {
        if (this.state.error === void 0)
            return this.props.children;
        if (!(this.state.error instanceof uM)) {
            let n = new ou;
            throw n.cause = this.state.error,
            n
        }
        let {notFoundPage: e, defaultPageStyle: t} = this.props;
        if (!e)
            throw this.state.error;
        return Sm(e, t)
    }
}
  , dM = ":([a-z]\\w*)"
  , Gi = new RegExp(dM,"gi");
function uk(e, t) {
    return e.replace(Gi, (n, r) => {
        let i = t[r];
        return typeof i != "string" || i.length === 0 ? n : encodeURIComponent(i)
    }
    )
}
function fk(e, t) {
    if (!e.startsWith("/") || !t.startsWith("/"))
        throw new Error("from/to paths are expected to be absolute");
    let[n] = TS(e)
      , [r,i] = TS(t)
      , o = hM(n, r);
    return o === "" && (o = "."),
    !o.startsWith(".") && !o.startsWith("/") && (o = "./" + o),
    o + "/" + i
}
function TS(e) {
    let t = e.lastIndexOf("/");
    return [e.substring(0, t + 1), e.substring(t + 1)]
}
var Kp = 46
  , Xo = 47
  , pi = (e, t) => e.charCodeAt(t)
  , RS = (e, t) => e.lastIndexOf(t)
  , Ko = (e, t, n) => e.slice(t, n);
function hM(e, t) {
    if (e === t || (e = "/" + FS(e),
    t = "/" + FS(t),
    e === t))
        return "";
    let n = 1
      , r = e.length
      , i = r - n
      , o = 1
      , s = t.length - o
      , a = i < s ? i : s
      , l = -1
      , c = 0;
    for (; c < a; c++) {
        let f = pi(e, n + c);
        if (f !== pi(t, o + c))
            break;
        f === Xo && (l = c)
    }
    if (c === a)
        if (s > a) {
            if (pi(t, o + c) === Xo)
                return Ko(t, o + c + 1);
            if (c === 0)
                return Ko(t, o + c)
        } else
            i > a && (pi(e, n + c) === Xo ? l = c : c === 0 && (l = 0));
    let u = "";
    for (c = n + l + 1; c <= r; ++c)
        (c === r || pi(e, c) === Xo) && (u += u.length === 0 ? ".." : "/..");
    return `${u}${Ko(t, o + l)}`
}
var pM = !1
  , qc = "/"
  , ES = e => e === Xo;
function FS(e) {
    let t = ""
      , n = 0
      , r = -1
      , i = 0
      , o = 0;
    for (let s = 0; s <= e.length; ++s) {
        if (s < e.length)
            o = pi(e, s);
        else {
            if (ES(o))
                break;
            o = Xo
        }
        if (ES(o)) {
            if (!(r === s - 1 || i === 1))
                if (i === 2) {
                    if (t.length < 2 || n !== 2 || pi(t, t.length - 1) !== Kp || pi(t, t.length - 2) !== Kp) {
                        if (t.length > 2) {
                            let a = RS(t, qc);
                            a === -1 ? (t = "",
                            n = 0) : (t = Ko(t, 0, a),
                            n = t.length - 1 - RS(t, qc)),
                            r = s,
                            i = 0;
                            continue
                        } else if (t.length !== 0) {
                            t = "",
                            n = 0,
                            r = s,
                            i = 0;
                            continue
                        }
                    }
                    pM && (t += t.length > 0 ? `${qc}..` : "..",
                    n = 2)
                } else
                    t.length > 0 ? t += `${qc}${Ko(e, r + 1, s)}` : t = Ko(e, r + 1, s),
                    n = s - r - 1;
            r = s,
            i = 0
        } else
            o === Kp && i !== -1 ? ++i : i = -1
    }
    return t
}
function dk(e) {
    let t = typeof P < "u" ? P.location.search : "";
    return t ? mM(t, e) : e
}
function mM(e, t) {
    let n = t.indexOf("#")
      , r = n === -1 ? t : t.substring(0, n)
      , i = n === -1 ? "" : t.substring(n)
      , o = r.indexOf("?");
    if (o === -1)
        return r + e + i;
    let s = new URLSearchParams(e)
      , a = r.substring(o + 1)
      , l = new URLSearchParams(a);
    for (let[c,u] of s)
        l.has(c) || l.append(c, u);
    return r.substring(0, o + 1) + l.toString() + i
}
function Ea(e) {
    return typeof e == "object" && e !== null && !Array.isArray(e)
}
function Ui(e) {
    return typeof e == "string"
}
var gM = "preload";
function hk(e) {
    return typeof e == "object" && e !== null && !x.isValidElement(e) && gM in e
}
function X6(e) {
    let t = x.lazy(e), n, r, i = x.forwardRef(function(s, a) {
        return x.createElement(r ?? t, a ? {
            ref: a,
            ...s
        } : s)
    });
    return i.preload = () => (n || (n = e().then(o => (r = o.default,
    r))),
    n),
    i
}
function Du(e, t) {
    if (t && e)
        return e.elements && t in e.elements ? e.elements[t] : t
}
function vM(e) {
    return /bot|-google|google-|yandex|ia_archiver/iu.test(e)
}
function pk(e) {
    if ("scheduler"in P) {
        if ("yield"in scheduler)
            return scheduler.yield(e);
        if ("postTask"in scheduler)
            return scheduler.postTask( () => {}
            , e)
    }
    return e?.priority === "user-blocking" ? Promise.resolve() : new Promise(t => {
        setTimeout(t)
    }
    )
}
async function mk(e, t) {
    return await pk(t),
    e()
}
function zu(e) {
    return new Promise(t => {
        setTimeout(t, 100),
        requestAnimationFrame( () => {
            mk(t, e)
        }
        )
    }
    )
}
function yM(e, t, n, r=Ae) {
    r( () => {
        let i = async s => (await zu(n),
        s())
          , o = i(e);
        return () => {
            (async () => {
                let s = await o;
                s && i(s)
            }
            )()
        }
    }
    , t)
}
var $m = () => {}
  , bM = [];
async function xM(e, t, n, r, i, o, s) {
    var a, l, c;
    let u = e
      , f = !1
      , d = {
        ...o
    }
      , p = Array.from(u.matchAll(Gi))
      , v = await Promise.all(p.map(async h => {
        var y;
        let w = h?.[0]
          , C = h?.[1];
        if (!w || !C)
            throw new Error("Failed to replace path variables: unexpected regex match group");
        let S = o[C];
        if (!S || !Ui(S))
            throw new Error(`No slug found for path variable ${C}`);
        let T = await ((y = s?.[i]) === null || y === void 0 ? void 0 : y.call(s));
        if (!T || !t)
            return S;
        let E = await T.getRecordIdBySlug(S, t);
        if (!E)
            return S;
        let I = await T.getSlugByRecordId(E, n);
        if (!I) {
            f = !0;
            let O = await T.getSlugByRecordId(E, r);
            return O && (d[C] = O),
            O ?? S
        }
        return d[C] = I,
        I
    }
    ))
      , g = 0
      , b = ""
      , m = !1;
    for (let h = 0; h < p.length; h++) {
        let y = p[h]
          , w = v[h];
        !y || !w || (b += u.substring(g, y.index),
        g = ((a = y.index) !== null && a !== void 0 ? a : 0) + ((c = (l = y[0]) === null || l === void 0 ? void 0 : l.length) !== null && c !== void 0 ? c : 0),
        b += v[h],
        m = !0)
    }
    return m && (u = b),
    {
        path: u,
        pathVariables: d,
        isMissingInLocale: f
    }
}
async function wM({currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: o, preserveQueryParams: s}) {
    let {path: a} = r
      , l = {
        path: a,
        pathVariables: i,
        isMissingInLocale: !1
    };
    if (!a)
        return l;
    if (i && r.collectionId)
        try {
            l = await xM(a, e, t, n, r.collectionId, i, o)
        } catch {}
    return t.slug && (l.path = "/" + t.slug + l.path),
    s && l.path && (l.path = dk(l.path)),
    l
}
function SM(e, t, {global: n, routes: r}) {
    var i;
    return ((i = r[e]) === null || i === void 0 ? void 0 : i[t]) || n
}
var kM = {
    global: void 0,
    routes: {}
}
  , gk = x.createContext(kM);
function Z6({children: e, value: t}) {
    return k(gk.Provider, {
        value: t,
        children: e
    })
}
function CM() {
    return x.useContext(gk)
}
var Qp = 10
  , TM = 1e4;
function RM(e) {
    let t = Qp
      , n = e.next(0)
      , r = [n.value];
    for (; !n.done && t < TM; )
        n = e.next(t),
        r.push(n.value),
        t += Qp;
    return r.length === 1 && r.push(n.value),
    {
        easing: `linear(${r.join(",")})`,
        duration: t - Qp
    }
}
var Lr = e => `--view-transition-${e}`;
function km(e) {
    return [parseFloat(e), e.endsWith("px") ? "px" : "%"]
}
function vk(e) {
    let {innerWidth: t, innerHeight: n} = P
      , [r,i] = km(e.x)
      , [o,s] = km(e.y);
    return {
        x: i === "px" ? r : t * (r / 100),
        y: s === "px" ? o : n * (o / 100)
    }
}
var EM = {
    makeKeyframe: (e, t, n) => {
        let r = 0;
        return (n === "exit" && e.angularDirection === "clockwise" && t === "start" || n === "exit" && e.angularDirection === "counter-clockwise" && t === "end" || n === "enter" && e.angularDirection === "counter-clockwise" && t === "start" || n === "enter" && e.angularDirection === "clockwise" && t === "end") && (r = e.sweepAngle / 360 * 100),
        `${Lr("conic-offset")}: ${r}%;`
    }
    ,
    makeStyles: (e, t) => {
        let n = `var(${Lr("conic-offset")})`
          , r = t === "exit" && e.angularDirection === "clockwise" || t === "enter" && e.angularDirection === "counter-clockwise"
          , i = r ? "transparent" : "black"
          , o = r ? "black" : "transparent"
          , s = "conic-gradient(from ";
        return s += `${e.angle}deg at ${e.x} ${e.y}, `,
        s += `${i} 0%, ${i} ${n}, `,
        s += `${o} ${n}, ${o} 100%)`,
        `mask-image: ${s}; -webkit-mask-image: ${s};`
    }
    ,
    makePropertyRules: () => `
        @property ${Lr("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `
}
  , FM = {
    makeKeyframe: (e, t) => {
        let {x: n, y: r} = vk(e);
        return t === "start" ? `clip-path: circle(0 at ${n}px ${r}px);` : `clip-path: circle(${Math.hypot(Math.max(n, P.innerWidth - n), Math.max(r, P.innerHeight - r))}px at ${n}px ${r}px);`
    }
}
  , PM = {
    makeKeyframe: (e, t) => {
        let {x: n, y: r} = vk(e)
          , i = P.innerHeight - r
          , o = P.innerWidth - n;
        return t === "start" ? `clip-path: inset(${r}px ${o}px ${i}px ${n}px round ${e.round}px);` : "clip-path: inset(0 round 0);"
    }
}
  , _M = {
    makeKeyframe: (e, t, n) => {
        let[,r] = km(e.width)
          , i = `0${r}`;
        return (t === "start" && n === "exit" || t === "end" && n === "enter") && (i = e.width),
        `${Lr("blinds-width")}: ${i};`
    }
    ,
    makeStyles: (e, t) => {
        let n = `var(${Lr("blinds-width")})`
          , r = t === "exit" ? "transparent" : "black"
          , i = t === "exit" ? "black" : "transparent"
          , o = "repeating-linear-gradient(";
        return o += e.angle + 90 + "deg, ",
        o += `${r} 0px, ${r} ${n}, `,
        o += `${i} ${n}, ${i} ${e.width})`,
        `mask-image: ${o}; -webkit-mask-image: ${o};`
    }
    ,
    makePropertyRules: () => `
            @property ${Lr("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `
}
  , IM = {
    makeKeyframe: (e, t, n) => {
        let r = t === "start" && n === "exit" || t === "end" && n === "enter" ? 1 : 0;
        return `${Lr("wipe-offset")}: ${r};`
    }
    ,
    makeStyles: (e, t) => {
        let n = `var(${Lr("wipe-offset")})`
          , r = t === "exit" ? "transparent" : "black"
          , i = t === "exit" ? "black" : "transparent"
          , o = "linear-gradient(";
        return o += e.angle + 90 + "deg, ",
        o += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `,
        o += `${i} calc(calc(100% + ${e.width}) * ${n}))`,
        `mask-image: ${o}; -webkit-mask-image: ${o};`
    }
    ,
    makePropertyRules: () => `
            @property ${Lr("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `
}
  , OM = {
    circle: FM,
    conic: EM,
    inset: PM,
    blinds: _M,
    wipe: IM
}
  , MM = {
    opacity: 1,
    x: "0px",
    y: "0px",
    scale: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    mask: void 0
};
function PS(e, t, n, r) {
    var i;
    let o = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `;
    return e.mask && (o += ((i = r?.makeKeyframe) === null || i === void 0 ? void 0 : i.call(r, e.mask, t, n)) || ""),
    o
}
function LM(e) {
    return e ? OM[e] : void 0
}
function _S(e, {transition: t, ...n}) {
    var r;
    let i = "view-transition-" + e
      , o = {
        duration: "0s",
        easing: "linear"
    };
    if (t.type === "tween")
        o.duration = t.duration + "s",
        o.easing = `cubic-bezier(${t.ease.join(",")})`;
    else if (VM(t)) {
        let {easing: c, duration: u} = RM(ks({
            keyframes: [0, 1],
            ...AM(t),
            restDelta: .001,
            restSpeed: 1e-4
        }));
        o.duration = u + "ms",
        o.easing = c
    }
    let s = LM((r = n?.mask) === null || r === void 0 ? void 0 : r.type)
      , a = PS(n, "start", e, s)
      , l = PS({
        ...MM,
        mask: n.mask
    }, "end", e, s);
    return e === "exit" && ([a,l] = [l, a]),
    `
        ${n.mask && s?.makePropertyRules ? s.makePropertyRules(n.mask) : ""}

        @keyframes ${i} {
            0% {
                ${a}
            }

            100% {
                ${l}
            }
        }

        ::view-transition-${e === "enter" ? "new" : "old"}(root) {
            animation-name: ${i};
            animation-duration: ${o.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${o.easing};
            animation-fill-mode: both;
            ${n.mask && s?.makeStyles ? s.makeStyles(n.mask, e) : ""}
        }
    `
}
function VM(e) {
    return e.type === "spring"
}
function AM(e) {
    return e.durationBasedSpring ? {
        duration: e.duration,
        bounce: e.bounce
    } : {
        stiffness: e.stiffness,
        damping: e.damping,
        mass: e.mass
    }
}
var yk = "view-transition-styles"
  , DM = {
    x: "0px",
    y: "0px",
    scale: 1,
    opacity: 1,
    rotate3d: !1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    mask: void 0,
    transition: {
        type: "tween",
        delay: 0,
        duration: .2,
        ease: [.27, 0, .51, 1],
        stiffness: 400,
        damping: 30,
        mass: 1
    }
};
function zM({exit: e=DM, enter: t}) {
    let n = document.createElement("style");
    n.id = yk;
    let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `;
    (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `),
    r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `,
    r += _S("exit", e),
    r += _S("enter", t),
    n.textContent = r,
    document.head.appendChild(n)
}
var BM = ( () => typeof P < "u" ? P.requestIdleCallback || P.setTimeout : setTimeout)();
function $M() {
    BM( () => {
        Z.render( () => {
            performance.mark("framer-vt-remove");
            let e = document.getElementById(yk);
            e && document.head.removeChild(e)
        }
        )
    }
    )
}
var IS = () => {}
;
function NM() {
    return !!document.startViewTransition
}
function jM(e) {
    return new Promise(t => {
        Z.render( () => {
            performance.mark("framer-vt-style"),
            zM(e),
            t()
        }
        )
    }
    )
}
async function OS(e, t, n) {
    if (!NM()) {
        e();
        return
    }
    if (await jM(t),
    n?.aborted)
        return;
    performance.mark("framer-vt");
    let r = document.startViewTransition(async () => {
        performance.mark("framer-vt-freeze"),
        !n?.aborted && (n?.addEventListener("abort", () => r.skipTransition()),
        await e())
    }
    );
    return r.updateCallbackDone.then( () => {
        performance.mark("framer-vt-unfreeze")
    }
    ).catch(IS),
    Promise.all([r.ready, r.finished]).then( () => {
        performance.mark("framer-vt-finished"),
        $M()
    }
    ).catch(IS),
    r
}
function bk() {
    let e = CM()
      , t = V(void 0);
    return $( () => {
        t.current && (t.current(),
        t.current = void 0)
    }
    ),
    K( (n, r, i, o, s) => {
        let a = SM(n, r, e);
        if (a) {
            let l = new Promise(f => {
                t.current = f
            }
            )
              , c = async () => {
                i(),
                await l
            }
              , u = async () => (await zu({
                priority: "user-blocking",
                signal: s
            }).catch($m),
            OS(c, a, s));
            return o ? u() : OS(c, a)
        } else
            return i()
    }
    , [e])
}
function xk(e) {
    let t = `${e}-start`
      , n = `${e}-end`
      , r = V(void 0);
    return yM( () => {
        r.current && (r.current(),
        r.current = void 0)
    }
    , void 0, {
        priority: "user-blocking"
    }),
    K( () => {
        let i = new Promise(o => {
            r.current = o
        }
        );
        return performance.mark(t),
        i.finally( () => {
            performance.mark(n),
            performance.measure(e, t, n)
        }
        ).catch(o => {
            console.error(o)
        }
        )
    }
    , [e, t, n])
}
async function MS(e, t, {currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, localeId: s, preserveQueryParams: a}, l=!1, c=!1) {
    let {path: u} = t;
    if (u)
        try {
            let f = Bu(t, {
                currentRoutePath: n,
                currentPathVariables: r,
                hash: i,
                pathVariables: o,
                preserveQueryParams: a
            });
            return await wk({
                routeId: e,
                hash: i,
                pathVariables: o,
                localeId: s
            }, f, l, c)
        } catch {}
}
function HM(e) {
    let t = "routeId";
    return Ea(e) && Ui(e[t])
}
function WM(e, t, n=!1) {
    performance.mark("framer-history-replace"),
    (n ? P.history.__proto__.replaceState : P.history.replaceState).call(P.history, e, "", t)
}
var Xc = !0
  , LS = ( () => {
    if (typeof Fe > "u")
        return !1;
    let e = Fe.userAgent
      , t = e.indexOf("Chrome/")
      , n = +e.slice(t + 7, e.indexOf(".", t));
    return n > 101 && n < 128
}
)();
async function wk(e, t, n=!1, r=!1) {
    if (n && await zu({
        priority: "user-blocking"
    }),
    performance.mark("framer-history-push"),
    !r) {
        P.history.pushState(e, "", t);
        return
    }
    let i = !1, o;
    Xc && (o = () => {
        var s;
        if (i = !0,
        LS)
            return;
        let a = "Popstate called after intercept(). Please report this to the Framer team.";
        console.error(a),
        (s = P.__framer_events) === null || s === void 0 || s.push(["published_site_load_recoverable_error", {
            message: a,
            userAgent: Fe.userAgent
        }])
    }
    ,
    P.addEventListener("popstate", o, {
        once: !0
    })),
    LS && Xc ? P.history.__proto__.pushState.call(P.history, e, "", t) : P.history.pushState(e, "", t),
    Xc && queueMicrotask( () => {
        i || (Xc = !1,
        P.removeEventListener("popstate", o))
    }
    )
}
function UM({disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r}) {
    Ae( () => {
        e || (performance.mark("framer-history-set-initial-state"),
        WM({
            routeId: t,
            pathVariables: n,
            localeId: r
        }, void 0, !0))
    }
    , [])
}
function GM(e, t) {
    let n = bk()
      , r = xk("framer-route-change-popstate")
      , i = V(void 0)
      , o = K(async ({state: a}) => {
        var l, c, u, f, d, p;
        if (!((l = P.navigation) === null || l === void 0) && l.transition && ((u = (c = P.navigation) === null || c === void 0 ? void 0 : c.transition) === null || u === void 0 ? void 0 : u.navigationType) !== "traverse" || !Ea(a))
            return;
        let {routeId: v, hash: g, pathVariables: b, localeId: m} = a;
        if (!Ui(v))
            return;
        r();
        let h = () => {
            t(v, Ui(m) ? m : void 0, Ui(g) ? g : void 0, Ea(b) ? b : void 0, !1, !0)
        }
          , y = await n(e.current, v, h, !1);
        y ? y.updateCallbackDone.then((f = i.current) === null || f === void 0 ? void 0 : f.resolve).catch((d = i.current) === null || d === void 0 ? void 0 : d.reject) : (p = i.current) === null || p === void 0 || p.resolve()
    }
    , [e, r, t, n])
      , s = K(a => {
        a.navigationType === "traverse" && a.intercept({
            async handler() {
                await new Promise( (l, c) => {
                    i.current = {
                        resolve: l,
                        reject: c
                    }
                }
                ),
                i.current = void 0
            },
            scroll: "after-transition"
        })
    }
    , []);
    $( () => {
        var a;
        return P.addEventListener("popstate", o),
        (a = P.navigation) === null || a === void 0 || a.addEventListener("navigate", s),
        () => {
            var l;
            P.removeEventListener("popstate", o),
            (l = P.navigation) === null || l === void 0 || l.removeEventListener("navigate", s)
        }
    }
    , [o, s])
}
function qM(e, t, n) {
    let r = Du(t, e);
    if (!r)
        return;
    let i = Object.assign({}, t?.elements, n);
    return r.replace(Gi, (o, s) => {
        var a;
        return String((a = i[s]) !== null && a !== void 0 ? a : o)
    }
    )
}
function Bu(e, {currentRoutePath: t, currentPathVariables: n, hash: r, pathVariables: i, hashVariables: o, relative: s=!0, preserveQueryParams: a}) {
    var l;
    let c = t ?? "/";
    n && (c = c.replace(Gi, (v, g) => String(n[g] || v)));
    let f = (l = e?.path) !== null && l !== void 0 ? l : "/";
    i && (f = f.replace(Gi, (v, g) => String(i[g] || v)));
    let d = qM(r, e, o)
      , p = c === f && d;
    return s && (f = fk(c, f)),
    (a || p) && (f = dk(f)),
    d && (f = `${f}#${d}`),
    f
}
async function XM(e, t, n) {
    if (!e.path || !t)
        return !1;
    let i = `${n.slug ? `/${n.slug}` : ""}${uk(e.path, t)}`;
    return (await fetch(i, {
        method: "HEAD",
        redirect: "manual"
    })).type === "opaqueredirect" ? (P.location.href = P.location.origin + i,
    !0) : !1
}
async function YM(e) {
    let t = await wM(e);
    if (t) {
        try {
            localStorage.setItem("preferredLocale", e.nextLocale.code)
        } catch {}
        try {
            if (!Ui(t.path))
                throw new Error("Expected result.path to be a string");
            if (t.isMissingInLocale && await XM(e.route, t.pathVariables, e.nextLocale))
                return
        } catch {}
        return t
    }
}
function KM() {
    let e = V(Promise.resolve())
      , t = V()
      , n = K(r => {
        if (r.navigationType === "traverse")
            return;
        let i = t.current;
        i?.signal.addEventListener("abort", () => {
            i.abort("user aborted")
        }
        ),
        r.intercept({
            handler: () => e.current
        })
    }
    , []);
    return K( (r, i, o) => {
        if (!P.navigation) {
            i();
            return
        }
        e.current = r,
        t.current = o,
        P.navigation.addEventListener("navigate", n),
        i(!0),
        r.catch($m).finally( () => {
            P.navigation.removeEventListener("navigate", n)
        }
        )
    }
    , [n])
}
function Or(e, t, n) {
    try {
        performance.measure(e, t, n)
    } catch (r) {
        console.warn(`Could not measure ${e}`, r)
    }
}
var cr = !1;
function tj() {
    cr = !0,
    performance.mark("framer-hydration-start")
}
var VS = !1
  , AS = !1
  , DS = !1;
function QM() {
    let e = "framer-hydration-router";
    ct( () => {
        VS || !cr || (VS = !0,
        performance.mark(`${e}-insertion-effect`))
    }
    , []),
    Ae( () => {
        AS || !cr || (AS = !0,
        performance.mark(`${e}-layout-effect`))
    }
    , []),
    $( () => {
        DS || !cr || (DS = !0,
        performance.mark(`${e}-effect`))
    }
    , [])
}
var zS = !1
  , BS = !1
  , $S = !1
  , Sk = !1;
function ZM() {
    let e = "framer-hydration-"
      , t = `${e}layout-effects-end`
      , n = `${e}effects-end`
      , r = `${e}browser-render-start`
      , i = `${e}render-end`;
    return ct( () => {
        zS || !cr || (zS = !0,
        performance.mark(i),
        Or(`${e}render`, `${e}start`, i),
        performance.mark(`${e}insertion-effects-start`))
    }
    , []),
    Ae( () => {
        if (!(BS || !cr)) {
            if (BS = !0,
            performance.mark(`${e}layout-effects-start`),
            document.visibilityState !== "visible") {
                Sk = !0;
                return
            }
            requestAnimationFrame( () => {
                var o, s, a;
                performance.mark(r),
                Or(`${e}uho`, (s = (o = performance.getEntriesByName(n)[0]) === null || o === void 0 ? void 0 : o.name) !== null && s !== void 0 ? s : (a = performance.getEntriesByName(t)[0]) === null || a === void 0 ? void 0 : a.name, r)
            }
            )
        }
    }
    , []),
    $( () => {
        var o;
        if ($S || !cr)
            return;
        $S = !0;
        let s = `${e}effects-start`;
        performance.mark(s),
        ((o = performance.getEntriesByName(r)[0]) === null || o === void 0 ? void 0 : o.name) || (Or(`${e}commit`, t, s),
        performance.mark(`${e}effects-sync`))
    }
    , []),
    null
}
var NS = !1
  , jS = !1
  , HS = !1;
function JM() {
    let e = "framer-hydration-"
      , t = `${e}layout-effects-end`
      , n = `${e}effects-end`
      , r = `${e}browser-render-start`
      , i = `${e}start`
      , o = `${e}insertion-effects-end`
      , s = `${e}first-paint`
      , a = `${e}browser-raf-end`;
    return ct( () => {
        NS || !cr || (NS = !0,
        performance.mark(o),
        Or(`${e}insertion-effects`, `${e}insertion-effects-start`, o))
    }
    , []),
    Ae( () => {
        jS || !cr || (jS = !0,
        performance.mark(t),
        Or(`${e}layout-effects`, `${e}layout-effects-start`, t),
        !(Sk || document.visibilityState !== "visible") && requestAnimationFrame( () => {
            performance.mark(a),
            Or(`${e}raf`, r, a),
            mk( () => {
                performance.mark(s),
                Or(`${e}time-to-first-paint`, i, s),
                Or(`${e}browser-render`, a, s)
            }
            )
        }
        ))
    }
    , []),
    $( () => {
        var l, c, u;
        HS || !cr || (HS = !0,
        performance.mark(n),
        Or(`${e}effects`, (c = (l = performance.getEntriesByName(s)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(`${e}effects-start`)[0]) === null || u === void 0 ? void 0 : u.name, n))
    }
    , []),
    null
}
function eL() {
    return ZM(),
    null
}
function tL() {
    return JM(),
    null
}
var WS = {
    Start: eL,
    End: tL
}
  , Ta = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset"]
  , kk = e => {
    var t, n;
    !((n = (t = e.target) === null || t === void 0 ? void 0 : t.closest) === null || n === void 0) && n.call(t, "#main") && (e.stopPropagation(),
    performance.mark("framer-react-event-handling-prevented"))
}
  , Ck = !1;
function rj() {
    if (!Ta)
        return;
    Ck = !0,
    performance.mark("framer-react-event-handling-start");
    let e = {
        capture: !0
    };
    Ta.forEach(t => document.body.addEventListener(t, kk, e))
}
function nL() {
    return $( () => {
        if (!Ck || !Ta)
            return;
        let e = {
            capture: !0
        };
        Ta.forEach(t => document.body.removeEventListener(t, kk, e)),
        Ta = void 0,
        performance.mark("framer-react-event-handling-end")
    }
    , []),
    null
}
var Nm = !1;
function oj() {
    Nm = !0
}
function rL() {
    Nm = !1
}
function iL() {
    let e = V(typeof P > "u" || Nm);
    return $( () => {
        e.current = !1
    }
    , []),
    e
}
function oL(e, t) {
    if (e.routeId !== t.routeId)
        return !1;
    if (e.pathVariables === t.pathVariables)
        return !0;
    let n = e.pathVariables || {}
      , r = t.pathVariables || {};
    return n.length === r.length && Object.keys(n).every(i => n[i] === r[i])
}
function Tk(e) {
    return x.useCallback(t => e[t], [e])
}
var jm = ( () => x.createContext({}))();
function sL({api: e, children: t}) {
    return k(jm.Provider, {
        value: e,
        children: t
    })
}
function Ki() {
    return x.useContext(jm)
}
function aL({routes: e, children: t}) {
    let n = Tk(e);
    return k(jm.Provider, {
        value: {
            getRoute: n
        },
        children: t
    })
}
var lL = class extends we {
    constructor() {
        super(...arguments),
        this.state = {
            error: void 0
        }
    }
    static getDerivedStateFromError(e) {
        return e instanceof ou || console.error("Derived error in SuspenseErrorBoundary", e),
        {
            error: e
        }
    }
    componentDidCatch(e, t) {
        var n;
        if (e instanceof ou)
            return;
        let r = t?.componentStack;
        if (console.error("Caught error in SuspenseErrorBoundary", e, r),
        typeof P < "u") {
            let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null;
            (n = P.__framer_events) === null || n === void 0 || n.push(["published_site_load_recoverable_error", {
                message: String(e),
                stack: i,
                componentStack: i ? void 0 : r
            }])
        }
    }
    render() {
        if (this.state.error === void 0)
            return this.props.children;
        if (this.state.error instanceof ou)
            throw this.state.error.cause;
        return P.__framer_STPD_OPT_OUT__ = !0,
        k(pr, {
            children: this.props.fallbackChildren
        })
    }
}
  , cL = ( () => typeof P < "u" ? new Promise( () => {}
) : null)();
function uL() {
    if (typeof P > "u" || P.__framer_STPD_OPT_OUT__)
        return null;
    throw cL
}
function Hm({children: e}) {
    return k(lL, {
        fallbackChildren: e,
        children: k(pr, {
            fallback: k(uL, {}),
            children: e
        })
    })
}
var US = "default";
function fL() {
    let[e,t] = x.useState(0);
    return [e, x.useCallback( () => t(n => n + 1), [])]
}
var dL = async () => {}
  , hL = {
    activeLocale: null,
    locales: [],
    setLocale: dL
}
  , Rk = x.createContext(hL);
function Ek() {
    return x.useContext(Rk)
}
function GS(e, t, n) {
    let r = e && document.getElementById(e);
    if (r) {
        yL(r, t);
        return
    }
    n || P.scrollTo(0, 0)
}
function pL(e) {
    let t = V([]);
    return Ae( () => {
        var n;
        !((n = t.current) === null || n === void 0) && n.length && (t.current.forEach(r => r()),
        t.current = [])
    }
    , [e]),
    K(n => {
        t.current.push(n)
    }
    , [])
}
function mL(e) {
    let t = KM()
      , n = xk("framer-route-change")
      , r = V(void 0);
    return K(async (i, o, s=!0) => {
        var a;
        if (rL(),
        !e)
            return await o?.(),
            i(),
            n(),
            new Promise(p => {
                p()
            }
            );
        (a = r.current) === null || a === void 0 || a.abort();
        let l = s ? new AbortController : void 0;
        r.current = l;
        let c = l?.signal
          , u = n();
        if (!o)
            return r.current = void 0,
            i(c),
            u;
        let f, d = new Promise( (p, v) => {
            f = p,
            c?.aborted ? v() : c?.addEventListener("abort", v)
        }
        );
        return await zu({
            priority: "user-blocking",
            signal: c
        }).catch($m),
        i(c),
        t(d, o, l),
        u.then( () => {
            f()
        }
        )
    }
    , [e, n, t])
}
function gL({defaultPageStyle: e, disableHistory: t, initialPathVariables: n, initialRoute: r, notFoundPage: i, collectionUtils: o, routes: s, initialLocaleId: a, locales: l=bM, preserveQueryParams: c=!1, enableAsyncURLUpdates: u=!1, LayoutTemplate: f, editorBar: d}) {
    QM(),
    UM({
        disabled: t,
        routeId: r,
        initialPathVariables: n,
        initialLocaleId: a
    });
    let p = bk()
      , [v,g] = fL()
      , b = pL(v)
      , m = mL(u)
      , h = V(r)
      , y = V(n)
      , w = V(a)
      , C = w.current
      , S = se( () => {
        var q;
        return (q = l.find( ({id: re}) => C ? re === C : re === US)) !== null && q !== void 0 ? q : null
    }
    , [C, l])
      , T = se( () => ({
        activeLocale: S,
        locales: l,
        setLocale: async q => {
            let re;
            Ui(q) ? re = q : Ea(q) && (re = q.id);
            let U = l.find( ({id: X}) => X === US)
              , pe = l.find( ({id: X}) => X === re);
            if (!pe)
                return;
            let me = h.current
              , ae = s[me];
            if (ae)
                try {
                    let X = await YM({
                        currentLocale: S,
                        nextLocale: pe,
                        route: ae,
                        routeId: me,
                        defaultLocale: U,
                        pathVariables: y.current,
                        collectionUtils: o,
                        preserveQueryParams: c
                    });
                    if (!X)
                        return;
                    let Ye = y.current
                      , Ce = HM(P.history.state) ? P.history.state.paginationInfo : void 0
                      , Ke = X.path;
                    y.current = X.pathVariables,
                    w.current = pe.id,
                    m( () => {
                        p(me, me, () => Mt(g), u)
                    }
                    , async (dn=!1) => {
                        if (Ke)
                            return wk({
                                routeId: me,
                                pathVariables: Ye,
                                localeId: pe.id,
                                paginationInfo: Ce
                            }, Ke, !1, dn)
                    }
                    , !1)
                } catch {}
        }
    }), [S, o, u, g, l, c, s, m, p])
      , E = K( (q, re, U, pe, me=!1, ae=!1, X) => {
        let Ye = h.current;
        if (h.current = q,
        y.current = pe,
        w.current = re,
        b( () => {
            GS(U, me, ae)
        }
        ),
        ae) {
            Mt(g);
            return
        }
        m(Ce => {
            p(Ye, q, () => Mt(g), u, Ce)
        }
        , X)
    }
    , [u, g, b, m, p]);
    GM(h, E);
    let I = K(async (q, re, U, pe) => {
        var me, ae;
        let X = s[q];
        if (U) {
            let St = new Set
              , Hn = (me = X?.path) !== null && me !== void 0 ? me : "/";
            for (let ce of Hn.matchAll(Gi)) {
                let Yt = ce[1];
                if (Yt === void 0)
                    throw new Error("A matching path variable should not be undefined");
                St.add(Yt)
            }
            U = Object.fromEntries(Object.entries(U).filter( ([ce]) => St.has(ce)))
        }
        let Ye = Du(X, re)
          , Ce = y.current
          , Ke = w.current;
        if (oL({
            routeId: h.current,
            pathVariables: Ce
        }, {
            routeId: q,
            pathVariables: U
        })) {
            let St = s[q];
            ((ae = P.history.state) === null || ae === void 0 ? void 0 : ae.hash) !== re && !t && St && await MS(q, St, {
                currentRoutePath: St.path,
                currentPathVariables: Ce,
                pathVariables: U,
                hash: re,
                localeId: Ke,
                preserveQueryParams: c
            }, u),
            GS(Ye, pe, !1);
            return
        }
        if (!X)
            return;
        let Ee = s[h.current];
        E(q, Ke, Ye, U, pe, !1, t ? void 0 : async (St=!1) => MS(q, X, {
            currentRoutePath: Ee?.path,
            currentPathVariables: Ce,
            hash: re,
            pathVariables: U,
            localeId: Ke,
            preserveQueryParams: c
        }, !1, St))
    }
    , [s, E, t, c, u])
      , O = Tk(s)
      , B = h.current
      , z = y.current
      , j = se( () => ({
        navigate: I,
        getRoute: O,
        currentRouteId: B,
        currentPathVariables: z,
        routes: s,
        collectionUtils: o,
        preserveQueryParams: c
    }), [I, O, B, z, s, o, c])
      , J = s[h.current];
    if (!J)
        throw new Error(`Router cannot find route for ${h.current}`);
    let H = !S || !J.includedLocales || J.includedLocales.includes(S.id)
      , fe = J.path && z ? uk(J.path, z) : J.path
      , ie = String(C) + fe;
    return k(sL, {
        api: j,
        children: k(Rk.Provider, {
            value: T,
            children: he(Hm, {
                children: [k(fM, {
                    notFoundPage: i,
                    defaultPageStyle: e,
                    forceUpdateKey: v,
                    children: k(vL, {
                        LayoutTemplate: f,
                        routeId: B,
                        children: he(gn, {
                            children: [k(WS.Start, {}), H ? Sm(J.page, f ? {
                                ...e,
                                display: "content"
                            } : e) : i && Sm(i, e)]
                        }, ie)
                    })
                }), k(nL, {}), k(WS.End, {}), d]
            })
        })
    })
}
function vL({LayoutTemplate: e, routeId: t, children: n}) {
    return e ? k(e, {
        routeId: t,
        children: n
    }) : n
}
function yL(e, t) {
    let n = t ? {
        behavior: "smooth",
        block: "start",
        inline: "nearest"
    } : void 0;
    e.scrollIntoView(n)
}
var Yc, Zp, qS;
function bL(e) {
    if (qS !== e) {
        Yc = {};
        for (let[t,{path: n}] of Object.entries(e))
            n && (Yc[n] = {
                path: n,
                depth: xL(n),
                routeId: t
            });
        Zp = Object.values(Yc),
        Zp.sort( ({depth: t}, {depth: n}) => n - t),
        qS = e
    }
    return [Yc, Zp]
}
function Fk(e, t, n=!0, r=[]) {
    let[i,o] = bL(e), s, a, l = t;
    if (r.length > 0) {
        let d = l.split("/").find(Boolean);
        if (d && (s = r.find( ({slug: p}) => p === d),
        s && (a = s.id,
        l = l.substring(s.slug.length + 1))),
        !a) {
            let p = r.find( ({slug: v}) => v === "");
            p && (a = p.id)
        }
    }
    let c = i[l];
    if (c) {
        let d = XS(l, c.path);
        if (d.isMatch)
            return {
                routeId: c.routeId,
                localeId: a,
                pathVariables: d.pathVariables
            }
    }
    for (let {path: d, routeId: p} of o) {
        let v = XS(l, d);
        if (v.isMatch)
            return {
                routeId: p,
                localeId: a,
                pathVariables: v.pathVariables
            }
    }
    if (!n)
        throw new Error("No exact match found for path");
    let u = i["/"];
    if (u)
        return {
            routeId: u.routeId,
            localeId: a
        };
    let f = Object.keys(e)[0];
    if (!f)
        throw new Error("Router should not have undefined routes");
    return {
        routeId: f,
        localeId: a
    }
}
function xL(e) {
    let t = e.replace(/^\/|\/$/gu, "");
    return t === "" ? 0 : t.split("/").length
}
function XS(e, t) {
    let n = []
      , i = wL(t).replace(Gi, (c, u) => (n.push(u),
    "([^/]+)"))
      , o = new RegExp(i + "$")
      , s = e.match(o);
    if (!s)
        return {
            isMatch: !1
        };
    if (s.length === 1)
        return {
            isMatch: !0
        };
    let a = {}
      , l = s.slice(1);
    for (let c = 0; c < n.length; ++c) {
        let u = n[c];
        if (u === void 0)
            continue;
        let f = l[c]
          , d = a[u];
        if (d) {
            if (d !== f)
                return {
                    isMatch: !1
                };
            continue
        }
        if (f === void 0)
            throw new Error("Path variable values cannot be undefined");
        a[u] = f
    }
    return {
        isMatch: !0,
        pathVariables: a
    }
}
function wL(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d")
}
var SL = "page";
function YS(e) {
    return Ea(e) && SL in e && e.page !== void 0
}
var kL = ( () => x.createContext(void 0))();
function La() {
    var e;
    let t = Ki()
      , n = D(kL)
      , r = n ?? t.currentRouteId;
    if (!r)
        return;
    let i = (e = t.getRoute) === null || e === void 0 ? void 0 : e.call(t, r);
    if (i)
        return {
            ...i,
            id: r,
            pathVariables: n ? void 0 : t.currentPathVariables
        }
}
function CL(e) {
    var t;
    let n = Ki();
    if (e)
        return (t = n.getRoute) === null || t === void 0 ? void 0 : t.call(n, e)
}
var Wm = ( () => typeof P < "u" && !vM(Fe.userAgent))();
function TL(e, t=!0) {
    let {getRoute: n} = Ki();
    $( () => {
        if (!(!n || !t || !Wm))
            for (let r of e)
                Pk(n(r))
    }
    , [e, n, t])
}
async function Pk(e) {
    if (!Wm || !e)
        return;
    let t = e.page;
    if (!(!t || !hk(t))) {
        await pk();
        try {
            await t.preload()
        } catch {}
    }
}
function wj(e, t) {
    var n;
    let r = La()
      , i = (n = CL(t)) !== null && n !== void 0 ? n : r;
    return x.useMemo( () => i ? Du(i, e) : e, [e, i])
}
var KS = new Set;
function Fa(e, ...t) {
    KS.has(e) || (KS.add(e),
    console.warn(e, ...t))
}
function RL(e, t, n) {
    let r = n ? `, use ${n} instead` : ""
      , i = `Deprecation warning: ${e} will be removed in version ${t}${r}.`;
    Fa(i)
}
var _k = class {
    constructor() {
        R(this, "observers", new Set),
        R(this, "transactions", {})
    }
    add(e) {
        this.observers.add(e);
        let t = !1;
        return () => {
            t || (t = !0,
            this.remove(e))
        }
    }
    remove(e) {
        this.observers.delete(e)
    }
    notify(e, t) {
        if (t) {
            let n = this.transactions[t] || e;
            n.value = e.value,
            this.transactions[t] = n
        } else
            this.callObservers(e)
    }
    finishTransaction(e) {
        let t = this.transactions[e];
        return delete this.transactions[e],
        this.callObservers(t, e)
    }
    callObservers(e, t) {
        let n = [];
        return new Set(this.observers).forEach(r => {
            typeof r == "function" ? r(e, t) : (r.update(e, t),
            n.push(r.finish))
        }
        ),
        n
    }
}
  , at = ( () => {
    function e(t) {
        return RL("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)"),
        Nn(t) ? t : new FL(t)
    }
    return e.transaction = t => {
        let n = Math.random()
          , r = new Set;
        t( (s, a) => {
            s.set(a, n),
            r.add(s)
        }
        , n);
        let o = [];
        r.forEach(s => {
            o.push(...s.finishTransaction(n))
        }
        ),
        o.forEach(s => {
            s(n)
        }
        )
    }
    ,
    e.getNumber = (t, n=0) => e.get(t, n),
    e.get = (t, n) => t == null ? n : Nn(t) ? t.get() : t,
    e.objectToValues = t => {
        if (!t)
            return t;
        let n = {};
        for (let r in t) {
            let i = t[r];
            Nn(i) ? n[r] = i.get() : n[r] = i
        }
        return n
    }
    ,
    e
}
)()
  , QS = "onUpdate"
  , ZS = "finishTransaction";
function Nn(e) {
    return e !== null && typeof e == "object" && QS in e && e[QS]instanceof Function && ZS in e && e[ZS]instanceof Function
}
function EL(e, t) {
    return {
        interpolate(n, r) {
            let i = n.get()
              , o = r.get()
              , s = at(i);
            return a => {
                let l = t.interpolate(i, o)(a);
                return s.set(l),
                s
            }
        },
        difference(n, r) {
            let i = n.get();
            return t.difference(i, r.get())
        }
    }
}
var FL = class {
    constructor(e) {
        this.value = e,
        R(this, "observers", new _k)
    }
    static interpolationFor(e, t) {
        if (Nn(e))
            return EL(e, t)
    }
    get() {
        return this.value
    }
    set(e, t) {
        let n = this.value;
        Nn(e) && (e = e.get()),
        this.value = e;
        let r = {
            value: e,
            oldValue: n
        };
        this.observers.notify(r, t)
    }
    finishTransaction(e) {
        return this.observers.finishTransaction(e)
    }
    onUpdate(e) {
        return this.observers.add(e)
    }
}
;
function Kc(e, t) {
    let r = 10 ** Math.round(Math.abs(t));
    return Math.round(e * r) / r
}
function JS(e, t) {
    return t === 0 ? Math.round(e) : (t -= t | 0,
    t < 0 && (t = 1 - t),
    Math.round(e - t) + t)
}
function un(e, t) {
    return {
        x: e,
        y: t
    }
}
(e => {
    e.add = (...i) => i.reduce( (o, s) => ({
        x: o.x + s.x,
        y: o.y + s.y
    }), {
        x: 0,
        y: 0
    }),
    e.subtract = (i, o) => ({
        x: i.x - o.x,
        y: i.y - o.y
    }),
    e.multiply = (i, o) => ({
        x: i.x * o,
        y: i.y * o
    }),
    e.divide = (i, o) => ({
        x: i.x / o,
        y: i.y / o
    }),
    e.absolute = i => ({
        x: Math.abs(i.x),
        y: Math.abs(i.y)
    }),
    e.reverse = i => ({
        x: i.x * -1,
        y: i.y * -1
    }),
    e.pixelAligned = (i, o={
        x: 0,
        y: 0
    }) => ({
        x: JS(i.x, o.x),
        y: JS(i.y, o.y)
    }),
    e.distance = (i, o) => {
        let s = Math.abs(i.x - o.x)
          , a = Math.abs(i.y - o.y);
        return Math.sqrt(s * s + a * a)
    }
    ,
    e.angle = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI - 90,
    e.angleFromX = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI,
    e.isEqual = (i, o) => i.x === o.x && i.y === o.y,
    e.rotationNormalizer = () => {
        let i;
        return o => {
            typeof i != "number" && (i = o);
            let s = i - o
              , a = Math.abs(s) + 180
              , l = Math.floor(a / 360);
            return s < 180 && (o -= l * 360),
            s > 180 && (o += l * 360),
            i = o,
            o
        }
    }
    ;
    function t(i, o) {
        return {
            x: (i.x + o.x) / 2,
            y: (i.y + o.y) / 2
        }
    }
    e.center = t;
    function n(i) {
        let o = 0
          , s = 0;
        i.forEach(c => {
            o += c.x,
            s += c.y
        }
        );
        let a = o / i.length
          , l = s / i.length;
        return {
            x: a,
            y: l
        }
    }
    e.centroid = n;
    function r(i) {
        let o = e.centroid(i)
          , s = new Map;
        for (let a = 0; a < i.length; a++) {
            let l = i[a];
            s.set(l, Math.atan2(l.x - o.x, l.y - o.y))
        }
        return i.sort( (a, l) => s.get(a) - s.get(l))
    }
    e.sortClockwise = r
}
)(un || (un = {}));
var Cm = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};
function ui(e, t, n, r=!1) {
    let[i,o] = t
      , [s,a] = n
      , l = o - i;
    if (l === 0)
        return (a + s) / 2;
    let c = a - s;
    if (c === 0)
        return s;
    let u = s + (e - i) / l * c;
    if (r === !0)
        if (s < a) {
            if (u < s)
                return s;
            if (u > a)
                return a
        } else {
            if (u > s)
                return s;
            if (u < a)
                return a
        }
    return u
}
function Qo(e) {
    return !Number.isNaN(e) && Number.isFinite(e)
}
function fi(e) {
    let t = Tm(e);
    return t !== void 0 ? e.includes("%") ? t / 100 : t : 0
}
function Tm(e) {
    let t = /\d?\.?\d+/u.exec(e);
    return t ? Number(t[0]) : void 0
}
var PL = ( () => iM().Hsluv)()
  , Xt = new PL;
function _L(e, t, n) {
    return Xt.rgb_r = e / 255,
    Xt.rgb_g = t / 255,
    Xt.rgb_b = n / 255,
    Xt.rgbToHsluv(),
    {
        h: Xt.hsluv_h,
        s: Xt.hsluv_s,
        l: Xt.hsluv_l
    }
}
function IL(e, t, n, r=1) {
    return Xt.hsluv_h = e,
    Xt.hsluv_s = t,
    Xt.hsluv_l = n,
    Xt.hsluvToRgb(),
    {
        r: Xt.rgb_r * 255,
        g: Xt.rgb_g * 255,
        b: Xt.rgb_b * 255,
        a: r
    }
}
function Qc(e, t, n, r) {
    let i = Math.round(e)
      , o = Math.round(t * 100)
      , s = Math.round(n * 100);
    return r === void 0 || r === 1 ? "hsv(" + i + ", " + o + "%, " + s + "%)" : "hsva(" + i + ", " + o + "%, " + s + "%, " + r + ")"
}
function OL(e, t, n) {
    return {
        r: Qo(e) ? $t(e, 255) * 255 : 0,
        g: Qo(t) ? $t(t, 255) * 255 : 0,
        b: Qo(n) ? $t(n, 255) * 255 : 0
    }
}
function e1(e, t, n, r) {
    let i = [em(Math.round(e).toString(16)), em(Math.round(t).toString(16)), em(Math.round(n).toString(16))];
    return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}
function Um(e, t, n) {
    let r, i, o = $t(e, 255), s = $t(t, 255), a = $t(n, 255), l = Math.max(o, s, a), c = Math.min(o, s, a), u = i = r = (l + c) / 2;
    if (l === c)
        u = i = 0;
    else {
        let f = l - c;
        switch (i = r > .5 ? f / (2 - l - c) : f / (l + c),
        l) {
        case o:
            u = (s - a) / f + (s < a ? 6 : 0);
            break;
        case s:
            u = (a - o) / f + 2;
            break;
        case a:
            u = (o - s) / f + 4;
            break
        }
        u /= 6
    }
    return {
        h: u * 360,
        s: i,
        l: r
    }
}
function Jp(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function ML(e, t, n) {
    let r, i, o;
    if (e = $t(e, 360),
    t = $t(t * 100, 100),
    n = $t(n * 100, 100),
    t === 0)
        r = i = o = n;
    else {
        let s = n < .5 ? n * (1 + t) : n + t - n * t
          , a = 2 * n - s;
        r = Jp(a, s, e + 1 / 3),
        i = Jp(a, s, e),
        o = Jp(a, s, e - 1 / 3)
    }
    return {
        r: r * 255,
        g: i * 255,
        b: o * 255
    }
}
function t1(e, t, n) {
    e = $t(e, 255),
    t = $t(t, 255),
    n = $t(n, 255);
    let r = Math.max(e, t, n), i = Math.min(e, t, n), o = r - i, s, a = r === 0 ? 0 : o / r, l = r;
    if (r === i)
        s = 0;
    else {
        switch (r) {
        case e:
            s = (t - n) / o + (t < n ? 6 : 0);
            break;
        case t:
            s = (n - e) / o + 2;
            break;
        case n:
            s = (e - t) / o + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: a,
        v: l
    }
}
function LL(e, t, n) {
    e = $t(e, 360) * 6,
    t = $t(t * 100, 100),
    n = $t(n * 100, 100);
    let r = Math.floor(e)
      , i = e - r
      , o = n * (1 - t)
      , s = n * (1 - i * t)
      , a = n * (1 - (1 - i) * t)
      , l = r % 6
      , c = [n, s, o, o, a, n][l]
      , u = [a, n, n, s, o, o][l]
      , f = [o, o, a, n, n, s][l];
    return {
        r: c * 255,
        g: u * 255,
        b: f * 255
    }
}
function $t(e, t) {
    let n, r;
    if (typeof t == "string" ? n = parseFloat(t) : n = t,
    typeof e == "string") {
        VL(e) && (e = "100%");
        let i = AL(e);
        r = Math.min(n, Math.max(0, parseFloat(e))),
        i && (r = Math.floor(r * n) / 100)
    } else
        r = e;
    return Math.abs(r - n) < 1e-6 ? 1 : r % n / n
}
function VL(e) {
    return typeof e == "string" && e.includes(".") && parseFloat(e) === 1
}
function AL(e) {
    return typeof e == "string" && e.includes("%")
}
function em(e) {
    return e.length === 1 ? "0" + e : "" + e
}
var or = ( () => {
    let e = "[-\\+]?\\d+%?"
      , n = "(?:" + "[-\\+]?\\d*\\.\\d+%?" + ")|(?:" + e + ")"
      , r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?"
      , i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?";
    return {
        rgb: new RegExp("rgb" + r),
        rgba: new RegExp("rgba" + i),
        hsl: new RegExp("hsl" + r),
        hsla: new RegExp("hsla" + i),
        hsv: new RegExp("hsv" + r),
        hsva: new RegExp("hsva" + i),
        hex3: /^([\da-f])([\da-f])([\da-f])$/iu,
        hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu,
        hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu,
        hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu
    }
}
)();
function Gm(e) {
    if (e.includes("gradient(") || e.includes("var("))
        return !1;
    let t = /^[\s,#]+/u
      , n = e.replace(t, "").trimEnd().toLowerCase()
      , r = Cm[n];
    if (r && (n = r),
    n === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    let i;
    return (i = or.rgb.exec(n)) ? {
        r: parseInt(i[1] ?? ""),
        g: parseInt(i[2] ?? ""),
        b: parseInt(i[3] ?? ""),
        a: 1,
        format: "rgb"
    } : (i = or.rgba.exec(n)) ? {
        r: parseInt(i[1] ?? ""),
        g: parseInt(i[2] ?? ""),
        b: parseInt(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "rgb"
    } : (i = or.hsl.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: fi(i[2] ?? ""),
        l: fi(i[3] ?? ""),
        a: 1,
        format: "hsl"
    } : (i = or.hsla.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: fi(i[2] ?? ""),
        l: fi(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "hsl"
    } : (i = or.hsv.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: fi(i[2] ?? ""),
        v: fi(i[3] ?? ""),
        a: 1,
        format: "hsv"
    } : (i = or.hsva.exec(n)) ? {
        h: parseInt(i[1] ?? ""),
        s: fi(i[2] ?? ""),
        v: fi(i[3] ?? ""),
        a: parseFloat(i[4] ?? ""),
        format: "hsv"
    } : (i = or.hex8.exec(n)) ? {
        r: cn(i[1] ?? ""),
        g: cn(i[2] ?? ""),
        b: cn(i[3] ?? ""),
        a: n1(i[4] ?? ""),
        format: r ? "name" : "hex"
    } : (i = or.hex6.exec(n)) ? {
        r: cn(i[1] ?? ""),
        g: cn(i[2] ?? ""),
        b: cn(i[3] ?? ""),
        a: 1,
        format: r ? "name" : "hex"
    } : (i = or.hex4.exec(n)) ? {
        r: cn(`${i[1]}${i[1]}`),
        g: cn(`${i[2]}${i[2]}`),
        b: cn(`${i[3]}${i[3]}`),
        a: n1(i[4] + "" + i[4]),
        format: r ? "name" : "hex"
    } : (i = or.hex3.exec(n)) ? {
        r: cn(`${i[1]}${i[1]}`),
        g: cn(`${i[2]}${i[2]}`),
        b: cn(`${i[3]}${i[3]}`),
        a: 1,
        format: r ? "name" : "hex"
    } : !1
}
function cn(e) {
    return parseInt(e, 16)
}
function n1(e) {
    return cn(e) / 255
}
var r1 = new Map
  , Y = ( () => {
    function e(o, s, a, l) {
        if (typeof o == "string") {
            let u = r1.get(o);
            return u || (u = t(o),
            u === void 0 ? {
                ...e("black"),
                isValid: !1
            } : (r1.set(o, u),
            u))
        }
        let c = t(o, s, a, l);
        return c !== void 0 ? c : {
            ...e("black"),
            isValid: !1
        }
    }
    function t(o, s, a, l) {
        if (o === "")
            return;
        let c = DL(o, s, a, l);
        if (c) {
            let u = {
                r: c.r,
                g: c.g,
                b: c.b,
                a: c.a,
                h: c.h,
                s: c.s,
                l: c.l,
                initialValue: typeof o == "string" && c.format !== "hsv" ? o : void 0,
                roundA: Math.round(100 * c.a) / 100,
                format: c.format,
                mix: e.mix,
                toValue: () => e.toRgbString(u)
            };
            return u
        } else
            return
    }
    let n = {
        isRGB(o) {
            return o === "rgb" || o === "rgba"
        },
        isHSL(o) {
            return o === "hsl" || o === "hsla"
        }
    };
    e.inspect = (o, s) => o.format === "hsl" ? `<${o.constructor.name} h:${o.h} s:${o.s} l:${o.l} a:${o.a}>` : o.format === "hex" || o.format === "name" ? `<${o.constructor.name} "${s}">` : `<${o.constructor.name} r:${o.r} g:${o.g} b:${o.b} a:${o.a}>`,
    e.isColor = o => typeof o == "string" ? e.isColorString(o) : e.isColorObject(o),
    e.isColorString = o => typeof o == "string" ? Gm(o) !== !1 : !1,
    e.isColorObject = o => o && typeof o != "string" && typeof o.r == "number" && typeof o.g == "number" && typeof o.b == "number" && typeof o.h == "number" && typeof o.s == "number" && typeof o.l == "number" && typeof o.a == "number" && typeof o.roundA == "number" && typeof o.format == "string",
    e.toString = o => e.toRgbString(o),
    e.toHex = (o, s=!1) => e1(o.r, o.g, o.b, s),
    e.toHexString = (o, s=!1) => `#${e.toHex(o, s)}`,
    e.toRgbString = o => o.a === 1 ? "rgb(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ")" : "rgba(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ", " + o.roundA + ")",
    e.toHusl = o => ({
        ..._L(o.r, o.g, o.b),
        a: o.roundA
    }),
    e.toHslString = o => {
        let s = e.toHsl(o)
          , a = Math.round(s.h)
          , l = Math.round(s.s * 100)
          , c = Math.round(s.l * 100);
        return o.a === 1 ? "hsl(" + a + ", " + l + "%, " + c + "%)" : "hsla(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")"
    }
    ,
    e.toHsv = o => {
        let s = t1(o.r, o.g, o.b);
        return {
            h: s.h * 360,
            s: s.s,
            v: s.v,
            a: o.a
        }
    }
    ,
    e.toHsvString = o => {
        let s = t1(o.r, o.g, o.b)
          , a = Math.round(s.h * 360)
          , l = Math.round(s.s * 100)
          , c = Math.round(s.v * 100);
        return o.a === 1 ? "hsv(" + a + ", " + l + "%, " + c + "%)" : "hsva(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")"
    }
    ,
    e.toName = o => {
        if (o.a === 0)
            return "transparent";
        if (o.a < 1)
            return !1;
        let s = e1(o.r, o.g, o.b, !0);
        for (let a of Object.keys(Cm))
            if (Cm[a] === s)
                return a;
        return !1
    }
    ,
    e.toHsl = o => ({
        h: Math.round(o.h),
        s: o.s,
        l: o.l,
        a: o.a
    }),
    e.toRgb = o => ({
        r: Math.round(o.r),
        g: Math.round(o.g),
        b: Math.round(o.b),
        a: o.a
    }),
    e.brighten = (o, s=10) => {
        let a = e.toRgb(o);
        return a.r = Math.max(0, Math.min(255, a.r - Math.round(255 * -(s / 100)))),
        a.g = Math.max(0, Math.min(255, a.g - Math.round(255 * -(s / 100)))),
        a.b = Math.max(0, Math.min(255, a.b - Math.round(255 * -(s / 100)))),
        e(a)
    }
    ,
    e.lighten = (o, s=10) => {
        let a = e.toHsl(o);
        return a.l += s / 100,
        a.l = Math.min(1, Math.max(0, a.l)),
        e(a)
    }
    ,
    e.darken = (o, s=10) => {
        let a = e.toHsl(o);
        return a.l -= s / 100,
        a.l = Math.min(1, Math.max(0, a.l)),
        e(a)
    }
    ,
    e.saturate = (o, s=10) => {
        let a = e.toHsl(o);
        return a.s += s / 100,
        a.s = Math.min(1, Math.max(0, a.s)),
        e(a)
    }
    ,
    e.desaturate = (o, s=10) => {
        let a = e.toHsl(o);
        return a.s -= s / 100,
        a.s = Math.min(1, Math.max(0, a.s)),
        e(a)
    }
    ,
    e.grayscale = o => e.desaturate(o, 100),
    e.hueRotate = (o, s) => {
        let a = e.toHsl(o);
        return a.h += s,
        a.h = a.h > 360 ? a.h - 360 : a.h,
        e(a)
    }
    ,
    e.alpha = (o, s=1) => e({
        r: o.r,
        g: o.g,
        b: o.b,
        a: s
    }),
    e.transparent = o => e.alpha(o, 0),
    e.multiplyAlpha = (o, s=1) => e({
        r: o.r,
        g: o.g,
        b: o.b,
        a: o.a * s
    }),
    e.interpolate = (o, s, a="rgb") => {
        if (!e.isColorObject(o) || !e.isColorObject(s))
            throw new TypeError("Both arguments for Color.interpolate must be Color objects");
        return l => e.mixAsColor(o, s, l, !1, a)
    }
    ,
    e.mix = (o, s, {model: a="rgb"}={}) => {
        let l = typeof o == "string" ? e(o) : o
          , c = e.interpolate(l, s, a);
        return u => e.toRgbString(c(u))
    }
    ,
    e.mixAsColor = (o, s, a=.5, l=!1, c="rgb") => {
        let u = null;
        if (n.isRGB(c))
            u = e({
                r: ui(a, [0, 1], [o.r, s.r], l),
                g: ui(a, [0, 1], [o.g, s.g], l),
                b: ui(a, [0, 1], [o.b, s.b], l),
                a: ui(a, [0, 1], [o.a, s.a], l)
            });
        else {
            let f, d;
            n.isHSL(c) ? (f = e.toHsl(o),
            d = e.toHsl(s)) : (f = e.toHusl(o),
            d = e.toHusl(s)),
            f.s === 0 ? f.h = d.h : d.s === 0 && (d.h = f.h);
            let p = f.h
              , v = d.h
              , g = v - p;
            g > 180 ? g = v - 360 - p : g < -180 && (g = v + 360 - p);
            let b = {
                h: ui(a, [0, 1], [p, p + g], l),
                s: ui(a, [0, 1], [f.s, d.s], l),
                l: ui(a, [0, 1], [f.l, d.l], l),
                a: ui(a, [0, 1], [o.a, s.a], l)
            };
            n.isHSL(c) ? u = e(b) : u = e(IL(b.h, b.s, b.l, b.a))
        }
        return u
    }
    ,
    e.random = (o=1) => {
        function s() {
            return Math.floor(Math.random() * 255)
        }
        return e("rgba(" + s() + ", " + s() + ", " + s() + ", " + o + ")")
    }
    ,
    e.grey = (o=.5, s=1) => (o = Math.floor(o * 255),
    e("rgba(" + o + ", " + o + ", " + o + ", " + s + ")")),
    e.gray = e.grey,
    e.rgbToHsl = (o, s, a) => Um(o, s, a),
    e.isValidColorProperty = (o, s) => !!((o.toLowerCase().slice(-5) === "color" || o === "fill" || o === "stroke") && typeof s == "string" && e.isColorString(s)),
    e.difference = (o, s) => {
        let a = (o.r + s.r) / 2
          , l = o.r - s.r
          , c = o.g - s.g
          , u = o.b - s.b
          , f = Math.pow(l, 2)
          , d = Math.pow(c, 2)
          , p = Math.pow(u, 2);
        return Math.sqrt(2 * f + 4 * d + 3 * p + a * (f - p) / 256)
    }
    ,
    e.equal = (o, s, a=.1) => !(Math.abs(o.r - s.r) >= a || Math.abs(o.g - s.g) >= a || Math.abs(o.b - s.b) >= a || Math.abs(o.a - s.a) * 256 >= a);
    let r = ho([0, 255], [0, 1]);
    function i(o) {
        o = r(o);
        let s = Math.abs(o);
        return s < .04045 ? o / 12.92 : (Math.sign(o) || 1) * Math.pow((s + .055) / 1.055, 2.4)
    }
    return e.luminance = o => {
        let {r: s, g: a, b: l} = e.toRgb(o);
        return .2126 * i(s) + .7152 * i(a) + .0722 * i(l)
    }
    ,
    e.contrast = (o, s) => {
        let a = e.luminance(o)
          , l = e.luminance(s);
        return (Math.max(a, l) + .05) / (Math.min(a, l) + .05)
    }
    ,
    e
}
)();
function DL(e, t, n, r=1) {
    let i;
    return typeof e == "number" && !Number.isNaN(e) && typeof t == "number" && !Number.isNaN(t) && typeof n == "number" && !Number.isNaN(n) ? i = Rm({
        r: e,
        g: t,
        b: n,
        a: r
    }) : typeof e == "string" ? i = zL(e) : typeof e == "object" && (e.hasOwnProperty("r") && e.hasOwnProperty("g") && e.hasOwnProperty("b") ? i = Rm(e) : i = Ik(e)),
    i
}
function zL(e) {
    let t = Gm(e);
    if (t)
        return t.format === "hsl" ? Ik(t) : t.format === "hsv" ? BL(t) : Rm(t)
}
function BL(e) {
    let t = LL(e.h, e.s, e.v);
    return {
        ...Um(t.r, t.g, t.b),
        ...t,
        format: "rgb",
        a: e.a !== void 0 ? Ok(e.a) : 1
    }
}
function Rm(e) {
    let t = OL(e.r, e.g, e.b);
    return {
        ...Um(t.r, t.g, t.b),
        ...t,
        format: "rgb",
        a: e.a !== void 0 ? Ok(e.a) : 1
    }
}
function Ik(e) {
    let t, n, r, i = {
        r: 0,
        g: 0,
        b: 0
    }, o = {
        h: 0,
        s: 0,
        l: 0
    };
    return t = Qo(e.h) ? e.h : 0,
    t = (t + 360) % 360,
    n = Qo(e.s) ? e.s : 1,
    typeof e.s == "string" && (n = Tm(e.s)),
    r = Qo(e.l) ? e.l : .5,
    typeof e.l == "string" && (r = Tm(e.l)),
    i = ML(t, n, r),
    o = {
        h: t,
        s: n,
        l: r
    },
    {
        ...i,
        ...o,
        a: e.a === void 0 ? 1 : e.a,
        format: "hsl"
    }
}
function Ok(e) {
    return e = parseFloat(e),
    e < 0 && (e = 0),
    (Number.isNaN(e) || e > 1) && (e = 1),
    e
}
var i1 = e => e instanceof gl;
var $L = ( () => oM().EventEmitter)()
  , NL = class {
    constructor() {
        R(this, "_emitter", new $L)
    }
    eventNames() {
        return this._emitter.eventNames()
    }
    eventListeners() {
        let e = {};
        for (let t of this._emitter.eventNames())
            e[t] = this._emitter.listeners(t);
        return e
    }
    on(e, t) {
        this.addEventListener(e, t, !1, !1, this)
    }
    off(e, t) {
        this.removeEventListeners(e, t)
    }
    once(e, t) {
        this.addEventListener(e, t, !0, !1, this)
    }
    unique(e, t) {
        this.addEventListener(e, t, !1, !0, this)
    }
    addEventListener(e, t, n, r, i) {
        if (r) {
            for (let o of this._emitter.eventNames())
                if (t === this._emitter.listeners(o))
                    return
        }
        n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i)
    }
    removeEventListeners(e, t) {
        e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners()
    }
    removeAllEventListeners() {
        this._emitter.removeAllListeners()
    }
    countEventListeners(e, t) {
        if (e)
            return this._emitter.listeners(e).length;
        {
            let n = 0;
            for (let r of this._emitter.eventNames())
                n += this._emitter.listeners(r).length;
            return n
        }
    }
    emit(e, ...t) {
        this._emitter.emit(e, ...t)
    }
}
  , jL = {
    addEventListener: () => {}
    ,
    removeEventListener: () => {}
    ,
    dispatchEvent: () => !1,
    ResizeObserver: void 0,
    onpointerdown: !1,
    onpointermove: !1,
    onpointerup: !1,
    ontouchstart: !1,
    ontouchmove: !1,
    ontouchend: !1,
    onmousedown: !1,
    onmousemove: !1,
    onmouseup: !1,
    devicePixelRatio: 1,
    scrollX: 0,
    scrollY: 0,
    location: {
        href: "",
        pathname: ""
    },
    document: {
        cookie: ""
    },
    setTimeout: () => 0,
    clearTimeout: () => {}
    ,
    setInterval: () => 0,
    clearInterval: () => {}
    ,
    requestAnimationFrame: () => 0,
    cancelAnimationFrame: () => {}
    ,
    requestIdleCallback: () => 0,
    getSelection: () => null,
    matchMedia: e => ({
        matches: !1,
        media: e,
        onchange: () => {}
        ,
        addEventListener: () => {}
        ,
        removeEventListener: () => {}
        ,
        addListener: () => {}
        ,
        removeListener: () => {}
        ,
        dispatchEvent: () => !1
    }),
    innerHeight: 0,
    innerWidth: 0,
    SVGSVGElement: {},
    open: function(e, t, n) {},
    __framer_events: []
}
  , nt = typeof P > "u" ? jL : P
  , HL = e => {
    setTimeout(e, 1 / 60)
}
  , WL = ( () => nt.requestAnimationFrame || HL)()
  , o1 = e => WL(e)
  , ya = ( () => 1 / 60)()
  , UL = class extends NL {
    constructor(e=!1) {
        super(),
        R(this, "_started", !1),
        R(this, "_frame", 0),
        R(this, "_frameTasks", []),
        R(this, "tick", () => {
            this._started && (o1(this.tick),
            this.emit("update", this._frame, ya),
            this.emit("render", this._frame, ya),
            this._processFrameTasks(),
            this._frame++)
        }
        ),
        e && this.start()
    }
    addFrameTask(e) {
        this._frameTasks.push(e)
    }
    _processFrameTasks() {
        var e;
        let t = this._frameTasks
          , n = t.length;
        if (n !== 0) {
            for (let r = 0; r < n; r++)
                (e = t[r]) == null || e.call(t);
            t.length = 0
        }
    }
    static set TimeStep(e) {
        ya = e
    }
    static get TimeStep() {
        return ya
    }
    start() {
        return this._started ? this : (this._frame = 0,
        this._started = !0,
        o1(this.tick),
        this)
    }
    stop() {
        return this._started = !1,
        this
    }
    get frame() {
        return this._frame
    }
    get time() {
        return this._frame * ya
    }
}
  , Mk = new UL
  , Em = {
    target: "PREVIEW",
    zoom: 1
};
var ue = {
    canvas: "CANVAS",
    export: "EXPORT",
    thumbnail: "THUMBNAIL",
    preview: "PREVIEW",
    current: () => Em.target,
    hasRestrictions: () => {
        let e = Em.target;
        return e === "CANVAS" || e === "EXPORT"
    }
};
var Zc = e => ({
    correct: (t, {delta: n, treeScale: r}) => {
        if (typeof t == "string" && (t = parseFloat(t)),
        t === 0)
            return "0px";
        let i = t;
        return n && r && (i = Math.round(t / n[e].scale / r[e]),
        i = Math.max(i, 1)),
        i + "px"
    }
});
vd({
    borderTopWidth: Zc("y"),
    borderLeftWidth: Zc("x"),
    borderRightWidth: Zc("x"),
    borderBottomWidth: Zc("y")
});
function A(e, ...t) {
    var n, r;
    if (e)
        return;
    let i = Error("Assertion Error" + (t.length > 0 ? ": " + t.join(" ") : ""));
    if (i.stack)
        try {
            let o = i.stack.split(`
`);
            (n = o[1]) != null && n.includes("assert") ? (o.splice(1, 1),
            i.stack = o.join(`
`)) : (r = o[0]) != null && r.includes("assert") && (o.splice(0, 1),
            i.stack = o.join(`
`))
        } catch {}
    throw i
}
function ke(e, t) {
    throw t || new Error(e ? `Unexpected value: ${e}` : "Application entered invalid state")
}
var Zo = x.createContext({
    getLayoutId: e => null,
    persistLayoutIdCache: () => {}
    ,
    top: !1,
    enabled: !0
});
function GL({children: e}) {
    if (D(Zo).top)
        return k(it, {
            children: e
        });
    let n = V({
        byId: {},
        byName: {},
        byLastId: {},
        byPossibleId: {},
        byLastName: {},
        byLayoutId: {},
        count: {
            byId: {},
            byName: {}
        }
    })
      , r = V({
        byId: {},
        byName: {},
        byLastId: {},
        byPossibleId: {},
        byLastName: {},
        byLayoutId: {}
    })
      , i = V(new Set).current
      , o = K( ({id: l, name: c, duplicatedFrom: u}) => {
        if (!l)
            return null;
        let f = c ? "byName" : "byId"
          , d = n.current[f][l];
        if (d)
            return d;
        let p = c || l;
        if (!u && !i.has(p) && (!n.current.byLayoutId[p] || n.current.byLayoutId[p] === p))
            return n.current.count[f][p] === void 0 && (n.current.count[f][p] = 0,
            n.current.byLayoutId[p] = p,
            r.current[f][l] = p),
            i.add(p),
            p;
        let v;
        if (u?.length)
            for (let S = u.length - 1; S >= 0; S--) {
                let T = u[S];
                A(!!T, "duplicatedId must be defined");
                let E = n.current[f][T]
                  , I = n.current.byLastId[T];
                if (I && !v) {
                    let z = n.current.byLayoutId[I]
                      , j = !z || z === c;
                    I && !i.has(I) && (!c || j) && (v = [I, T])
                }
                let O = E ? n.current.byLayoutId[E] : void 0
                  , B = !O || O === c;
                if (E && !i.has(E) && (!c || B))
                    return r.current[f][l] = E,
                    r.current.byLastId[T] = E,
                    i.add(E),
                    E
            }
        let g = n.current.byLastId[l];
        if (g && !i.has(g))
            return i.add(g),
            r.current.byId[l] = g,
            g;
        if (v) {
            let[S,T] = v;
            return r.current[f][l] = S,
            r.current.byLastId[T] = S,
            i.add(S),
            S
        }
        let b = n.current.byPossibleId[l];
        if (b && !i.has(b))
            return i.add(b),
            r.current.byId[l] = b,
            b;
        let m = u?.[0]
          , h = c || m || l
          , y = (n.current.count[f][h] ?? -1) + 1
          , {layoutId: w, value: C} = qL(h, y, i);
        if (n.current.count[f][h] = C,
        r.current[f][l] = w,
        u?.length && !c) {
            let S = u[u.length - 1];
            if (S && (r.current.byLastId[S] = w),
            u.length > 1)
                for (let T = 0; T < u.length - 1; T++) {
                    let E = u[T];
                    E !== void 0 && (r.current.byPossibleId[E] || (r.current.byPossibleId[E] = w))
                }
        }
        return r.current.byLayoutId[w] = p,
        i.add(w),
        w
    }
    , [])
      , s = K( () => {
        n.current = {
            byId: {
                ...n.current.byId,
                ...r.current.byId
            },
            byLastId: {
                ...n.current.byLastId,
                ...r.current.byLastId
            },
            byPossibleId: {
                ...n.current.byPossibleId,
                ...r.current.byPossibleId
            },
            byName: {
                ...n.current.byName,
                ...r.current.byName
            },
            byLastName: {
                ...n.current.byLastName,
                ...r.current.byLastName
            },
            byLayoutId: {
                ...n.current.byLayoutId,
                ...r.current.byLayoutId
            },
            count: {
                ...n.current.count,
                byName: {}
            }
        },
        r.current = {
            byId: {},
            byName: {},
            byLastId: {},
            byPossibleId: {},
            byLastName: {},
            byLayoutId: {}
        },
        i.clear()
    }
    , [])
      , a = V({
        getLayoutId: o,
        persistLayoutIdCache: s,
        top: !0,
        enabled: !0
    }).current;
    return k(Zo.Provider, {
        value: a,
        children: e
    })
}
function qL(e, t, n) {
    let r = t
      , i = r ? `${e}-${r}` : e;
    for (; n.has(i); )
        r++,
        i = `${e}-${r}`;
    return {
        layoutId: i,
        value: r
    }
}
function XL({enabled: e=!0, ...t}) {
    let n = D(Zo)
      , r = se( () => ({
        ...n,
        enabled: e
    }), [e]);
    return k(Zo.Provider, {
        ...t,
        value: r
    })
}
function mt(e) {
    let t = V(null);
    return t.current === null && (t.current = e()),
    t.current
}
var YL = {
    background: void 0,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    lineHeight: "1.4em",
    textOverflow: "ellipsis",
    overflow: "hidden",
    minHeight: 0,
    width: "100%",
    height: "100%"
}
  , KL = ( () => ({
    ...YL,
    border: "1px solid rgba(149, 149, 149, 0.15)",
    borderRadius: 6,
    fontSize: "12px",
    backgroundColor: "rgba(149, 149, 149, 0.1)",
    color: "#a5a5a5"
}))()
  , Lk = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    maxWidth: "100%",
    flexShrink: 0,
    padding: "0 10px"
}
  , QL = ( () => ({
    ...Lk,
    fontWeight: 500
}))()
  , ZL = ( () => ({
    ...Lk,
    whiteSpace: "pre",
    maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))",
    WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)"
}))();
function Pj(e) {
    let {error: t, file: n} = e
      , r = n ? `Error in ${JL(n)}` : "Error"
      , i = t instanceof Error ? t.message : "" + t;
    return he("div", {
        style: KL,
        children: [k("div", {
            className: "text",
            style: QL,
            children: r
        }), i && k("div", {
            className: "text",
            style: ZL,
            children: i
        })]
    })
}
function JL(e) {
    return e.startsWith("./") ? e.replace("./", "") : e
}
function ne(e) {
    return Number.isFinite(e)
}
function eV(e) {
    return !e || !Object.keys(e).length && e.constructor === Object
}
function su(e) {
    return typeof e != "string" && typeof e != "number"
}
function au(e) {
    return e !== null && typeof e < "u" && typeof e != "boolean" && !eV(e)
}
function tV(e) {
    return e * (Math.PI / 180)
}
var En = ( () => {
    function e(t, n) {
        return {
            a: t,
            b: n
        }
    }
    return e.offset = (t, n) => {
        let r = un.angleFromX(t.a, t.b)
          , i = tV(r)
          , o = n * Math.sin(i)
          , s = n * Math.cos(i);
        return e({
            x: t.a.x + o,
            y: t.a.y - s
        }, {
            x: t.b.x + o,
            y: t.b.y - s
        })
    }
    ,
    e.intersection = (t, n, r) => {
        let i = t.a.x
          , o = t.a.y
          , s = t.b.x
          , a = t.b.y
          , l = n.a.x
          , c = n.a.y
          , u = n.b.x
          , f = n.b.y
          , d = (u - l) * (c - o) - (f - c) * (l - i)
          , p = (u - l) * (a - o) - (f - c) * (s - i)
          , v = (s - i) * (c - o) - (a - o) * (l - i);
        if (d === 0 && p === 0 || p === 0)
            return null;
        let g = d / p
          , b = v / p;
        return r && (g < 0 || g > 1 || b < 0 || b > 1) ? null : {
            x: i + g * (s - i),
            y: o + g * (a - o)
        }
    }
    ,
    e.intersectionAngle = (t, n) => {
        let r = t.b.x - t.a.x
          , i = t.b.y - t.a.y
          , o = n.b.x - n.a.x
          , s = n.b.y - n.a.y;
        return Math.atan2(r * s - i * o, r * o + i * s) * (180 / Math.PI)
    }
    ,
    e.isOrthogonal = t => t.a.x === t.b.x || t.a.y === t.b.y,
    e.perpendicular = (t, n) => {
        let r = t.a.x - t.b.x
          , i = t.a.y - t.b.y
          , o = un(n.x - i, n.y + r);
        return e(o, n)
    }
    ,
    e.projectPoint = (t, n) => {
        let r = e.perpendicular(t, n);
        return e.intersection(t, r)
    }
    ,
    e.pointAtPercentDistance = (t, n) => {
        let r = e.distance(t)
          , i = n * r / r;
        return {
            x: i * t.b.x + (1 - i) * t.a.x,
            y: i * t.b.y + (1 - i) * t.a.y
        }
    }
    ,
    e.distance = t => un.distance(t.a, t.b),
    e
}
)()
  , te = {
    equals: function(e, t) {
        return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
    },
    atOrigin: e => ({
        ...e,
        x: 0,
        y: 0
    }),
    fromTwoPoints: (e, t) => ({
        x: Math.min(e.x, t.x),
        y: Math.min(e.y, t.y),
        width: Math.abs(e.x - t.x),
        height: Math.abs(e.y - t.y)
    }),
    fromRect: e => ({
        x: e.left,
        y: e.top,
        width: e.right - e.left,
        height: e.bottom - e.top
    }),
    multiply: (e, t) => ({
        x: e.x * t,
        y: e.y * t,
        width: e.width * t,
        height: e.height * t
    }),
    divide: (e, t) => te.multiply(e, 1 / t),
    offset: (e, t) => {
        let n = typeof t.x == "number" ? t.x : 0
          , r = typeof t.y == "number" ? t.y : 0;
        return {
            ...e,
            x: e.x + n,
            y: e.y + r
        }
    }
    ,
    inflate: (e, t) => {
        if (t === 0)
            return e;
        let n = 2 * t;
        return {
            x: e.x - t,
            y: e.y - t,
            width: e.width + n,
            height: e.height + n
        }
    }
    ,
    pixelAligned: e => {
        let t = Math.round(e.x)
          , n = Math.round(e.y)
          , r = Math.round(e.x + e.width)
          , i = Math.round(e.y + e.height)
          , o = Math.max(r - t, 0)
          , s = Math.max(i - n, 0);
        return {
            x: t,
            y: n,
            width: o,
            height: s
        }
    }
    ,
    halfPixelAligned: e => {
        let t = Math.round(e.x * 2) / 2
          , n = Math.round(e.y * 2) / 2
          , r = Math.round((e.x + e.width) * 2) / 2
          , i = Math.round((e.y + e.height) * 2) / 2
          , o = Math.max(r - t, 1)
          , s = Math.max(i - n, 1);
        return {
            x: t,
            y: n,
            width: o,
            height: s
        }
    }
    ,
    round: (e, t=0) => {
        let n = Kc(e.x, t)
          , r = Kc(e.y, t)
          , i = Kc(e.width, t)
          , o = Kc(e.height, t);
        return {
            x: n,
            y: r,
            width: i,
            height: o
        }
    }
    ,
    roundToOutside: e => {
        let t = Math.floor(e.x)
          , n = Math.floor(e.y)
          , r = Math.ceil(e.x + e.width)
          , i = Math.ceil(e.y + e.height)
          , o = Math.max(r - t, 0)
          , s = Math.max(i - n, 0);
        return {
            x: t,
            y: n,
            width: o,
            height: s
        }
    }
    ,
    minX: e => e.x,
    maxX: e => e.x + e.width,
    minY: e => e.y,
    maxY: e => e.y + e.height,
    positions: e => ({
        minX: e.x,
        midX: e.x + e.width / 2,
        maxX: te.maxX(e),
        minY: e.y,
        midY: e.y + e.height / 2,
        maxY: te.maxY(e)
    }),
    center: e => ({
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
    }),
    boundingRectFromPoints: e => {
        let t = 1 / 0
          , n = -1 / 0
          , r = 1 / 0
          , i = -1 / 0;
        for (let o = 0; o < e.length; o++) {
            let s = e[o];
            t = Math.min(t, s.x),
            n = Math.max(n, s.x),
            r = Math.min(r, s.y),
            i = Math.max(i, s.y)
        }
        return {
            x: t,
            y: r,
            width: n - t,
            height: i - r
        }
    }
    ,
    fromPoints: e => {
        let[t,n,r,i] = e
          , {x: o, y: s} = t
          , a = un.distance(t, n)
          , l = un.distance(t, i);
        return {
            x: o,
            y: s,
            width: a,
            height: l
        }
    }
    ,
    merge: (...e) => {
        let t = {
            x: Math.min(...e.map(te.minX)),
            y: Math.min(...e.map(te.minY))
        }
          , n = {
            x: Math.max(...e.map(te.maxX)),
            y: Math.max(...e.map(te.maxY))
        };
        return te.fromTwoPoints(t, n)
    }
    ,
    intersection: (e, t) => {
        let n = Math.max(e.x, t.x)
          , r = Math.min(e.x + e.width, t.x + t.width)
          , i = Math.max(e.y, t.y)
          , o = Math.min(e.y + e.height, t.y + t.height);
        return {
            x: n,
            y: i,
            width: r - n,
            height: o - i
        }
    }
    ,
    points: e => [{
        x: te.minX(e),
        y: te.minY(e)
    }, {
        x: te.minX(e),
        y: te.maxY(e)
    }, {
        x: te.maxX(e),
        y: te.minY(e)
    }, {
        x: te.maxX(e),
        y: te.maxY(e)
    }],
    pointsAtOrigin: e => [{
        x: 0,
        y: 0
    }, {
        x: e.width,
        y: 0
    }, {
        x: e.width,
        y: e.height
    }, {
        x: 0,
        y: e.height
    }],
    transform: (e, t) => {
        let {x: n, y: r} = t.transformPoint({
            x: e.x,
            y: e.y
        })
          , {x: i, y: o} = t.transformPoint({
            x: e.x + e.width,
            y: e.y
        })
          , {x: s, y: a} = t.transformPoint({
            x: e.x + e.width,
            y: e.y + e.height
        })
          , {x: l, y: c} = t.transformPoint({
            x: e.x,
            y: e.y + e.height
        })
          , u = Math.min(n, i, s, l)
          , f = Math.max(n, i, s, l) - u
          , d = Math.min(r, o, a, c)
          , p = Math.max(r, o, a, c) - d;
        return {
            x: u,
            y: d,
            width: f,
            height: p
        }
    }
    ,
    containsPoint: (e, t) => !(t.x < te.minX(e) || t.x > te.maxX(e) || t.y < te.minY(e) || t.y > te.maxY(e) || Number.isNaN(e.x) || Number.isNaN(e.y)),
    containsRect: (e, t) => {
        for (let n of te.points(t))
            if (!te.containsPoint(e, n))
                return !1;
        return !0
    }
    ,
    toCSS: e => ({
        display: "block",
        transform: `translate(${e.x}px, ${e.y}px)`,
        width: `${e.width}px`,
        height: `${e.height}px`
    }),
    inset: (e, t) => ({
        x: e.x + t,
        y: e.y + t,
        width: Math.max(0, e.width - 2 * t),
        height: Math.max(0, e.height - 2 * t)
    }),
    intersects: (e, t) => !(t.x >= te.maxX(e) || te.maxX(t) <= e.x || t.y >= te.maxY(e) || te.maxY(t) <= e.y),
    overlapHorizontally: (e, t) => {
        let n = te.maxX(e)
          , r = te.maxX(t);
        return n > t.x && r > e.x
    }
    ,
    overlapVertically: (e, t) => {
        let n = te.maxY(e)
          , r = te.maxY(t);
        return n > t.y && r > e.y
    }
    ,
    doesNotIntersect: (e, t) => t.find(n => te.intersects(n, e)) === void 0,
    isEqual: (e, t) => te.equals(e, t),
    cornerPoints: e => {
        let t = e.x
          , n = e.x + e.width
          , r = e.y
          , i = e.y + e.height;
        return [{
            x: t,
            y: r
        }, {
            x: n,
            y: r
        }, {
            x: n,
            y: i
        }, {
            x: t,
            y: i
        }]
    }
    ,
    midPoints: e => {
        let t = e.x
          , n = e.x + e.width / 2
          , r = e.x + e.width
          , i = e.y
          , o = e.y + e.height / 2
          , s = e.y + e.height;
        return [{
            x: n,
            y: i
        }, {
            x: r,
            y: o
        }, {
            x: n,
            y: s
        }, {
            x: t,
            y: o
        }]
    }
    ,
    pointDistance: (e, t) => {
        let n = 0
          , r = 0;
        return t.x < e.x ? n = e.x - t.x : t.x > te.maxX(e) && (n = t.x - te.maxX(e)),
        t.y < e.y ? r = e.y - t.y : t.y > te.maxY(e) && (r = t.y - te.maxY(e)),
        un.distance({
            x: n,
            y: r
        }, {
            x: 0,
            y: 0
        })
    }
    ,
    fromAny: (e, t={
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }) => ({
        x: e.x || t.x,
        y: e.y || t.y,
        width: e.width || t.width,
        height: e.height || t.height
    }),
    delta: (e, t) => {
        let n = {
            x: te.minX(e),
            y: te.minY(e)
        }
          , r = {
            x: te.minX(t),
            y: te.minY(t)
        };
        return {
            x: n.x - r.x,
            y: n.y - r.y
        }
    }
    ,
    withMinSize: (e, t) => {
        let {width: n, height: r} = t
          , i = e.width - n
          , o = e.height - r;
        return {
            width: Math.max(e.width, n),
            height: Math.max(e.height, r),
            x: e.width < n ? e.x + i / 2 : e.x,
            y: e.height < r ? e.y + o / 2 : e.y
        }
    }
    ,
    anyPointsOutsideRect: (e, t) => {
        let n = te.minX(e)
          , r = te.minY(e)
          , i = te.maxX(e)
          , o = te.maxY(e);
        for (let s of t)
            if (s.x < n || s.x > i || s.y < r || s.y > o)
                return !0;
        return !1
    }
    ,
    edges: e => {
        let[t,n,r,i] = te.cornerPoints(e);
        return [En(t, n), En(n, r), En(r, i), En(i, t)]
    }
    ,
    rebaseRectOnto: (e, t, n, r) => {
        let i = {
            ...e
        };
        switch (n) {
        case "bottom":
        case "top":
            switch (r) {
            case "start":
                i.x = t.x;
                break;
            case "center":
                i.x = t.x + t.width / 2 - e.width / 2;
                break;
            case "end":
                i.x = t.x + t.width - e.width;
                break;
            default:
                ke(r)
            }
            break;
        case "left":
            i.x = t.x - e.width;
            break;
        case "right":
            i.x = t.x + t.width;
            break;
        default:
            ke(n)
        }
        switch (n) {
        case "left":
        case "right":
            switch (r) {
            case "start":
                i.y = t.y;
                break;
            case "center":
                i.y = t.y + t.height / 2 - e.height / 2;
                break;
            case "end":
                i.y = t.y + t.height - e.height;
                break;
            default:
                ke(r)
            }
            break;
        case "top":
            i.y = t.y - e.height;
            break;
        case "bottom":
            i.y = t.y + t.height;
            break;
        default:
            ke(n)
        }
        return i
    }
};
var Vk = {
    quickfix: e => ((e.widthType === 2 || e.heightType === 2) && (e.aspectRatio = null),
    ne(e.aspectRatio) && (e.left && e.right && (e.widthType = 0),
    e.top && e.bottom && (e.heightType = 0),
    e.left && e.right && e.top && e.bottom && (e.bottom = !1),
    e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)),
    e.left && e.right && ((e.fixedSize || e.widthType === 2 || ne(e.maxWidth)) && (e.right = !1),
    e.widthType = 0),
    e.top && e.bottom && ((e.fixedSize || e.heightType === 2 || ne(e.maxHeight)) && (e.bottom = !1),
    e.heightType = 0),
    e)
};
function gu(e) {
    if (typeof e == "string") {
        let t = e.trim();
        if (t === "auto")
            return 2;
        if (t.endsWith("fr"))
            return 3;
        if (t.endsWith("%"))
            return 1;
        if (t.endsWith("vw") || t.endsWith("vh"))
            return 4
    }
    return 0
}
var Ak = {
    fromProperties: e => {
        let {left: t, right: n, top: r, bottom: i, width: o, height: s, centerX: a, centerY: l, aspectRatio: c, autoSize: u} = e
          , f = Vk.quickfix({
            left: ne(t) || Nn(t),
            right: ne(n) || Nn(n),
            top: ne(r) || Nn(r),
            bottom: ne(i) || Nn(i),
            widthType: gu(o),
            heightType: gu(s),
            aspectRatio: c || null,
            fixedSize: u === !0
        })
          , d = null
          , p = null
          , v = 0
          , g = 0;
        if (f.widthType !== 0 && typeof o == "string") {
            let h = parseFloat(o);
            o.endsWith("fr") ? (v = 3,
            d = h) : o === "auto" ? v = 2 : (v = 1,
            d = h / 100)
        } else
            o !== void 0 && typeof o != "string" && (d = at.getNumber(o));
        if (f.heightType !== 0 && typeof s == "string") {
            let h = parseFloat(s);
            s.endsWith("fr") ? (g = 3,
            p = h) : s === "auto" ? g = 2 : (g = 1,
            p = parseFloat(s) / 100)
        } else
            s !== void 0 && typeof s != "string" && (p = at.getNumber(s));
        let b = .5
          , m = .5;
        return a && (b = parseFloat(a) / 100),
        l && (m = parseFloat(l) / 100),
        {
            left: f.left ? at.getNumber(t) : null,
            right: f.right ? at.getNumber(n) : null,
            top: f.top ? at.getNumber(r) : null,
            bottom: f.bottom ? at.getNumber(i) : null,
            widthType: v,
            heightType: g,
            width: d,
            height: p,
            aspectRatio: f.aspectRatio || null,
            centerAnchorX: b,
            centerAnchorY: m
        }
    }
    ,
    toSize: (e, t, n, r) => {
        let i = null
          , o = null
          , s = t?.sizing ? at.getNumber(t?.sizing.width) : null
          , a = t?.sizing ? at.getNumber(t?.sizing.height) : null
          , l = s1(e.left, e.right);
        if (s && ne(l))
            i = s - l;
        else if (n && e.widthType === 2)
            i = n.width;
        else if (ne(e.width))
            switch (e.widthType) {
            case 0:
                i = e.width;
                break;
            case 3:
                i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null;
                break;
            case 1:
            case 4:
                s && (i = s * e.width);
                break;
            case 2:
                break;
            default:
                ke(e.widthType)
            }
        let c = s1(e.top, e.bottom);
        if (a && ne(c))
            o = a - c;
        else if (n && e.heightType === 2)
            o = n.height;
        else if (ne(e.height))
            switch (e.heightType) {
            case 0:
                o = e.height;
                break;
            case 3:
                o = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null;
                break;
            case 1:
            case 4:
                a && (o = a * e.height);
                break;
            case 2:
                break;
            default:
                ke(e.heightType)
            }
        return aV(i, o, e, {
            height: a ?? 0,
            width: s ?? 0
        }, t?.viewport)
    }
    ,
    toRect: (e, t=null, n=null, r=!1, i=null) => {
        let o = e.left || 0
          , s = e.top || 0
          , {width: a, height: l} = Ak.toSize(e, t, n, i)
          , c = t?.positioning ?? null
          , u = c ? at.getNumber(c.width) : null
          , f = c ? at.getNumber(c.height) : null;
        e.left !== null ? o = e.left : u && e.right !== null ? o = u - e.right - a : u && (o = e.centerAnchorX * u - a / 2),
        e.top !== null ? s = e.top : f && e.bottom !== null ? s = f - e.bottom - l : f && (s = e.centerAnchorY * f - l / 2);
        let d = {
            x: o,
            y: s,
            width: a,
            height: l
        };
        return r ? te.pixelAligned(d) : d
    }
}
  , nV = 200
  , rV = 200;
function vu(e, t, n, r) {
    if (typeof t == "string") {
        if (t.endsWith("%") && n)
            switch (e) {
            case "maxWidth":
            case "minWidth":
                return parseFloat(t) / 100 * n.width;
            case "maxHeight":
            case "minHeight":
                return parseFloat(t) / 100 * n.height;
            default:
                break
            }
        if (t.endsWith("vh")) {
            if (!r)
                return iV(e);
            switch (e) {
            case "maxWidth":
            case "minWidth":
                return parseFloat(t) / 100 * r.width;
            case "maxHeight":
            case "minHeight":
                return parseFloat(t) / 100 * r.height;
            default:
                break
            }
        }
        return parseFloat(t)
    }
    return t
}
function iV(e) {
    switch (e) {
    case "minWidth":
    case "minHeight":
        return Number.NEGATIVE_INFINITY;
    case "maxWidth":
    case "maxHeight":
        return Number.POSITIVE_INFINITY;
    default:
        ke(e, "unknown constraint key")
    }
}
function oV(e, t, n, r) {
    return t.minHeight && (e = Math.max(vu("minHeight", t.minHeight, n, r), e)),
    t.maxHeight && (e = Math.min(vu("maxHeight", t.maxHeight, n, r), e)),
    e
}
function sV(e, t, n, r) {
    return t.minWidth && (e = Math.max(vu("minWidth", t.minWidth, n, r), e)),
    t.maxWidth && (e = Math.min(vu("maxWidth", t.maxWidth, n, r), e)),
    e
}
function aV(e, t, n, r, i) {
    let o = sV(ne(e) ? e : nV, n, r, i)
      , s = oV(ne(t) ? t : rV, n, r, i);
    return ne(n.aspectRatio) && n.aspectRatio > 0 && (ne(n.left) && ne(n.right) ? s = o / n.aspectRatio : ne(n.top) && ne(n.bottom) ? o = s * n.aspectRatio : n.widthType !== 0 ? s = o / n.aspectRatio : o = s * n.aspectRatio),
    {
        width: o,
        height: s
    }
}
function s1(e, t) {
    return !ne(e) || !ne(t) ? null : e + t
}
function lV(e) {
    return typeof e.right == "string" || typeof e.bottom == "string" || typeof e.left == "string" && (!e.center || e.center === "y") || typeof e.top == "string" && (!e.center || e.center === "x")
}
function Va(e) {
    return !e._constraints || lV(e) ? !1 : e._constraints.enabled
}
function cV(e) {
    let {size: t} = e
      , {width: n, height: r} = e;
    return ne(t) && (n === void 0 && (n = t),
    r === void 0 && (r = t)),
    ne(n) && ne(r) ? {
        width: n,
        height: r
    } : null
}
function uV(e) {
    let t = cV(e);
    if (t === null)
        return null;
    let {left: n, top: r} = e;
    return ne(n) && ne(r) ? {
        x: n,
        y: r,
        ...t
    } : null
}
function Pa(e, t, n=!0) {
    if (e.positionFixed || e.positionAbsolute)
        return null;
    let r = t === 1 || t === 2;
    if (!Va(e) || r)
        return uV(e);
    let i = fV(e)
      , o = dV(t)
      , s = o ? {
        sizing: o,
        positioning: o,
        viewport: null
    } : null;
    return Ak.toRect(i, s, null, n, null)
}
function fV(e) {
    let {left: t, right: n, top: r, bottom: i, center: o, _constraints: s, size: a} = e
      , {width: l, height: c} = e;
    l === void 0 && (l = a),
    c === void 0 && (c = a);
    let {aspectRatio: u, autoSize: f} = s
      , d = Vk.quickfix({
        left: ne(t),
        right: ne(n),
        top: ne(r),
        bottom: ne(i),
        widthType: gu(l),
        heightType: gu(c),
        aspectRatio: u || null,
        fixedSize: f === !0
    })
      , p = null
      , v = null
      , g = 0
      , b = 0;
    if (d.widthType !== 0 && typeof l == "string") {
        let y = parseFloat(l);
        l.endsWith("fr") ? (g = 3,
        p = y) : l === "auto" ? g = 2 : (g = 1,
        p = y / 100)
    } else
        l !== void 0 && typeof l != "string" && (p = l);
    if (d.heightType !== 0 && typeof c == "string") {
        let y = parseFloat(c);
        c.endsWith("fr") ? (b = 3,
        v = y) : c === "auto" ? b = 2 : (b = 1,
        v = parseFloat(c) / 100)
    } else
        c !== void 0 && typeof c != "string" && (v = c);
    let m = .5
      , h = .5;
    return (o === !0 || o === "x") && (d.left = !1,
    typeof t == "string" && (m = parseFloat(t) / 100)),
    (o === !0 || o === "y") && (d.top = !1,
    typeof r == "string" && (h = parseFloat(r) / 100)),
    {
        left: d.left ? t : null,
        right: d.right ? n : null,
        top: d.top ? r : null,
        bottom: d.bottom ? i : null,
        widthType: g,
        heightType: b,
        width: p,
        height: v,
        aspectRatio: d.aspectRatio || null,
        centerAnchorX: m,
        centerAnchorY: h,
        minHeight: e.minHeight,
        maxHeight: e.maxHeight,
        minWidth: e.minWidth,
        maxWidth: e.maxWidth
    }
}
var Dk = x.createContext({
    parentSize: 0
});
function dV(e) {
    return e === 0 || e === 1 || e === 2 ? null : e
}
function Aa() {
    return x.useContext(Dk).parentSize
}
function zk(e) {
    return typeof e == "object"
}
var hV = e => {
    let t = Aa()
      , {parentSize: n, children: r} = e
      , i = x.useMemo( () => ({
        parentSize: n
    }), [pV(n), mV(n)]);
    return t === 1 ? r ? k(it, {
        children: r
    }) : null : k(Dk.Provider, {
        value: i,
        children: r
    })
}
;
function pV(e) {
    return zk(e) ? e.width : e
}
function mV(e) {
    return zk(e) ? e.height : e
}
function gV(e, t) {
    return k(hV, {
        parentSize: t,
        children: e
    })
}
function vV(e) {
    let t = Aa();
    return Pa(e, t, !0)
}
function Bk({width: e, height: t}) {
    return e === "auto" || e === "min-content" || t === "auto" || t === "min-content"
}
var yV = (e => (e.Boolean = "boolean",
e.Number = "number",
e.String = "string",
e.RichText = "richtext",
e.FusedNumber = "fusednumber",
e.Enum = "enum",
e.SegmentedEnum = "segmentedenum",
e.Color = "color",
e.Image = "image",
e.ResponsiveImage = "responsiveimage",
e.File = "file",
e.ComponentInstance = "componentinstance",
e.Array = "array",
e.EventHandler = "eventhandler",
e.Transition = "transition",
e.BoxShadow = "boxshadow",
e.Link = "link",
e.Date = "date",
e.Object = "object",
e.Font = "font",
e.PageScope = "pagescope",
e.ScrollSectionRef = "scrollsectionref",
e.CustomCursor = "customcursor",
e.Border = "border",
e.Cursor = "cursor",
e.Padding = "padding",
e.BorderRadius = "borderradius",
e.CollectionReference = "collectionreference",
e.MultiCollectionReference = "multicollectionreference",
e))(yV || {}), tm;
function bV() {
    if (tm !== void 0)
        return tm;
    let e = document.createElement("div");
    Object.assign(e.style, {
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        rowGap: "1px"
    }),
    e.appendChild(document.createElement("div")),
    e.appendChild(document.createElement("div")),
    document.body.appendChild(e);
    let t = e.scrollHeight === 1;
    return e.parentNode && e.parentNode.removeChild(e),
    tm = t,
    t
}
var qi = "flexbox-gap-not-supported"
  , a1 = !1;
function Lj() {
    a1 || (a1 = !0,
    !bV() && document.body.classList.add(qi))
}
var xV = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, wV = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, SV = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, kV = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, CV = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, TV = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current],
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current] span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, RV = `
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover,
[data-framer-component-type="DeprecatedRichText"] a[data-framer-page-link-current]:hover span:not([data-text-fill]):not([data-nested-link]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, EV = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, FV = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, PV = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, _V = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, IV = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
    --font-variation-settings: normal;
}
`, OV = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, MV = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, LV = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, VV = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`, AV = ['[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }', IV, _V, xV, wV, SV, kV, CV, TV, RV, EV, FV, PV, OV, MV, LV, VV], DV = [`
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, none));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            font-variation-settings: var(--framer-font-variation-axes, normal);
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold, var(--framer-font-variation-axes-bold));
        }
    `, `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-italic, var(--framer-font-variation-axes-italic));
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
            font-variation-settings: var(--framer-blockquote-font-variation-axes-bold-italic, var(--framer-font-variation-axes-bold-italic));
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `, `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link],
        span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `, `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link],
        code.framer-text span.framer-text[data-nested-link] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-nested-link]:hover,
        span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-nested-link]:hover,
        code.framer-text span.framer-text[data-nested-link]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current],
        span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current],
        code.framer-text span.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        span.framer-text[data-framer-page-link-current]:hover,
        span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]),
        code.framer-text span.framer-text[data-framer-page-link-current]:hover,
        code.framer-text span.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `, `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `, `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `], zV = new Set, nm;
function $k(e, t, n=zV) {
    if (!(!e || n.has(e) || typeof document > "u")) {
        if (n.add(e),
        !t) {
            if (!nm) {
                let r = document.createElement("style");
                if (r.setAttribute("type", "text/css"),
                r.setAttribute("data-framer-css", "true"),
                !document.head) {
                    console.warn("not injecting CSS: the document is missing a <head> element");
                    return
                }
                if (document.head.appendChild(r),
                r.sheet)
                    nm = r.sheet;
                else {
                    console.warn("not injecting CSS: injected <style> element does not have a sheet", r);
                    return
                }
            }
            t = nm
        }
        try {
            t.insertRule(e, t.cssRules.length)
        } catch {}
    }
}
var BV = ["[data-framer-component-type] { position: absolute; }"]
  , $V = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`
  , NV = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`
  , jV = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`
  , HV = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`
  , WV = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`
  , UV = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`
  , GV = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`
  , qV = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`
  , XV = ['[data-framer-component-type="Text"] { cursor: inherit; }', "[data-framer-component-text-autosized] * { white-space: pre; }", $V, NV, jV, HV, WV, UV, GV, qV]
  , YV = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`
  , KV = ( () => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${qi} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])()
  , QV = ( () => `
.${qi} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)()
  , ZV = ( () => `
.${qi}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${qi}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)()
  , JV = ( () => `
.${qi}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${qi}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)()
  , eA = ( () => [YV, QV, ...KV, ZV, JV])()
  , tA = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`]
  , nA = ['[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }', '[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }']
  , rA = ['[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }', '[data-framer-component-type="NativeScroll"] > * { position: relative; }', '[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }', '[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }', '[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }', '[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }']
  , iA = ['[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }']
  , oA = ['[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }']
  , sA = ['[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }']
  , aA = ['[data-framer-cursor="pointer"] { cursor: pointer; }', '[data-framer-cursor="grab"] { cursor: grab; }', '[data-framer-cursor="grab"]:active { cursor: grabbing; }']
  , lA = ['[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }', "[data-framer-generated] * { pointer-events: unset }"]
  , cA = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`]
  , uA = ['[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }', '[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }']
  , rm = "--framer-will-change-override"
  , fA = "(background: -webkit-named-image(i))"
  , dA = "(grid-template-rows: subgrid)"
  , hA = e => e ? [`body { ${rm}: none; }`, `@supports ${fA} and (not ${dA}) { body { ${rm}: transform; } }`] : [`body { ${rm}: none; }`]
  , pA = e => e ? lA : []
  , mA = [".svgContainer svg { display: block; }"]
  , Nk = e => [...hA(e), ...BV, ...XV, ...DV, ...AV, ...eA, ...tA, ...nA, ...rA, ...oA, ...iA, ...sA, ...aA, ...pA(e), ...mA, ...cA, ...uA]
  , gA = Nk(!1)
  , vA = Nk(!0)
  , l1 = !1;
function Da() {
    if (l1)
        return;
    l1 = !0;
    let e = ue.current() === ue.preview ? vA : gA;
    for (let t of e)
        $k(t, void 0, void 0)
}
function jn(e) {
    return typeof e == "function"
}
function qm(e) {
    return typeof e == "boolean"
}
function xe(e) {
    return typeof e == "string"
}
function He(e) {
    return Number.isFinite(e)
}
function $u(e) {
    return Array.isArray(e)
}
function Re(e) {
    return e !== null && typeof e == "object" && !$u(e)
}
function et(e) {
    return typeof e > "u"
}
function ar(e) {
    return e === null
}
function yA(e) {
    return e == null
}
function jk(e) {
    return e instanceof Date && !Number.isNaN(e.getTime())
}
function Hk(e) {
    return Re(e) && jn(e.return)
}
function bA(e) {
    return Re(e) || jn(e)
}
var c1 = "optional";
function xA(e) {
    return !!e && c1 in e && e[c1] === !0
}
function wA(e) {
    try {
        switch (e.type) {
        case "string":
        case "collectionreference":
        case "multicollectionreference":
        case "color":
        case "date":
        case "link":
        case "boxshadow":
        case "padding":
        case "borderradius":
            return xe(e.defaultValue) ? e.defaultValue : void 0;
        case "boolean":
            return qm(e.defaultValue) ? e.defaultValue : void 0;
        case "enum":
            return et(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0;
        case "fusednumber":
        case "number":
            return He(e.defaultValue) ? e.defaultValue : void 0;
        case "transition":
            return Re(e.defaultValue) ? e.defaultValue : void 0;
        case "border":
            return Re(e.defaultValue) ? e.defaultValue : void 0;
        case "font":
            return Re(e.defaultValue) ? e.defaultValue : void 0;
        case "object":
            {
                let t = Re(e.defaultValue) ? e.defaultValue : {};
                return Re(e.controls) && Wk(t, e.controls),
                t
            }
        case "array":
            return $u(e.defaultValue) ? e.defaultValue : void 0;
        case "file":
        case "image":
        case "richtext":
        case "pagescope":
        case "eventhandler":
        case "segmentedenum":
        case "responsiveimage":
        case "componentinstance":
        case "scrollsectionref":
        case "customcursor":
        case "cursor":
            return;
        default:
            return
        }
    } catch {
        return
    }
}
function Wk(e, t) {
    for (let n in t) {
        let r = t[n];
        if (!r)
            continue;
        let i = e[n];
        if (!et(i) || xA(r))
            continue;
        let o = wA(r);
        et(o) || (e[n] = o)
    }
}
function SA(e) {
    if (Re(e.defaultProps))
        return e.defaultProps;
    let t = {};
    return e.defaultProps = t,
    t
}
function kA(e, t) {
    if (!bA(e))
        return;
    let n = SA(e);
    Wk(n, t)
}
function Vj(e, t) {
    Object.assign(e, {
        propertyControls: t
    }),
    kA(e, t)
}
function CA(e) {
    return e.propertyControls
}
var rt = e => e;
function TA(e) {
    let t = Object.create(Object.prototype);
    return n => (t[n] === void 0 && (t[n] = e(n)),
    t[n])
}
var RA = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/u
  , EA = TA(e => RA.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91)
  , u1 = e => () => {
    Fa(e)
}
  , FA = () => () => {}
  , PA = {
    useImageSource(e) {
        return e.src ?? ""
    },
    useImageElement(e, t, n) {
        let r = new Image;
        return r.src = pt.useImageSource(e, t, n),
        e.srcSet && (r.srcset = e.srcSet),
        r
    },
    canRenderOptimizedCanvasImage() {
        return !1
    }
}
  , _A = !1
  , IA = {
    get(e, t, n) {
        return Reflect.has(e, t) ? Reflect.get(e, t, n) : ["getLogger"].includes(String(t)) ? FA() : u1(_A ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`)
    }
}
  , pt = new Proxy(PA,IA);
var f1 = {
    position: "absolute",
    borderRadius: "inherit",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
}
  , OA = {
    backgroundRepeat: "repeat",
    backgroundPosition: "left top",
    backgroundSize: "126px auto",
    backgroundImage: "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTI2IiBoZWlnaHQ9IjEyNiI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0xMjYgMHYyMS41ODRMMjEuNTg0IDEyNkgwdi0xNy41ODVMMTA4LjQxNSAwSDEyNlptMCAxMDguNDE0VjEyNmgtMTcuNTg2TDEyNiAxMDguNDE0Wm0wLTg0djM5LjE3MUw2My41ODUgMTI2SDI0LjQxNEwxMjYgMjQuNDE0Wm0wIDQydjM5LjE3TDEwNS41ODQgMTI2aC0zOS4xN0wxMjYgNjYuNDE0Wk0xMDUuNTg2IDAgMCAxMDUuNTg2VjY2LjQxNUw2Ni40MTUgMGgzOS4xNzFabS00MiAwTDAgNjMuNTg2VjI0LjQxNUwyNC40MTUgMGgzOS4xNzFabS00MiAwTDAgMjEuNTg2VjBoMjEuNTg2WiIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODg4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)",
    opacity: .2
};
function MA(e) {
    switch (e) {
    case "fit":
        return "contain";
    case "stretch":
        return "fill";
    default:
        return "cover"
    }
}
function Uk(e, t) {
    let n = e ?? "center"
      , r = t ?? "center";
    return n === "center" && r === "center" ? "center" : n + " " + r
}
function Xm(e) {
    return {
        display: "block",
        width: "100%",
        height: "100%",
        borderRadius: "inherit",
        objectPosition: Uk(e.positionX, e.positionY),
        objectFit: MA(e.fit)
    }
}
function LA({image: e, containerSize: t, nodeId: n, alt: r, draggable: i}) {
    let o = pt.useImageSource(e, t, n)
      , s = Xm(e)
      , a = x.useRef(null);
    return k("img", {
        ref: a,
        decoding: "async",
        fetchpriority: e.fetchPriority,
        loading: e.loading,
        sizes: e.sizes,
        srcSet: e.srcSet,
        src: o,
        alt: r ?? e.alt ?? "",
        style: s,
        draggable: i
    })
}
function VA({image: e, containerSize: t, nodeId: n}) {
    let r = x.useRef(null)
      , i = pt.useImageElement(e, t, n)
      , o = Xm(e);
    return x.useLayoutEffect( () => {
        let s = r.current;
        if (s !== null)
            return s.appendChild(i),
            () => {
                s.removeChild(i)
            }
    }
    , [i]),
    Object.assign(i.style, o),
    k("div", {
        ref: r,
        style: {
            display: "contents",
            borderRadius: "inherit"
        }
    })
}
function AA({nodeId: e, image: t, containerSize: n}) {
    let r = x.useRef(null)
      , i = pt.useImageSource(t, n, e);
    return x.useLayoutEffect( () => {
        let o = r.current;
        if (o === null)
            return;
        let s = Xm(t);
        pt.renderOptimizedCanvasImage(o, i, s, e)
    }
    , [e, t, i, n]),
    k("div", {
        ref: r,
        style: {
            display: "contents",
            borderRadius: "inherit"
        }
    })
}
function Gk({layoutId: e, image: t, ...n}) {
    e && (e = e + "-background");
    let r = {
        ...f1,
        ...OA
    }
      , i = null;
    if (xe(t.src))
        if (t.fit === "tile" && t.pixelWidth && t.pixelHeight) {
            let o = He(t.backgroundSize) ? t.backgroundSize : 1
              , s = {
                width: Math.round(o * t.pixelWidth),
                height: Math.round(o * t.pixelHeight)
            }
              , a = pt.useImageSource(t, s);
            r.backgroundImage = `url(${a})`,
            r.backgroundRepeat = "repeat",
            r.backgroundPosition = Uk(t.positionX, t.positionY),
            r.opacity = void 0,
            r.border = 0,
            r.backgroundSize = `${(o * (t.pixelWidth / 2)).toFixed(2)}px auto`,
            i = null
        } else
            ue.current() !== ue.canvas ? i = k(LA, {
                image: t,
                ...n
            }) : pt.canRenderOptimizedCanvasImage(pt.useImageSource(t)) ? i = k(AA, {
                image: t,
                ...n
            }) : i = k(VA, {
                image: t,
                ...n
            });
    return k(Jt.div, {
        layoutId: e,
        style: i ? f1 : r,
        "data-framer-background-image-wrapper": !0,
        children: i
    })
}
var DA = "src"
  , Hi = {
    isImageObject: function(e) {
        return !e || typeof e == "string" ? !1 : DA in e
    }
};
function zA(e, t) {
    let {_forwardedOverrideId: n, _forwardedOverrides: r, id: i} = t
      , o = n ?? i
      , s = r && o ? r[o] : void 0;
    return s && typeof s == "string" && (e = {
        ...e,
        src: s
    }),
    e
}
function BA(e) {
    let {background: t, image: n} = e;
    if (n !== void 0 && t && !Hi.isImageObject(t))
        return;
    let r = null;
    if (xe(n) ? r = {
        alt: "",
        src: n
    } : r = at.get(t, null),
    !!Hi.isImageObject(r))
        return zA(r, e)
}
function $A(e, t, n=!0) {
    let {borderWidth: r, borderStyle: i, borderColor: o} = e;
    if (!r)
        return;
    let s, a, l, c;
    if (typeof r == "number" ? s = a = l = c = r : (s = r.top || 0,
    a = r.bottom || 0,
    l = r.left || 0,
    c = r.right || 0),
    !(s === 0 && a === 0 && l === 0 && c === 0)) {
        if (n && s === a && s === l && s === c) {
            t.border = `${s}px ${i} ${o}`;
            return
        }
        t.borderStyle = e.borderStyle,
        t.borderColor = e.borderColor,
        t.borderTopWidth = `${s}px`,
        t.borderBottomWidth = `${a}px`,
        t.borderLeftWidth = `${l}px`,
        t.borderRightWidth = `${c}px`
    }
}
function NA(e) {
    let t = e.layoutId ? `${e.layoutId}-border` : void 0;
    if (!e.borderWidth)
        return null;
    let n = {
        position: "absolute",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        borderRadius: "inherit",
        pointerEvents: "none"
    };
    return e.border ? (n.border = e.border,
    k(Jt.div, {
        style: n
    })) : ($A(e, n, !1),
    k(Jt.div, {
        "data-frame-border": !0,
        style: n,
        layoutId: t
    }))
}
function za(e) {
    return e && e !== "search" && e !== "slot" && e !== "template" ? Jt[e] : Jt.div
}
var jA = hr(Bm(), 1)
  , Pn = typeof Fe < "u" ? Fe : void 0
  , Vr = () => typeof document == "object";
var HA = () => Pn && /Chrome/u.test(Pn.userAgent) && /Google Inc/u.test(Pn.vendor) && !qA()
  , WA = () => Pn && /Safari/u.test(Pn.userAgent) && /Apple Computer/u.test(Pn.vendor)
  , UA = () => Pn && /Firefox\/\d+\.\d+$/u.test(Pn.userAgent)
  , GA = () => Pn && /FramerX/u.test(Pn.userAgent)
  , qA = () => Pn && /Edg\//u.test(Pn.userAgent);
var XA = () => jA.default.env.NODE_ENV === "test";
var YA = HA();
function qk(e) {
    let t = {};
    return !YA || ue.current() !== ue.canvas || ((e === !0 || e === "x") && (t["data-framer-layout-hint-center-x"] = !0),
    (e === !0 || e === "y") && (t["data-framer-layout-hint-center-y"] = !0)),
    t
}
function Ym(e) {
    return e.replace(/^id_/u, "").replace(/\\/gu, "")
}
function KA(e, t) {
    if (!t && (t = e.children,
    !t))
        return {
            props: e,
            children: t
        };
    let n = e._forwardedOverrides;
    return n ? (t = x.Children.map(t, r => x.isValidElement(r) ? x.cloneElement(r, {
        _forwardedOverrides: n
    }) : r),
    {
        props: e,
        children: t
    }) : {
        props: e,
        children: t
    }
}
function Nu(e) {
    return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === "x" ? `translateX(-50%) ${n}` : e === "y" ? `translateY(-50%) ${n}` : n || "none"
}
function Ba(e, {specificLayoutId: t, postfix: n}={}) {
    let {name: r, layoutIdKey: i, duplicatedFrom: o, __fromCodeComponentNode: s=!1, drag: a} = e
      , {getLayoutId: l, enabled: c} = D(Zo);
    return se( () => {
        if (!c)
            return e.layoutId;
        let u = t || e.layoutId;
        if (!u && (a || !i || s))
            return;
        let f = u || l({
            id: i,
            name: r,
            duplicatedFrom: o
        });
        if (f)
            return n ? `${f}-${n}` : f
    }
    , [c])
}
var Xk = typeof document < "u" ? Ae : $
  , ts = x.createContext(!1);
function ju() {
    let[e,t] = x.useState(0);
    return x.useCallback( () => t(n => n + 1), [])
}
var QA = ( () => sM().ResizeObserver)();
var ZA = class {
    constructor() {
        R(this, "sharedResizeObserver"),
        R(this, "callbacks", new WeakMap);
        let e = nt.ResizeObserver ?? QA;
        this.sharedResizeObserver = new e(this.updateResizedElements.bind(this))
    }
    updateResizedElements(e) {
        for (let t of e) {
            let n = this.callbacks.get(t.target);
            n && n(t.contentRect)
        }
    }
    observeElementWithCallback(e, t) {
        this.sharedResizeObserver.observe(e),
        this.callbacks.set(e, t)
    }
    unobserve(e) {
        this.sharedResizeObserver.unobserve(e),
        this.callbacks.delete(e)
    }
}
  , Jc = ( () => Vr() ? new ZA : void 0)();
function JA(e) {
    let t = ju();
    $( () => {
        let n = e?.current;
        if (n)
            return Jc?.observeElementWithCallback(e.current, t),
            () => {
                Jc?.unobserve(n)
            }
    }
    , [e, t])
}
var eD = "data-framer-size-compatibility-wrapper";
function tD(e) {
    return [...e.firstElementChild && e.firstElementChild.hasAttribute(eD) ? e.firstElementChild.children : e.children].filter(Yk).map(Kk)
}
function Yk(e) {
    return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement
}
function Kk(e) {
    if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== "contents")
        return e;
    let t = [...e.children].find(Yk);
    return t ? Kk(t) : e
}
function Hu(e, t, n= () => [], r={}) {
    let {id: i, visible: o, _needsMeasure: s} = e
      , {skipHook: a=!1} = r
      , l = !!D(ts)
      , c = ue.current() === ue.canvas;
    Xk( () => {
        !c || l || a || t.current && i && o && s && pt.queueMeasureRequest(Ym(i), t.current, n(t.current))
    }
    )
}
function nD(e) {
    let t = e.closest("[data-framer-component-container]");
    t && pt.queueMeasureRequest(Ym(t.id), t, tD(t))
}
var Xi = Object.keys;
function yu(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
var rD = "equals";
function d1(e) {
    return e === null || !(rD in e) ? !1 : typeof e.equals == "function"
}
function Km(e, t) {
    return e === t ? !0 : e !== e && t !== t
}
function iD(e, t) {
    let n = e.length;
    if (n !== t.length)
        return !1;
    for (let r = n; r-- !== 0; )
        if (!Km(e[r], t[r]))
            return !1;
    return !0
}
function oD(e, t) {
    let n = e.length;
    if (n !== t.length)
        return !1;
    for (let r = n; r-- !== 0; )
        if (!Wu(e[r], t[r], !0))
            return !1;
    return !0
}
function sD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let[n,r] of e.entries())
        if (!Km(r, t.get(n)))
            return !1;
    return !0
}
function aD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let[n,r] of e.entries())
        if (!Wu(r, t.get(n), !0))
            return !1;
    return !0
}
function lD(e, t) {
    if (e.size !== t.size)
        return !1;
    for (let n of e.keys())
        if (!t.has(n))
            return !1;
    return !0
}
function cD(e, t) {
    let n = Xi(e);
    if (n.length !== Xi(t).length)
        return !1;
    for (let r of n) {
        if (!yu(t, r))
            return !1;
        if (!(r === "_owner" && yu(e, "$$typeof") && e.$$typeof) && !Km(e[r], t[r]))
            return !1
    }
    return !0
}
function uD(e, t) {
    let n = Xi(e);
    if (n.length !== Xi(t).length)
        return !1;
    for (let r of n) {
        if (!yu(t, r))
            return !1;
        if (!(r === "_owner" && yu(e, "$$typeof") && e.$$typeof) && !Wu(e[r], t[r], !0))
            return !1
    }
    return !0
}
function Wu(e, t, n) {
    if (e === t)
        return !0;
    if (!e || !t)
        return e !== e && t !== t;
    let r = typeof e;
    if (r !== typeof t || r !== "object")
        return !1;
    let o = Array.isArray(e)
      , s = Array.isArray(t);
    if (o && s)
        return n ? oD(e, t) : iD(e, t);
    if (o !== s)
        return !1;
    let a = e instanceof Map
      , l = t instanceof Map;
    if (a && l)
        return n ? aD(e, t) : sD(e, t);
    if (a !== l)
        return !1;
    let c = e instanceof Set
      , u = t instanceof Set;
    if (c && u)
        return lD(e, t);
    if (c !== u)
        return !1;
    let f = e instanceof Date
      , d = t instanceof Date;
    if (f && d)
        return e.getTime() === t.getTime();
    if (f !== d)
        return !1;
    let p = e instanceof RegExp
      , v = t instanceof RegExp;
    return p && v ? e.toString() === t.toString() : p !== v ? !1 : d1(e) && d1(t) ? e.equals(t) : n ? uD(e, t) : cD(e, t)
}
function Qm(e, t, n=!0) {
    try {
        return Wu(e, t, n)
    } catch (r) {
        if (r instanceof Error && /stack|recursion/iu.exec(r.message))
            return console.warn("Warning: isEqual does not handle circular references.", r.name, r.message),
            !1;
        throw r
    }
}
var Qk = "0.000001px"
  , im = ( () => ` translateZ(${Qk})`)()
  , Zk = ( () => GA() || WA() || XA())();
function fD(e) {
    e.willChange = "transform";
    let t = ue.current() === ue.canvas;
    Zk && t && (e.translateZ = Qk)
}
function Zm(e) {
    e.willChange = "transform",
    dD(e, !0)
}
function dD(e, t) {
    let n = ue.current() === ue.canvas;
    if (!Zk || !n)
        return;
    let r = xe(e.transform) && e.transform || "";
    t ? r.includes(im) || (e.transform = r + im) : e.transform = r.replace(im, "")
}
function Jk(e, t, n, r=!0) {
    if (!e)
        return;
    let i = rt(e.style)
      , o = n || i[t]
      , s = () => {
        i[t] = o
    }
    ;
    i[t] = null,
    r ? Promise.resolve().then(s) : setTimeout(s, 0)
}
var lu = ( () => {
    class e extends we {
        constructor() {
            super(...arguments),
            R(this, "layerElement", null),
            R(this, "setLayerElement", n => {
                this.layerElement = n
            }
            )
        }
        static applyWillChange(n, r, i) {
            n.willChangeTransform && (i ? fD(r) : Zm(r))
        }
        shouldComponentUpdate(n, r) {
            return n._needsMeasure || this.state !== r || !Qm(this.props, n)
        }
        componentDidUpdate(n) {
            rt(this.props).clip && rt(this.props).radius === 0 && rt(n).radius !== 0 && Jk(this.layerElement, "overflow", "hidden", !1)
        }
    }
    return R(e, "defaultProps", {}),
    e
}
)();
function hD(e, t) {
    if (e.size < t)
        return;
    let r = Math.round(Math.random());
    for (let i of e.keys())
        (++r & 1) !== 1 && e.delete(i)
}
function pD(e, t, n, r) {
    let i = t.get(n);
    if (i)
        return i;
    hD(t, e);
    let o = r(n);
    return t.set(n, o),
    o
}
var eC = e => {
    let t = 0, n, r;
    if (e.length === 0)
        return t;
    for (n = 0; n < e.length; n++)
        r = e.charCodeAt(n),
        t = (t << 5) - t + r,
        t |= 0;
    return t
}
  , Jm = {
    hueRotate: (e, t) => Y.toHslString(Y.hueRotate(Y(e), t)),
    setAlpha: (e, t) => Y.toRgbString(Y.alpha(Y(e), t)),
    getAlpha: e => {
        let t = Gm(e);
        return t ? t.a : 1
    }
    ,
    multiplyAlpha: (e, t) => Y.toRgbString(Y.multiplyAlpha(Y(e), t)),
    toHex: e => Y.toHexString(Y(e)).toUpperCase(),
    toRgb: e => Y.toRgb(Y(e)),
    toRgbString: e => Y.toRgbString(Y(e)),
    toHSV: e => Y.toHsv(Y(e)),
    toHSL: e => Y.toHsl(Y(e)),
    toHslString: e => Y.toHslString(Y(e)),
    toHsvString: e => Y.toHsvString(Y(e)),
    hsvToHSLString: e => Y.toHslString(Y(Qc(e.h, e.s, e.v, e.a))),
    hsvToHex: e => Y.toHexString(Y(Qc(e.h, e.s, e.v, e.a))).toUpperCase(),
    hsvToRgbString: e => Y.toRgbString(Y(Qc(e.h, e.s, e.v, e.a))),
    hsvToString: e => Qc(e.h, e.s, e.v),
    rgbaToString: e => Y.toRgbString(Y(e)),
    rgbToHexString: e => Y.toHexString(Y(e)),
    hslToString: e => Y.toHslString(Y(e)),
    hslToRgbString: e => Y.toRgbString(Y(e)),
    toColorPickerSquare: e => Y.toRgbString(Y({
        h: e,
        s: 1,
        l: .5,
        a: 1
    })),
    isValid: e => Y(e).isValid !== !1,
    equals: (e, t) => (typeof e == "string" && (e = Y(e)),
    typeof t == "string" && (t = Y(t)),
    Y.equal(e, t)),
    toHexOrRgbaString: e => {
        let t = Y(e);
        return t.a !== 1 ? Y.toRgbString(t) : Y.toHexString(t)
    }
}
  , mD = /var\(.+\)/u
  , gD = new Map;
function vD(e, t) {
    let n = [e, t];
    return mD.test(e) ? e : pD(1e3, gD, n, () => Jm.multiplyAlpha(e, t))
}
function $a(e, t=1) {
    let n;
    return "stops"in e ? n = e.stops : n = [{
        value: e.start,
        position: 0
    }, {
        value: e.end,
        position: 1
    }],
    t === 1 ? n : n.map(r => ({
        ...r,
        value: vD(r.value, t)
    }))
}
function tC(e, t) {
    let n = 0;
    return $a(e, t).forEach(r => {
        n ^= eC(r.value) ^ r.position
    }
    ),
    n
}
var yD = ["stops"];
function nC(e) {
    return e && yD.every(t => t in e)
}
var bD = ["start", "end"];
function rC(e) {
    return e && bD.every(t => t in e)
}
var xD = ["angle", "alpha"]
  , _a = {
    isLinearGradient: e => e && xD.every(t => t in e) && (rC(e) || nC(e)),
    hash: e => e.angle ^ tC(e, e.alpha),
    toCSS: (e, t) => {
        let n = $a(e, e.alpha)
          , r = t !== void 0 ? t : e.angle
          , i = n.map(o => `${o.value} ${o.position * 100}%`);
        return `linear-gradient(${r}deg, ${i.join(", ")})`
    }
}
  , wD = ["widthFactor", "heightFactor", "centerAnchorX", "centerAnchorY", "alpha"]
  , Ia = {
    isRadialGradient: e => e && wD.every(t => t in e) && (rC(e) || nC(e)),
    hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ tC(e, e.alpha),
    toCSS: e => {
        let {alpha: t, widthFactor: n, heightFactor: r, centerAnchorX: i, centerAnchorY: o} = e
          , s = $a(e, t)
          , a = s.map( (l, c) => {
            let u = s[c + 1]
              , f = l.position === 1 && u?.position === 1 ? l.position - 1e-4 : l.position;
            return `${l.value} ${f * 100}%`
        }
        );
        return `radial-gradient(${n * 100}% ${r * 100}% at ${i * 100}% ${o * 100}%, ${a.join(", ")})`
    }
};
function SD({background: e, backgroundColor: t}, n) {
    t ? typeof t == "string" || i1(t) ? n.backgroundColor = t : Y.isColorObject(e) && (n.backgroundColor = e.initialValue || Y.toRgbString(e)) : e && (e = at.get(e, null),
    typeof e == "string" || i1(e) ? n.background = e : _a.isLinearGradient(e) ? n.background = _a.toCSS(e) : Ia.isRadialGradient(e) ? n.background = Ia.toCSS(e) : Y.isColorObject(e) && (n.backgroundColor = e.initialValue || Y.toRgbString(e)))
}
function be(e, t, n, r) {
    if (r === void 0 && (r = t),
    e[t] !== void 0) {
        n[r] = e[t];
        return
    }
}
function kD(e) {
    return e ? e.left !== void 0 && e.right !== void 0 : !1
}
function CD(e) {
    return e ? e.top !== void 0 && e.bottom !== void 0 : !1
}
function TD(e) {
    if (!e)
        return {};
    let t = {};
    return e.preserve3d === !0 ? t.transformStyle = "preserve-3d" : e.preserve3d === !1 && (t.transformStyle = "flat"),
    e.backfaceVisible === !0 ? t.backfaceVisibility = "visible" : e.backfaceVisible === !1 && (t.backfaceVisibility = "hidden"),
    t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility),
    e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective),
    e.__fromCanvasComponent || (e.center === !0 ? (t.left = "50%",
    t.top = "50%") : e.center === "x" ? t.left = "50%" : e.center === "y" && (t.top = "50%")),
    be(e, "size", t),
    be(e, "width", t),
    be(e, "height", t),
    be(e, "minWidth", t),
    be(e, "minHeight", t),
    be(e, "top", t),
    be(e, "right", t),
    be(e, "bottom", t),
    be(e, "left", t),
    be(e, "position", t),
    be(e, "overflow", t),
    be(e, "opacity", t),
    (!e._border || !e._border.borderWidth) && be(e, "border", t),
    be(e, "borderRadius", t),
    be(e, "radius", t, "borderRadius"),
    be(e, "color", t),
    be(e, "shadow", t, "boxShadow"),
    be(e, "x", t),
    be(e, "y", t),
    be(e, "z", t),
    be(e, "rotate", t),
    be(e, "rotateX", t),
    be(e, "rotateY", t),
    be(e, "rotateZ", t),
    be(e, "scale", t),
    be(e, "scaleX", t),
    be(e, "scaleY", t),
    be(e, "skew", t),
    be(e, "skewX", t),
    be(e, "skewY", t),
    be(e, "originX", t),
    be(e, "originY", t),
    be(e, "originZ", t),
    SD(e, t),
    t
}
function RD(e) {
    for (let t in e)
        if (t === "drag" || t.startsWith("while") || typeof rt(e)[t] == "function" && t.startsWith("on") && !t.includes("Animation"))
            return !0;
    return !1
}
var h1 = ["onClick", "onDoubleClick", "onMouse", "onMouseDown", "onMouseUp", "onTapDown", "onTap", "onTapUp", "onPointer", "onPointerDown", "onPointerUp", "onTouch", "onTouchDown", "onTouchUp"]
  , ED = ( () => new Set([...h1, ...h1.map(e => `${e}Capture`)]))();
function FD(e) {
    if (e.drag)
        return "grab";
    for (let t in e)
        if (ED.has(t))
            return "pointer"
}
var om = "overflow";
function PD(e) {
    return p1(e) ? !0 : e.style ? !!p1(e.style) : !1
}
function p1(e) {
    return om in e && (e[om] === "scroll" || e[om] === "auto")
}
function iC(e) {
    let {left: t, top: n, bottom: r, right: i, width: o, height: s, center: a, _constraints: l, size: c, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p} = e
      , v = Ct(e.minWidth)
      , g = Ct(e.minHeight)
      , b = Ct(e.maxWidth)
      , m = Ct(e.maxHeight);
    return {
        top: Ct(n),
        left: Ct(t),
        bottom: Ct(r),
        right: Ct(i),
        width: Ct(o),
        height: Ct(s),
        size: Ct(c),
        center: a,
        _constraints: l,
        widthType: u,
        heightType: f,
        positionFixed: d,
        positionAbsolute: p,
        minWidth: v,
        minHeight: g,
        maxWidth: b,
        maxHeight: m
    }
}
var m1 = {
    x: 0,
    y: 0,
    width: 200,
    height: 200
};
function _D(e) {
    x.useInsertionEffect( () => {
        Da()
    }
    , []);
    let t = !!D(ts)
      , {style: n, _initialStyle: r, __fromCanvasComponent: i, size: o} = e
      , s = iC(e)
      , a = vV(s)
      , l = {
        display: "block",
        flex: n?.flex ?? "0 0 auto",
        userSelect: ue.current() !== ue.preview ? "none" : void 0
    };
    e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0);
    let c = !RD(e) && !e.__fromCanvasComponent && !PD(e)
      , u = e.style ? !("pointerEvents"in e.style) : !0;
    c && u && (l.pointerEvents = "none");
    let d = x.Children.count(e.children) > 0 && x.Children.toArray(e.children).every(m => typeof m == "string" || typeof m == "number") && {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        textAlign: "center"
    }
      , p = TD(e);
    o === void 0 && !i && (kD(p) || (l.width = m1.width),
    CD(p) || (l.height = m1.height)),
    s.minWidth !== void 0 && (l.minWidth = s.minWidth),
    s.minHeight !== void 0 && (l.minHeight = s.minHeight);
    let v = {};
    Va(s) && a && !Bk(e) && (v = {
        left: a.x,
        top: a.y,
        width: a.width,
        height: a.height,
        right: void 0,
        bottom: void 0
    }),
    Object.assign(l, d, r, p, v, n),
    Object.assign(l, {
        overflowX: l.overflowX ?? l.overflow,
        overflowY: l.overflowY ?? l.overflow,
        overflow: void 0
    }),
    lu.applyWillChange(e, l, !0);
    let g = l;
    l.transform || (g = {
        x: 0,
        y: 0,
        ...l
    });
    let b = ue.current() === ue.canvas;
    return e.positionSticky ? (!b || t) && (g.position = "sticky",
    g.willChange = "transform",
    g.zIndex = 1,
    g.top = e.positionStickyTop,
    g.right = e.positionStickyRight,
    g.bottom = e.positionStickyBottom,
    g.left = e.positionStickyLeft) : b && (e.positionFixed || e.positionAbsolute) && (g.position = "absolute"),
    "rotate"in g && g.rotate === void 0 && delete g.rotate,
    [g, a]
}
var ID = new Set(["width", "height", "opacity", "overflow", "radius", "background", "color", "x", "y", "z", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "originX", "originY", "originZ"]);
function OD(e) {
    let t = {};
    for (let n in e)
        (lo(n) || EA(n)) && !ID.has(n) ? t[n] = rt(e)[n] : (n === "positionTransition" || n === "layoutTransition") && (t.layout = !0,
        typeof rt(e)[n] != "boolean" && !e.transition && (t.transition = rt(e)[n]));
    return t
}
function MD(e) {
    return "data-framer-name"in e
}
var LD = Ie(function(t, n) {
    let {name: r, center: i, border: o, _border: s, __portal: a} = t
      , {props: l, children: c} = KA(t)
      , u = OD(l)
      , f = Ba(t)
      , d = FD(t)
      , p = V(null)
      , v = n ?? p
      , g = {
        "data-framer-component-type": t.componentType ?? "Frame",
        "data-framer-cursor": d,
        "data-framer-highlight": d === "pointer" ? !0 : void 0,
        "data-layoutid": f,
        "data-framer-offset-parent-id": rt(t)["data-framer-offset-parent-id"]
    };
    !MD(t) && r && (rt(g)["data-framer-name"] = r);
    let[b,m] = _D(l)
      , h = iC(l)
      , y = Bk(h);
    i && !(m && !y && Va(h)) ? (u.transformTemplate || (u.transformTemplate = Nu(i)),
    Object.assign(g, qk(i))) : u.transformTemplate || (u.transformTemplate = void 0),
    Hu(t, v);
    let w = BA(t)
      , C = !!D(ts)
      , S = VD(l, h, m, C)
      , T = gV(he(it, {
        children: [w ? k(Gk, {
            alt: t.alt ?? "",
            image: w,
            containerSize: m ?? void 0,
            nodeId: t.id && Ym(t.id),
            layoutId: f
        }) : null, c, k(NA, {
            ...s,
            border: o,
            layoutId: f
        })]
    }), S)
      , E = za(t.as)
      , {size: I, radius: O, shadow: B} = b;
    return I !== void 0 && (delete b.size,
    b.height === void 0 && (b.height = I),
    b.width === void 0 && (b.width = I)),
    O !== void 0 && (delete b.radius,
    b.borderRadius = O),
    B !== void 0 && (delete b.shadow,
    b.boxShadow = B),
    he(E, {
        ...g,
        ...u,
        layoutId: f,
        style: b,
        ref: v,
        children: [T, a]
    })
})
  , cu = Ie(function(t, n) {
    let {visible: r=!0} = t;
    return r ? k(LD, {
        ...t,
        ref: n
    }) : null
});
function VD(e, t, n, r) {
    if (r)
        return n ? {
            width: n.width,
            height: n.height
        } : 1;
    let {_usesDOMRect: i} = e
      , {widthType: o=0, heightType: s=0, width: a, height: l} = t;
    return n && !i ? n : o === 0 && s === 0 && typeof a == "number" && typeof l == "number" ? {
        width: a,
        height: l
    } : i || e.positionFixed || e.positionAbsolute ? 2 : 0
}
var eg = "__LAYOUT_TREE_ROOT"
  , oC = x.createContext({
    schedulePromoteTree: () => {}
    ,
    scheduleProjectionDidUpdate: () => {}
    ,
    initLead: () => {}
})
  , AD = class extends we {
    constructor() {
        super(...arguments),
        R(this, "shouldAnimate", !1),
        R(this, "transition"),
        R(this, "lead"),
        R(this, "follow"),
        R(this, "scheduledPromotion", !1),
        R(this, "scheduledDidUpdate", !1),
        R(this, "scheduleProjectionDidUpdate", () => {
            this.scheduledDidUpdate = !0
        }
        ),
        R(this, "schedulePromoteTree", (e, t, n) => {
            this.follow = this.lead,
            this.shouldAnimate = n,
            this.lead = e,
            this.transition = t,
            this.scheduledPromotion = !0
        }
        ),
        R(this, "initLead", (e, t) => {
            this.follow = this.lead,
            this.lead = e,
            this.follow && t && (this.follow.layoutMaybeMutated = !0)
        }
        ),
        R(this, "sharedLayoutContext", {
            schedulePromoteTree: this.schedulePromoteTree,
            scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate,
            initLead: this.initLead
        })
    }
    getSnapshotBeforeUpdate() {
        var e;
        if (!this.scheduledPromotion || !this.lead || !this.follow)
            return null;
        let t = !!((e = this.lead) != null && e.layoutMaybeMutated) && !this.shouldAnimate;
        return this.lead.projectionNodes.forEach(n => {
            var r;
            n?.promote({
                needsReset: t,
                transition: this.shouldAnimate ? this.transition : void 0,
                preserveFollowOpacity: n.options.layoutId === eg && !((r = this.follow) != null && r.isExiting)
            })
        }
        ),
        this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(),
        this.lead.layoutMaybeMutated = !1,
        this.transition = void 0,
        this.scheduledPromotion = !1,
        null
    }
    componentDidUpdate() {
        var e, t;
        if (!this.lead)
            return null;
        this.scheduledDidUpdate && ((t = (e = this.lead.rootProjectionNode) == null ? void 0 : e.root) == null || t.didUpdate(),
        this.scheduledDidUpdate = !1)
    }
    render() {
        return k(oC.Provider, {
            value: this.sharedLayoutContext,
            children: this.props.children
        })
    }
}
  , DD = {
    width: "100%",
    height: "100%",
    backgroundColor: "none"
};
function zD(e) {
    return k(Jt.div, {
        layoutId: eg,
        style: DD,
        children: e.children
    })
}
function g1(e, t) {
    jn(e) ? e(t) : sC(e) && (e.current = t)
}
function sC(e) {
    return Re(e) && "current"in e
}
function BD() {
    let e = mt( () => new Set)
      , t = mt( () => new Map);
    return mt( () => (n, r) => ({
        get current() {
            return n.current
        },
        set current(i) {
            r && r(i),
            n.current = i;
            let o = i === null;
            e.forEach(s => {
                if (o && t.has(s))
                    return;
                let a = s(i);
                a && t.set(s, a)
            }
            ),
            o && (t.forEach(s => s()),
            t.clear())
        },
        observe(i, o=!1) {
            e.has(i) || (e.add(i),
            !o && n.current && i(n.current))
        },
        unobserve(i) {
            i && e.delete(i)
        },
        cleanup(i) {
            var o;
            return !i || !t.has(i) ? !1 : ((o = t.get(i)) == null || o(),
            !0)
        }
    }))
}
function aC(e) {
    let t = V(null)
      , n = BD();
    return mt( () => sC(e) ? n(e) : jn(e) ? n(t, e) : n(t))
}
function Yi(e, t, n) {
    var r;
    let i = V()
      , o = V();
    if (se( () => {
        o.current !== void 0 && (o.current = !0)
    }
    , [n]),
    !e)
        return;
    let s = o.current;
    if (s) {
        o.current = !1,
        e.cleanup(i.current) || (r = i.current) == null || r.call(i, null);
        let a = e.current;
        a && t?.(a)
    }
    i.current !== t && (e.unobserve(i.current),
    i.current = t,
    e.observe(t, s),
    o.current === void 0 && (o.current = !1))
}
var $D = class {
    constructor(e) {
        R(this, "sharedIntersectionObserver"),
        R(this, "callbacks", new WeakMap),
        document && (this.sharedIntersectionObserver = new IntersectionObserver(this.resizeObserverCallback.bind(this),e))
    }
    resizeObserverCallback(e, t) {
        for (let n of e) {
            let r = this.callbacks.get(n.target);
            r && r([n], t)
        }
    }
    observeElementWithCallback(e, t) {
        this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e),
        this.callbacks.set(e, t))
    }
    unobserve(e) {
        this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e),
        this.callbacks.delete(e))
    }
    get root() {
        var e;
        return (e = this.sharedIntersectionObserver) == null ? void 0 : e.root
    }
}
  , ND = ve(new Map);
function jD(e, t, n) {
    if (typeof IntersectionObserver > "u")
        return;
    let r = mt( () => `${n.rootMargin}`)
      , i = D(ND)
      , {enabled: o} = n;
    Yi(e, s => {
        var a;
        if (!o || s === null)
            return;
        let l = i.get(r);
        if (!l || l.root !== ((a = n.root) == null ? void 0 : a.current)) {
            let {root: c, ...u} = n;
            l = new $D({
                ...u,
                root: c?.current
            }),
            i.set(r, l)
        }
        return l.observeElementWithCallback(s, t),
        () => {
            l?.unobserve(s)
        }
    }
    , [o])
}
var HD = new Array(100).fill(void 0).map( (e, t) => t * .01)
  , WD = x.createContext(null);
function UD(e, t, n) {
    let r = x.useRef({
        isInView: !1,
        hasAnimatedOnce: !1
    })
      , {enabled: i, animateOnce: o, threshold: s, rootMargin: a="0px 0px 0px 0px"} = n
      , l = x.useCallback( ([c]) => {
        if (!c)
            return;
        let {isInView: u, hasAnimatedOnce: f} = r.current
          , d = qD(c, s?.y ?? 0);
        if (d && !u) {
            if (o && f)
                return;
            r.current.hasAnimatedOnce = !0,
            r.current.isInView = !0,
            t(!0);
            return
        }
        if (!d && u) {
            if (r.current.isInView = !1,
            o)
                return;
            t(!1);
            return
        }
    }
    , [o, s?.y, t]);
    jD(e, l, {
        threshold: HD,
        rootMargin: a,
        enabled: i ?? !0
    })
}
function GD(e, t) {
    return t.height === 0 ? 0 : e.height / Math.min(t.height, nt.innerHeight)
}
function qD({boundingClientRect: e, intersectionRect: t, isIntersecting: n}, r) {
    return e.height === 0 ? n : n && GD(t, e) >= r
}
var dH = hr(Au(), 1);
var pH = hr(Au(), 1);
var v1 = (e, t) => Object.prototype.hasOwnProperty.call(e, t)
  , Mr = Symbol("private")
  , sm = ( () => {
    function e(t={}, n=!1, r=!0) {
        let i = {
            [Mr]: {
                makeAnimatables: n,
                observeAnimatables: r,
                observers: new _k,
                reset() {
                    for (let s in o)
                        if (v1(o, s)) {
                            let a = v1(t, s) ? rt(t)[s] : void 0;
                            a !== void 0 ? o[s] = a : delete o[s]
                        }
                },
                transactions: new Set
            }
        }
          , o = new Proxy(i,YD);
        return Object.assign(o, t),
        o
    }
    return e.resetObject = t => t[Mr].reset(),
    e.addObserver = (t, n) => t[Mr].observers.add(n),
    e
}
)()
  , XD = class {
    constructor() {
        R(this, "set", (e, t, n, r) => {
            if (t === Mr)
                return !1;
            let i = e[Mr], o, s;
            if (Nn(n) ? (o = n,
            s = o.get()) : s = n,
            i.makeAnimatables && typeof n != "function" && typeof n != "object" && !o && (o = at(n)),
            i.observeAnimatables && o) {
                let u = i.transactions;
                o.onUpdate({
                    update: (f, d) => {
                        d && u.add(d),
                        i.observers.notify({
                            value: r
                        }, d)
                    }
                    ,
                    finish: f => {
                        u.delete(f) && i.observers.finishTransaction(f)
                    }
                })
            }
            let a = !1
              , l = !0
              , c = rt(e)[t];
            if (c !== void 0) {
                Nn(c) ? (l = c.get() !== s,
                c.set(s)) : (l = c !== s,
                rt(e)[t] = s);
                let u = s !== null && typeof s == "object";
                (Array.isArray(s) || u) && (l = !0),
                a = !0
            } else
                o && (n = o),
                a = Reflect.set(e, t, n);
            return l && i.observers.notify({
                value: r
            }),
            a
        }
        ),
        R(this, "get", (e, t, n) => {
            if (t === Mr)
                return rt(e)[t];
            let r = Reflect.get(e, t, n);
            return typeof r == "function" ? r.bind(n) : r
        }
        )
    }
    deleteProperty(e, t) {
        let n = Reflect.deleteProperty(e, t);
        return e[Mr].observers.notify({
            value: e
        }),
        n
    }
    ownKeys(e) {
        let t = Reflect.ownKeys(e)
          , n = t.indexOf(Mr);
        return n !== -1 && t.splice(n, 1),
        t
    }
    getOwnPropertyDescriptor(e, t) {
        if (t !== Mr)
            return Reflect.getOwnPropertyDescriptor(e, t)
    }
}
  , YD = new XD;
var KD = "opacity";
function QD(e) {
    return KD in e
}
function ZD(e, t) {
    if (!QD(e))
        return;
    let n = at.getNumber(e.opacity);
    n !== 1 && (t.opacity = n)
}
function JD(e) {
    let t = [];
    if (e && e.length) {
        let n = e.map(r => `drop-shadow(${r.x}px ${r.y}px ${r.blur}px ${r.color})`);
        t.push(...n)
    }
    return t
}
function lC(e, t) {
    if (!e.shadows || e.shadows.length === 0)
        return;
    let n = e.shadows.map(r => `${r.x}px ${r.y}px ${r.blur}px ${r.color}`).join(", ");
    n && (t.textShadow = n)
}
function e3(e, t) {
    let n = [];
    ne(e.brightness) && n.push(`brightness(${e.brightness / 100})`),
    ne(e.contrast) && n.push(`contrast(${e.contrast / 100})`),
    ne(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`),
    ne(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`),
    ne(e.invert) && n.push(`invert(${e.invert / 100})`),
    ne(e.saturate) && n.push(`saturate(${e.saturate / 100})`),
    ne(e.sepia) && n.push(`sepia(${e.sepia / 100})`),
    ne(e.blur) && n.push(`blur(${e.blur}px)`),
    e.dropShadows && n.push(...JD(e.dropShadows)),
    n.length !== 0 && (t.filter = t.WebkitFilter = n.join(" "))
}
function t3(e, t) {
    ne(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`)
}
function tg(e, t) {
    t3(e, t),
    e3(e, t)
}
var n3 = class extends we {
    constructor() {
        super(...arguments),
        R(this, "layoutMaybeMutated"),
        R(this, "projectionNodes", new Map),
        R(this, "rootProjectionNode"),
        R(this, "isExiting"),
        R(this, "shouldPreserveFollowOpacity", e => e.options.layoutId === eg && !this.props.isExiting),
        R(this, "switchLayoutGroupContext", {
            register: e => this.addChild(e),
            deregister: e => this.removeChild(e),
            transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0,
            shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity
        })
    }
    componentDidMount() {
        this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout)
    }
    shouldComponentUpdate(e) {
        let {isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: o, sharedLayoutContext: s} = e;
        if (this.isExiting = n,
        t === void 0)
            return !0;
        let a = !this.props.isLead && !!t
          , l = this.props.isExiting && !n
          , c = a || l
          , u = !!this.props.isLead && !t
          , f = this.props.isOverlayed !== r;
        return (c || u) && this.projectionNodes.forEach(d => d?.willUpdate()),
        c ? s.schedulePromoteTree(this, o, !!i) : f && s.scheduleProjectionDidUpdate(),
        !!c && !!i
    }
    addChild(e) {
        let t = e.options.layoutId;
        t && (this.projectionNodes.set(t, e),
        this.setRootChild(e))
    }
    setRootChild(e) {
        if (!this.rootProjectionNode)
            return this.rootProjectionNode = e;
        this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e
    }
    removeChild(e) {
        let t = e.options.layoutId;
        t && this.projectionNodes.delete(t)
    }
    render() {
        return k(Sl.Provider, {
            value: this.switchLayoutGroupContext,
            children: this.props.children
        })
    }
}
  , r3 = e => {
    let t = x.useContext(oC);
    return k(n3, {
        ...e,
        sharedLayoutContext: t
    })
}
  , i3 = x.createContext(!0);
function o3() {
    return new Map
}
function s3() {
    return mt(o3)
}
var cC = ve({
    register: () => {}
    ,
    deregister: () => {}
})
  , a3 = ({isCurrent: e, isOverlayed: t, children: n}) => {
    let r = s3()
      , i = K(a => {
        if (r.has(a)) {
            console.warn("NavigationTargetWrapper: already registered");
            return
        }
        r.set(a, void 0)
    }
    , [r])
      , o = K(a => {
        let l = r.get(a);
        l?.(),
        r.delete(a)
    }
    , [r])
      , s = V({
        register: i,
        deregister: o
    }).current;
    return $( () => (r.forEach( (a, l) => {
        let c = l(e, t);
        r.set(l, jn(c) ? c : void 0)
    }
    ),
    () => {
        r.forEach( (a, l) => {
            a && (a(),
            r.set(l, void 0))
        }
        )
    }
    ), [e, t, r]),
    k(cC.Provider, {
        value: s,
        children: n
    })
}
;
function uC(e, t=[]) {
    let {register: n, deregister: r} = D(cC);
    $( () => {
        if (e)
            return n(e),
            () => r(e)
    }
    , [n, r, ...t])
}
var am = x.memo(function({isLayeredContainer: t, isCurrent: n, isPrevious: r, isOverlayed: i=!1, visible: o, transitionProps: s, children: a, backdropColor: l, onTapBackdrop: c, backfaceVisible: u, exitBackfaceVisible: f, animation: d, exitAnimation: p, instant: v, initialProps: g, exitProps: b, position: m={
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
}, withMagicMotion: h, index: y, areMagicMotionLayersPresent: w, id: C, isInitial: S}) {
    let T = rb()
      , E = D(po)
      , {persistLayoutIdCache: I} = D(Zo)
      , O = V({
        wasCurrent: void 0,
        wasPrevious: !1,
        wasBeingRemoved: !1,
        wasReset: !0,
        origins: y1({}, g, s)
    })
      , B = V(null)
      , z = E !== null && !E.isPresent;
    n && O.current.wasCurrent === void 0 && I(),
    $( () => {
        if (t || !T)
            return;
        if (z) {
            O.current = {
                ...O.current,
                wasBeingRemoved: z
            };
            return
        }
        let {wasPrevious: ae, wasCurrent: X} = O.current
          , Ye = n && !X || !z && O.current.wasBeingRemoved && n
          , Ce = r && !ae
          , Ke = y1(O.current.origins, g, s)
          , Ee = O.current.wasReset;
        Ye || Ce ? (T.stop(),
        T.start({
            zIndex: y,
            ...Ke,
            ...s
        }),
        Ee = !1) : Ee === !1 && (T.stop(),
        T.set({
            zIndex: y,
            ...Wi,
            opacity: 0
        }),
        Ee = !0),
        O.current = {
            wasCurrent: !!n,
            wasPrevious: !!r,
            wasBeingRemoved: !1,
            wasReset: Ee,
            origins: Ke
        }
    }
    , [n, r, z]);
    let j = v ? {
        type: !1
    } : "velocity"in d ? {
        ...d,
        velocity: 0
    } : d
      , J = v ? {
        type: !1
    } : p || d
      , H = {
        ...m
    };
    (H.left === void 0 || H.right === void 0) && (H.width = "auto"),
    (H.top === void 0 || H.bottom === void 0) && (H.height = "auto");
    let ie = (b1(s) || b1(g)) && (t || n || r) ? 1200 : void 0
      , q = {
        ...Wi,
        ...O.current.origins
    }
      , re = t ? {
        initial: {
            ...q,
            ...g
        },
        animate: {
            ...q,
            ...s,
            transition: j
        },
        exit: {
            ...q,
            ...b,
            transition: d
        }
    } : {
        animate: T,
        exit: {
            ...q,
            ...b,
            transition: J
        }
    }
      , U = !(z || w === !1)
      , pe = !!n && U;
    return he(cu, {
        "data-framer-component-type": "NavigationContainerWrapper",
        width: "100%",
        height: "100%",
        style: {
            position: "absolute",
            transformStyle: "flat",
            backgroundColor: "transparent",
            overflow: "hidden",
            zIndex: t || z || n && h ? y : void 0,
            pointerEvents: void 0,
            visibility: o ? "visible" : "hidden",
            perspective: ie
        },
        children: [t && k(cu, {
            width: "100%",
            height: "100%",
            "data-framer-component-type": "NavigationContainerBackdrop",
            transition: d,
            initial: {
                opacity: v && o ? 1 : 0
            },
            animate: {
                opacity: 1
            },
            exit: {
                opacity: 0
            },
            backgroundColor: l || "transparent",
            onTap: z ? void 0 : c
        }), k(cu, {
            ...H,
            ...re,
            transition: {
                default: j,
                originX: {
                    type: !1
                },
                originY: {
                    type: !1
                },
                originZ: {
                    type: !1
                }
            },
            backgroundColor: "transparent",
            backfaceVisible: z ? f : u,
            "data-framer-component-type": "NavigationContainer",
            "data-framer-is-current-navigation-target": !!n,
            style: {
                pointerEvents: void 0,
                opacity: n && S || t || n && h ? 1 : 0
            },
            "data-is-present": U ? void 0 : !1,
            ref: B,
            children: k(WD.Provider, {
                value: B,
                children: k(i3.Provider, {
                    value: pe,
                    children: k(a3, {
                        isCurrent: pe,
                        isOverlayed: i,
                        children: k(r3, {
                            isLead: n,
                            animatesLayout: !!h,
                            transition: j,
                            isExiting: !U,
                            isOverlayed: i,
                            id: C,
                            children: a
                        })
                    })
                })
            })
        })]
    })
}, l3);
function l3(e, t) {
    return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed)
}
function y1(e, t, n) {
    let r = {
        ...e
    };
    return t && (ne(t.originX) && (r.originX = t.originX),
    ne(t.originY) && (r.originY = t.originY),
    ne(t.originZ) && (r.originZ = t.originZ)),
    n && (ne(n.originX) && (r.originX = n.originX),
    ne(n.originY) && (r.originY = n.originY),
    ne(n.originZ) && (r.originZ = n.originZ)),
    r
}
function b1(e) {
    var t, n, r;
    if (!e || !("rotateX"in e || "rotateY"in e || "z"in e))
        return !1;
    let o = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0
      , s = ((t = e?.transition) == null ? void 0 : t.rotateX.from) !== 0 || ((n = e?.transition) == null ? void 0 : n.rotateY.from) !== 0 || ((r = e?.transition) == null ? void 0 : r.z.from) !== 0;
    return o || s
}
var Wi = {
    x: 0,
    y: 0,
    z: 0,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    skew: 0,
    skewX: 0,
    skewY: 0,
    originX: .5,
    originY: .5,
    originZ: 0,
    opacity: 1
}
  , c3 = class {
    constructor() {
        R(this, "warning", () => {
            Fa("The Navigator API is only available inside of Framer: https://www.framer.com/")
        }
        ),
        R(this, "goBack", () => this.warning()),
        R(this, "instant", () => this.warning()),
        R(this, "fade", () => this.warning()),
        R(this, "push", () => this.warning()),
        R(this, "modal", () => this.warning()),
        R(this, "overlay", () => this.warning()),
        R(this, "flip", () => this.warning()),
        R(this, "customTransition", () => this.warning()),
        R(this, "magicMotion", () => this.warning())
    }
}
  , u3 = new c3
  , f3 = ve(u3)
  , ht = {
    Fade: {
        exit: {
            opacity: 0
        },
        enter: {
            opacity: 0
        }
    },
    PushLeft: {
        exit: {
            x: "-30%"
        },
        enter: {
            x: "100%"
        }
    },
    PushRight: {
        exit: {
            x: "30%"
        },
        enter: {
            x: "-100%"
        }
    },
    PushUp: {
        exit: {
            y: "-30%"
        },
        enter: {
            y: "100%"
        }
    },
    PushDown: {
        exit: {
            y: "30%"
        },
        enter: {
            y: "-100%"
        }
    },
    Instant: {
        animation: {
            type: !1
        },
        enter: {
            opacity: 0
        }
    },
    Modal: {
        overCurrentContext: !0,
        goBackOnTapOutside: !0,
        position: {
            center: !0
        },
        enter: {
            opacity: 0,
            scale: 1.2
        }
    },
    OverlayLeft: {
        overCurrentContext: !0,
        goBackOnTapOutside: !0,
        position: {
            right: 0,
            top: 0,
            bottom: 0
        },
        enter: {
            x: "100%"
        }
    },
    OverlayRight: {
        overCurrentContext: !0,
        goBackOnTapOutside: !0,
        position: {
            left: 0,
            top: 0,
            bottom: 0
        },
        enter: {
            x: "-100%"
        }
    },
    OverlayUp: {
        overCurrentContext: !0,
        goBackOnTapOutside: !0,
        position: {
            bottom: 0,
            left: 0,
            right: 0
        },
        enter: {
            y: "100%"
        }
    },
    OverlayDown: {
        overCurrentContext: !0,
        goBackOnTapOutside: !0,
        position: {
            top: 0,
            left: 0,
            right: 0
        },
        enter: {
            y: "-100%"
        }
    },
    FlipLeft: {
        backfaceVisible: !1,
        exit: {
            rotateY: -180
        },
        enter: {
            rotateY: 180
        }
    },
    FlipRight: {
        backfaceVisible: !1,
        exit: {
            rotateY: 180
        },
        enter: {
            rotateY: -180
        }
    },
    FlipUp: {
        backfaceVisible: !1,
        exit: {
            rotateX: 180
        },
        enter: {
            rotateX: -180
        }
    },
    FlipDown: {
        backfaceVisible: !1,
        exit: {
            rotateX: -180
        },
        enter: {
            rotateX: 180
        }
    },
    MagicMotion: {
        withMagicMotion: !0
    }
};
function d3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "right") {
    case "right":
        return ht.PushLeft;
    case "left":
        return ht.PushRight;
    case "bottom":
        return ht.PushUp;
    case "top":
        return ht.PushDown
    }
}
function h3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "bottom") {
    case "right":
        return ht.OverlayLeft;
    case "left":
        return ht.OverlayRight;
    case "bottom":
        return ht.OverlayUp;
    case "top":
        return ht.OverlayDown
    }
}
function p3(e) {
    switch (e && e.appearsFrom ? e.appearsFrom : "bottom") {
    case "right":
        return ht.FlipLeft;
    case "left":
        return ht.FlipRight;
    case "bottom":
        return ht.FlipUp;
    case "top":
        return ht.FlipDown
    }
}
var m3 = () => ({
    current: -1,
    previous: -1,
    currentOverlay: -1,
    previousOverlay: -1,
    visualIndex: 0,
    overlayItemId: 0,
    historyItemId: 0,
    history: [],
    overlayStack: [],
    containers: {},
    containerIndex: {},
    containerVisualIndex: {},
    containerIsRemoved: {},
    transitionForContainer: {},
    previousTransition: null
});
function x1(e, t) {
    switch (t.type) {
    case "addOverlay":
        return v3(e, t.transition, t.component);
    case "removeOverlay":
        return y3(e);
    case "add":
        return fC(e, t.key, t.transition, t.component);
    case "remove":
        return dC(e);
    case "update":
        return g3(e, t.key, t.component);
    case "back":
        return b3(e);
    case "forward":
        return x3(e);
    default:
        return
    }
}
function g3(e, t, n) {
    return {
        ...e,
        containers: {
            ...e.containers,
            [t]: n
        }
    }
}
function v3(e, t, n) {
    let r = e.overlayStack[e.currentOverlay];
    if (r && r.component === n)
        return;
    let i = e.overlayItemId + 1
      , o = [...e.overlayStack, {
        key: `stack-${i}`,
        component: n,
        transition: t
    }];
    return {
        ...e,
        overlayStack: o,
        overlayItemId: i,
        currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, o.length - 1)),
        previousOverlay: e.currentOverlay
    }
}
function y3(e) {
    return {
        ...e,
        overlayStack: [],
        currentOverlay: -1,
        previousOverlay: e.currentOverlay
    }
}
function fC(e, t, n, r) {
    e.containers[t] || (e.containers[t] = r),
    e.history = e.history.slice(0, e.current + 1),
    e.visualIndex = Math.max(e.history.length, 0);
    let i = e.history[e.history.length - 1]
      , o = i && i.key === t;
    if (e.overlayStack = [],
    o && e.currentOverlay > -1)
        return {
            ...e,
            currentOverlay: -1,
            previousOverlay: e.currentOverlay
        };
    if (o)
        return;
    let s = e.containerVisualIndex[t]
      , a = e.containerIsRemoved[t]
      , l = i?.key && n.withMagicMotion ? C3(t, s, a, e.history) : !0;
    e.history.push({
        key: t,
        transition: n,
        visualIndex: l ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t]
    });
    let c = e.current + 1
      , u = e.current;
    for (let v in e.containerIndex)
        e.containerIndex[v] === c && (e.containerIndex[v] = k3(v, e.history));
    e.containerIndex[t] = c;
    let {containerVisualIndex: f, containerIsRemoved: d} = w3(e, t, l)
      , p = hC(c, u, e.history, e.containerIndex, e.transitionForContainer);
    return {
        ...e,
        current: c,
        previous: u,
        containerVisualIndex: f,
        containerIsRemoved: d,
        transitionForContainer: p,
        previousTransition: null,
        currentOverlay: -1,
        historyItemId: e.historyItemId + 1,
        previousOverlay: e.currentOverlay
    }
}
function b3(e) {
    let t = {
        ...e.containers
    }
      , n = dC(e);
    if (n)
        return n.containers = t,
        n
}
function x3(e) {
    let t = e.history[e.current + 1];
    if (!t)
        return;
    let {key: n, transition: r, component: i} = t
      , o = [...e.history]
      , s = fC(e, n, r, i);
    if (s)
        return s.history = o,
        s
}
function dC(e) {
    let t = [...e.history.slice(0, e.current + 1)];
    if (t.length === 1)
        return;
    let n = t.pop();
    if (!n)
        return;
    let r = t[t.length - 1];
    A(r, "The navigation history must have at least one component"),
    e.containerIndex[r.key] = t.length - 1,
    t.every(d => d.key !== n.key) && delete e.containers[n.key];
    let o = e.current - 1
      , s = e.current
      , {containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u} = S3(e, r, n)
      , f = hC(o, s, e.history, e.containerIndex, e.transitionForContainer);
    return {
        ...e,
        current: o,
        previous: s,
        containerIsRemoved: a,
        containerVisualIndex: l,
        previousTransition: c,
        visualIndex: u,
        transitionForContainer: f
    }
}
function w3(e, t, n) {
    let r = {
        containerVisualIndex: {
            ...e.containerVisualIndex
        },
        containerIsRemoved: {
            ...e.containerIsRemoved
        }
    };
    if (n)
        r.containerVisualIndex[t] = e.history.length - 1,
        r.containerIsRemoved[t] = !1;
    else {
        let i = e.containerVisualIndex[t];
        for (let[o,s] of Object.entries(e.containerVisualIndex))
            i !== void 0 && s > i && (r.containerIsRemoved[o] = !0)
    }
    return r
}
function S3(e, t, n) {
    let r = [t.key, n.key]
      , i = e.history[e.history.length - 2]
      , o = e.previousTransition === null ? null : {
        ...e.previousTransition
    }
      , s = {
        containerIsRemoved: {
            ...e.containerIsRemoved
        },
        containerVisualIndex: {
            ...e.containerVisualIndex
        },
        previousTransition: o,
        visualIndex: e.visualIndex
    };
    i && r.push(i.key);
    let a = e.containerVisualIndex[t.key]
      , l = e.containerVisualIndex[n.key]
      , c = a !== void 0 && l !== void 0 && a <= l || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1
      , u = t.visualIndex;
    return c ? (s.containerIsRemoved[n.key] = !0,
    s.containerVisualIndex[t.key] = u !== void 0 ? u : e.history.length - 1) : (s.visualIndex = e.visualIndex + 1,
    s.containerVisualIndex[t.key] = e.visualIndex + 1),
    n.transition.withMagicMotion && (s.previousTransition = n.transition || null),
    e.containerIsRemoved[t.key] = !1,
    s
}
function k3(e, t) {
    var n;
    for (let r = t.length; r > t.length; r--)
        if (((n = t[r]) == null ? void 0 : n.key) === e)
            return r;
    return -1
}
function hC(e, t, n, r, i) {
    let o = {
        ...i
    };
    for (let[s,a] of Object.entries(r)) {
        let l = T3(a, {
            current: e,
            previous: t,
            history: n
        });
        l && (o[s] = l)
    }
    return o
}
function C3(e, t, n, r) {
    return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(s => s.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(s => s.key === e) > -1)
}
function T3(e, t) {
    let {current: n, previous: r, history: i} = t;
    if (!(e !== n && e !== r)) {
        if (e === n && n > r) {
            let o = i[e];
            return eu("enter", o?.transition.enter, o?.transition.animation)
        }
        if (e === r && n > r) {
            let o = i[e + 1];
            return eu("exit", o?.transition.exit, o?.transition.animation)
        }
        if (e === n && n < r) {
            let o = i[e + 1];
            return eu("enter", o?.transition.exit, o?.transition.animation)
        }
        if (e === r && n < r) {
            let o = i[e];
            return eu("exit", o?.transition.enter, o?.transition.animation)
        }
    }
}
var R3 = Xi(Wi);
function eu(e, t, n) {
    let r = {}
      , i = {};
    return R3.forEach(o => {
        r[o] = Wi[o],
        i[o] = {
            ...n,
            from: Wi[o]
        }
    }
    ),
    t && Object.keys(t).forEach(o => {
        if (t[o] === void 0)
            return;
        let s = t[o]
          , a = typeof t[o] == "string" ? `${rt(Wi)[o]}%` : rt(Wi)[o];
        rt(r)[o] = e === "enter" ? a : s,
        i[o] = {
            ...n,
            from: e === "enter" ? s : a,
            velocity: 0
        }
    }
    ),
    {
        ...r,
        transition: {
            ...i
        }
    }
}
var E3 = x.createContext(void 0);
var pC = x.createContext(void 0)
  , F3 = ( () => {
    var e, t, n, r, i, o, s, a, l;
    return t = class extends we {
        constructor(c) {
            var u;
            super(c),
            Qt(this, n),
            Qt(this, i),
            Qt(this, a),
            Qt(this, e, null),
            R(this, "state", m3()),
            Qt(this, s, b => {
                if (!this.props.enabled && this.state.history.length > 0)
                    return;
                let m = x1(this.state, b);
                if (!m)
                    return;
                let {skipLayoutAnimation: h} = this.props
                  , y = m.history[m.current]
                  , w = b.type === "add" && b.transition.withMagicMotion || b.type === "forward" && y?.transition.withMagicMotion || b.type === "remove" && !!m.previousTransition
                  , C = () => {
                    var S;
                    this.setState(m),
                    y?.key && ((S = this.context) == null || S.call(this, y.key))
                }
                ;
                h && !w ? h(C) : C()
            }
            ),
            R(this, "goBack", () => {
                var b;
                if (!Nt(this, i, o).call(this))
                    return Qu(this, e, ((b = globalThis.event) == null ? void 0 : b.timeStamp) || null),
                    this.state.currentOverlay !== -1 ? de(this, s).call(this, {
                        type: "removeOverlay"
                    }) : de(this, s).call(this, {
                        type: "remove"
                    })
            }
            );
            let f = this.props.children;
            if (!f || !au(f) || !su(f))
                return;
            let d = {
                ...ht.Instant
            }
              , v = {
                type: "add",
                key: ((u = f.key) == null ? void 0 : u.toString()) || `stack-${this.state.historyItemId + 1}`,
                transition: d,
                component: f
            }
              , g = x1(this.state, v);
            g && (this.state = g)
        }
        componentDidMount() {
            var c;
            let u = this.state.history[this.state.current];
            u && ((c = this.context) == null || c.call(this, u.key))
        }
        UNSAFE_componentWillReceiveProps(c) {
            var u;
            let f = c.children;
            if (!au(f) || !su(f))
                return;
            let d = (u = f.key) == null ? void 0 : u.toString();
            d && (this.state.history.length === 0 ? Nt(this, a, l).call(this, f, ht.Instant) : de(this, s).call(this, {
                type: "update",
                key: d,
                component: f
            }))
        }
        componentWillUnmount() {
            var c, u;
            (u = (c = this.props).resetProjection) == null || u.call(c)
        }
        instant(c) {
            Nt(this, a, l).call(this, c, ht.Instant, void 0)
        }
        fade(c, u) {
            Nt(this, a, l).call(this, c, ht.Fade, u)
        }
        push(c, u) {
            Nt(this, a, l).call(this, c, d3(u), u)
        }
        modal(c, u) {
            Nt(this, a, l).call(this, c, ht.Modal, u)
        }
        overlay(c, u) {
            Nt(this, a, l).call(this, c, h3(u), u)
        }
        flip(c, u) {
            Nt(this, a, l).call(this, c, p3(u), u)
        }
        magicMotion(c, u) {
            Nt(this, a, l).call(this, c, ht.MagicMotion, u)
        }
        customTransition(c, u) {
            Nt(this, a, l).call(this, c, u)
        }
        render() {
            var c, u, f, d, p;
            let v = Nt(this, n, r).call(this, {
                overCurrentContext: !1
            })
              , g = Nt(this, n, r).call(this, {
                overCurrentContext: !0
            })
              , b = P3(g)
              , m = g.current > -1
              , h = this.state.history.length === 1
              , y = [];
            for (let[C,S] of Object.entries(this.state.containers)) {
                let T = this.state.containerIndex[C];
                A(T !== void 0, "Container's index must be registered");
                let E = this.state.containerVisualIndex[C];
                A(E !== void 0, "Container's visual index must be registered");
                let I = this.state.containerIsRemoved[C]
                  , O = this.state.history[T]
                  , B = this.state.transitionForContainer[C]
                  , z = T === this.state.current
                  , j = T === this.state.previous
                  , J = z ? !1 : I
                  , H = ((c = O?.transition) == null ? void 0 : c.withMagicMotion) || z && !!this.state.previousTransition;
                y.push(k(am, {
                    id: C,
                    index: E,
                    isInitial: h,
                    isCurrent: z,
                    isPrevious: j,
                    isOverlayed: m,
                    visible: z || j,
                    position: (u = O?.transition) == null ? void 0 : u.position,
                    instant: S1(T, v),
                    transitionProps: B,
                    animation: w1(T, v),
                    backfaceVisible: A3(T, v),
                    exitAnimation: (f = O?.transition) == null ? void 0 : f.animation,
                    exitBackfaceVisible: (d = O?.transition) == null ? void 0 : d.backfaceVisible,
                    exitProps: (p = O?.transition) == null ? void 0 : p.enter,
                    withMagicMotion: H,
                    areMagicMotionLayersPresent: J ? !1 : void 0,
                    children: k(zD, {
                        children: k1({
                            component: S,
                            transition: O?.transition
                        })
                    })
                }, C))
            }
            let w = this.state.overlayStack.map( (C, S) => k(am, {
                isLayeredContainer: !0,
                isCurrent: S === this.state.currentOverlay,
                position: C.transition.position,
                initialProps: V3(S, g),
                transitionProps: D3(S, g),
                instant: S1(S, g, !0),
                animation: w1(S, g),
                exitProps: C.transition.enter,
                visible: z3(S, g),
                backdropColor: M3(C.transition),
                backfaceVisible: L3(S, g),
                onTapBackdrop: B3(C.transition, this.goBack),
                index: this.state.current + 1 + S,
                children: k1({
                    component: C.component,
                    transition: C.transition
                })
            }, C.key));
            return k(cu, {
                "data-framer-component-type": "NavigationRoot",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                position: "relative",
                style: {
                    overflow: "hidden",
                    backgroundColor: "unset",
                    pointerEvents: void 0,
                    ...this.props.style
                },
                children: k(f3.Provider, {
                    value: this,
                    children: he(pC.Provider, {
                        value: h,
                        children: [k(am, {
                            isLayeredContainer: !0,
                            position: void 0,
                            initialProps: {},
                            instant: !1,
                            transitionProps: _3(b),
                            animation: I3(b),
                            backfaceVisible: O3(b),
                            visible: !0,
                            backdropColor: void 0,
                            onTapBackdrop: void 0,
                            index: 0,
                            children: k(GL, {
                                children: k(AD, {
                                    children: k(Pd, {
                                        presenceAffectsLayout: !1,
                                        children: y
                                    })
                                })
                            })
                        }), k(Pd, {
                            children: w
                        })]
                    })
                })
            })
        }
    }
    ,
    e = new WeakMap,
    n = new WeakSet,
    r = function(c) {
        let {current: u, previous: f, currentOverlay: d, previousOverlay: p} = this.state;
        return c.overCurrentContext ? {
            current: d,
            previous: p,
            history: this.state.overlayStack
        } : {
            current: u,
            previous: f,
            history: this.state.history
        }
    }
    ,
    i = new WeakSet,
    o = function() {
        return globalThis.event ? de(this, e) === globalThis.event.timeStamp : !1
    }
    ,
    s = new WeakMap,
    a = new WeakSet,
    l = function(c, u, f) {
        var d, p;
        if (Nt(this, i, o).call(this) || (Qu(this, e, ((d = globalThis.event) == null ? void 0 : d.timeStamp) || null),
        !c || !au(c) || !su(c)))
            return;
        let v = {
            ...u,
            ...f
        };
        if (!!v.overCurrentContext)
            return de(this, s).call(this, {
                type: "addOverlay",
                transition: v,
                component: c
            });
        let b = ((p = c.key) == null ? void 0 : p.toString()) || `stack-${this.state.historyItemId + 1}`;
        de(this, s).call(this, {
            type: "add",
            key: b,
            transition: v,
            component: c
        })
    }
    ,
    R(t, "defaultProps", {
        enabled: !0
    }),
    R(t, "contextType", E3),
    t
}
)()
  , mC = {
    stiffness: 500,
    damping: 50,
    restDelta: 1,
    type: "spring"
};
function P3(e) {
    let t, n;
    return e.current !== -1 ? t = e.history[e.current] : n = e.history[e.previous],
    {
        currentOverlayItem: t,
        previousOverlayItem: n
    }
}
function _3({currentOverlayItem: e}) {
    return e && e.transition.exit
}
function I3({currentOverlayItem: e, previousOverlayItem: t}) {
    return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : mC
}
function O3({currentOverlayItem: e, previousOverlayItem: t}) {
    return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible
}
function M3(e) {
    if (e.backdropColor)
        return e.backdropColor;
    if (e.overCurrentContext)
        return "rgba(4,4,15,.4)"
}
function L3(e, t) {
    let {current: n, history: r} = t;
    if (e === n) {
        let i = r[e];
        return i && i.transition ? i.transition.backfaceVisible : !0
    } else if (e < n) {
        let i = r[e + 1];
        return i && i.transition ? i.transition.backfaceVisible : !0
    } else {
        let i = r[e];
        return i && i.transition ? i.transition.backfaceVisible : !0
    }
}
function V3(e, t) {
    let n = t.history[e];
    if (n)
        return n.transition.enter
}
function A3(e, t) {
    var n, r, i, o;
    let {current: s, previous: a, history: l} = t;
    return e === a && s > a || e === s && s < a ? (r = (n = l[e + 1]) == null ? void 0 : n.transition) == null ? void 0 : r.backfaceVisible : (o = (i = l[e]) == null ? void 0 : i.transition) == null ? void 0 : o.backfaceVisible
}
function D3(e, t) {
    let {current: n, history: r} = t;
    if (e !== n)
        if (e < n) {
            let i = r[e + 1];
            if (i && i.transition)
                return i.transition.exit
        } else {
            let i = r[e];
            if (i && i.transition)
                return i.transition.enter
        }
}
function w1(e, t) {
    let {current: n, previous: r, history: i} = t
      , o = r > n ? r : n;
    if (e < o) {
        let s = i[e + 1];
        if (s && s.transition.animation)
            return s.transition.animation
    } else if (e !== o) {
        let s = i[e];
        if (s && s.transition.animation)
            return s.transition.animation
    } else {
        let s = i[e];
        if (s?.transition.animation)
            return s.transition.animation
    }
    return mC
}
function S1(e, t, n) {
    let {current: r, previous: i, history: o} = t;
    return !!(n && o.length > 1 || e !== i && e !== r || r === i)
}
function z3(e, t) {
    let {current: n, previous: r} = t;
    return e > n && e > r ? !1 : e === n
}
function k1(e) {
    return x.Children.map(e.component, n => {
        var r;
        if (!au(n) || !su(n) || !n.props)
            return n;
        let i = {
            style: n.props.style ?? {}
        }
          , o = (r = e?.transition) == null ? void 0 : r.position
          , s = !o || o.left !== void 0 && o.right !== void 0
          , a = !o || o.top !== void 0 && o.bottom !== void 0
          , l = "style"in n.props ? Re(n.props.style) : !0;
        return s && ("width"in n.props && (i.width = "100%"),
        l && (i.style.width = "100%")),
        a && ("height"in n.props && (i.height = "100%"),
        l && (i.style.height = "100%")),
        x.cloneElement(n, i)
    }
    )
}
function B3(e, t) {
    if (e.goBackOnTapOutside !== !1)
        return t
}
function $3(e) {
    let t = ob()
      , n = Ad();
    return x.useInsertionEffect( () => {
        Da()
    }
    , []),
    k(F3, {
        ...e,
        resetProjection: t,
        skipLayoutAnimation: n,
        children: e.children
    })
}
var _H = hr(Au(), 1);
var VH = hr(Bm(), 1);
function N3(e, t) {
    let n, r = (...o) => {
        nt.clearTimeout(n),
        n = nt.setTimeout(e, t, ...o)
    }
    , i = () => {
        nt.clearTimeout(n)
    }
    ;
    return r.cancel = i,
    r
}
function bu(...e) {
    return e.filter(Boolean).join(" ")
}
var j3 = ( () => {
    function e(t={}) {
        let n = sm(t, !1, !1);
        return e.addData(n),
        n
    }
    return e._stores = [],
    e.addData = t => {
        e._stores.push(t)
    }
    ,
    e.reset = () => {
        e._stores.forEach(t => sm.resetObject(t))
    }
    ,
    e.addObserver = (t, n) => sm.addObserver(t, n),
    e
}
)()
  , lm = j3;
var H3 = {
    update: 0
}
  , W3 = x.createContext({
    update: NaN
});
var U3 = class extends we {
    constructor() {
        super(...arguments),
        R(this, "observers", []),
        R(this, "state", H3),
        R(this, "taskAdded", !1),
        R(this, "frameTask", () => {
            this.setState({
                update: this.state.update + 1
            }),
            this.taskAdded = !1
        }
        ),
        R(this, "observer", () => {
            this.taskAdded || (this.taskAdded = !0,
            Mk.addFrameTask(this.frameTask))
        }
        )
    }
    componentWillUnmount() {
        this.observers.map(e => e()),
        lm.reset()
    }
    render() {
        let {children: e} = this.props;
        return this.observers.map(t => t()),
        this.observers = [],
        lm._stores.forEach(t => {
            let n = lm.addObserver(t, this.observer);
            this.observers.push(n)
        }
        ),
        k(W3.Provider, {
            value: {
                ...this.state
            },
            children: e
        })
    }
}
  , a8 = hr(Au(), 1);
var gC = "__framer__"
  , G3 = ( () => gC.length)();
function q3(e) {
    if (e.startsWith(gC))
        return e.substr(G3)
}
var ur = ["opacity", "x", "y", "scale", "rotate", "rotateX", "rotateY", "skewX", "skewY", "transformPerspective"]
  , xu = e => ({
    x: Ge(e?.x ?? 0),
    y: Ge(e?.y ?? 0),
    opacity: Ge(e?.opacity ?? 1),
    scale: Ge(e?.scale ?? 1),
    rotate: Ge(e?.rotate ?? 0),
    rotateX: Ge(e?.rotateX ?? 0),
    rotateY: Ge(e?.rotateY ?? 0),
    skewX: Ge(e?.skewX ?? 0),
    skewY: Ge(e?.skewY ?? 0),
    transformPerspective: Ge(e?.transformPerspective ?? 0)
})
  , Je = {
    x: 0,
    y: 0,
    scale: 1,
    opacity: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    skewX: 0,
    skewY: 0,
    transformPerspective: 0
};
function vC(e) {
    return e in Je
}
function yC(e, t) {
    let n = mt( () => ({
        values: xu(t ? e : void 0)
    }));
    return x.useEffect( () => {
        if (!t)
            for (let r of ur) {
                let i = Je[r];
                et(i) || n.values[r].set(i)
            }
    }
    , [n, t]),
    n
}
var X3 = new Set(["loopEffectEnabled", "loopTransition", "loop", "loopRepeatType", "loopRepeatDelay"])
  , Y3 = () => {
    let e = V();
    return $( () => () => {
        clearTimeout(e.current)
    }
    , []),
    async t => new Promise(n => {
        e.current = setTimeout( () => {
            n(!0)
        }
        , t * 1e3)
    }
    )
}
;
function K3({loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: i}) {
    let o = ki()
      , s = mt(xu)
      , a = x.useRef(!1)
      , l = Y3()
      , c = async () => {
        if (!i)
            return;
        let d = n || void 0
          , p = a.current && r === "mirror"
          , v = p ? Je : i
          , g = p ? i : Je;
        return a.current = !a.current,
        Promise.all(ur.map(b => {
            if (!(o && b !== "opacity"))
                return s[b].set(g[b] ?? Je[b]),
                new Promise(m => {
                    let h = {
                        ...d,
                        onComplete: () => m()
                    }
                      , y = v[b] ?? g[b];
                    typeof y == "number" && Zn(s[b], y, h)
                }
                )
        }
        ))
    }
      , u = async () => {
        e && (await c(),
        await l(t ?? 0),
        await u())
    }
      , f = K( () => {
        ur.forEach(d => {
            s[d].stop()
        }
        ),
        ur.forEach(d => {
            s[d].set(Je[d])
        }
        ),
        a.current = !1
    }
    , [s]);
    return x.useEffect( () => (e && i ? u() : f(),
    () => f()), [e]),
    x.useMemo( () => ({
        values: s,
        style: e ? {
            willChange: "transform"
        } : {}
    }), [s, e])
}
function Q3(e, t, n, r, i) {
    let o = n / 100 - 1
      , s = i ? (t - r) * o : 0
      , a = -e * o;
    return s + a
}
var Z3 = new Set(["speed", "adjustPosition", "offset", "parallaxTransformEnabled"]);
function J3(e, t, n) {
    let {speed: r=100, offset: i=0, adjustPosition: o=!1, parallaxTransformEnabled: s} = e
      , a = x.useRef(null)
      , l = ki()
      , c = x.useCallback(v => a.current === null || r === 100 ? 0 : Q3(v, a.current, r, i, o), [a, r, i, o])
      , {scrollY: u} = Y0()
      , f = Vt(u, c)
      , d = Qn(o && a.current === null ? "hidden" : n)
      , p = Qn(0);
    return Yi(t, v => {
        v !== null && (Z.read( () => {
            var g;
            a.current = ((g = v.getBoundingClientRect()) == null ? void 0 : g.top) ?? 0
        }
        ),
        Z.update( () => {
            f.set(c(u.get())),
            o && d.set(n ?? "initial")
        }
        ))
    }
    , [o]),
    {
        values: {
            y: l || !s ? p : f
        },
        style: s ? {
            visibility: d,
            willChange: "transform"
        } : void 0
    }
}
function ez(e) {
    if (!(xe(e) || !Re(e)))
        return e?.transition
}
function cm(e, t, n, r, i, o) {
    let s = ez(e);
    return Promise.all(ur.map(a => new Promise(l => {
        if (n && a !== "opacity")
            return l();
        let c = t.values[a];
        c.stop();
        let u = Re(e) ? e?.[a] ?? Je[a] : Je[a];
        if (De(u) && (u = u.get()),
        !He(u))
            return l();
        let f = Yn.get(r.current);
        f && f.setBaseTarget(a, u);
        let d;
        if (xe(i) && !c?.hasAnimated && nt.MotionHandoffAnimation) {
            let p = nt.MotionHandoffAnimation(i, a, Z);
            p && (d = p)
        }
        o ? c.set(u) : Zn(c, u, {
            ...s,
            velocity: 0,
            startTime: d,
            onComplete: () => l()
        })
    }
    )))
}
var tz = new Set(["presenceInitial", "presenceAnimate", "presenceExit"]);
function nz({initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: o}, s, a, l, c) {
    let u = r ?? e
      , f = i ?? t
      , d = o ?? n
      , [p,v] = gd()
      , g = V({
        lastPresence: !1,
        lastAnimate: f,
        hasMounted: !1,
        running: !1
    })
      , b = mt( () => {
        let h = u ?? l;
        if (!Re(h))
            return {
                values: xu()
            };
        let y = {};
        for (let w in h) {
            let C = Re(h) ? h[w] : void 0;
            He(C) && (y[w] = C)
        }
        return {
            values: xu(y)
        }
    }
    );
    Yi(s, h => {
        let {hasMounted: y} = g.current;
        if (y && f)
            return;
        let w = Yn.get(h);
        if (w) {
            Object.assign(g.current, {
                hasMounted: !0
            });
            for (let C in b.values) {
                if (!vC(C))
                    continue;
                let S = l?.[C];
                w.setBaseTarget(C, He(S) ? S : Je[C])
            }
        }
    }
    , [f]);
    let m = ki();
    return Yi(s, h => {
        if (!a) {
            v?.();
            return
        }
        if (h === null)
            return;
        if (p !== g.current.lastPresence) {
            Object.assign(g.current, {
                lastPresence: p
            }),
            p ? u && f && (Object.assign(g.current, {
                running: !0
            }),
            cm(f, b, m, s, c).then( () => Object.assign(g.current, {
                running: !1
            }))) : d ? (Object.assign(g.current, {
                running: !0
            }),
            cm(d, b, m, s, c).then( () => Object.assign(g.current, {
                running: !1
            })).then( () => v())) : v();
            return
        }
        let {lastAnimate: y, running: w} = g.current;
        Qm(f, y) || !f || (Object.assign(g.current, {
            lastAnimate: f
        }),
        cm(f, b, m, s, c, !w).then( () => Object.assign(g.current, {
            running: !1
        })))
    }
    ),
    b
}
function rz(e, t) {
    let n = 0
      , r = e;
    for (; r && r !== t && r instanceof HTMLElement; )
        n += r.offsetTop,
        r = r.offsetParent;
    return n
}
var iz = 1;
function bC(e, t=0, n) {
    var r;
    let i = []
      , o = [];
    for (let s = e.length; s >= 0; s--) {
        let {ref: a, offset: l} = e[s] ?? {};
        if (!a || !a.current)
            continue;
        let u = rz(a.current, document.documentElement) - iz - (l ?? 0) - t
          , f = ((r = a.current) == null ? void 0 : r.clientHeight) ?? 0
          , d = i[i.length - 1]
          , p = Math.max(u + f, 0);
        i.push(u),
        o.unshift(Math.max(u, 0), d === void 0 ? p : Math.min(p, Math.max(d - 1, 0))),
        n?.(s)
    }
    return o
}
function oz(e, t=0) {
    return e < t ? "up" : "down"
}
var sz = 4;
function az(e, t, n={}) {
    let {direction: r, target: i} = e ?? {}
      , {repeat: o=!0, enabled: s=!0} = n;
    x.useEffect( () => {
        if (!r || !s)
            return;
        let a, l = 0, c, u;
        return jr( ({y: f}) => {
            if (!o && u === i || f.current > f.scrollLength || f.current < 0)
                return;
            let d = oz(f.current, a);
            a = f.current;
            let p = d !== c;
            if (c = d,
            p)
                l = f.current;
            else {
                if (Math.abs(f.current - l) < sz)
                    return;
                let g = d === r ? i : void 0;
                g !== u && t(g),
                u = g
            }
        }
        )
    }
    , [r, o, i, s, t])
}
var lz = new Set(["threshold", "animateOnce", "opacity", "targetOpacity", "x", "y", "scale", "transition", "rotate", "rotateX", "rotateY", "perspective", "enter", "exit", "animate", "styleAppearEffectEnabled", "targets", "scrollDirection"])
  , cz = ["animate", "animate"]
  , C1 = {
    inputRange: [],
    outputRange: []
};
function uz(e, t, n) {
    let r = bC(e, t)
      , i = [...cz]
      , o = r[0];
    if (!He(o))
        return C1;
    if (o > 1 && (r.unshift(0, o - 1),
    i.unshift("initial", "initial")),
    n) {
        let s = r.length - 1
          , a = r[s];
        if (!He(a))
            return C1;
        r.push(a + 1),
        i.push("exit")
    }
    return {
        inputRange: r,
        outputRange: i
    }
}
function um(e) {
    return {
        x: e?.x ?? Je.x,
        y: e?.y ?? Je.y,
        scale: e?.scale ?? Je.scale,
        opacity: e?.opacity ?? Je.opacity,
        transformPerspective: e?.transformPerspective ?? Je.transformPerspective,
        rotate: e?.rotate ?? Je.rotate,
        rotateX: e?.rotateX ?? Je.rotateX,
        rotateY: e?.rotateY ?? Je.rotateY,
        skewX: e?.skewX ?? Je.skewX,
        skewY: e?.skewY ?? Je.skewY,
        transition: e?.transition ?? void 0
    }
}
function fz({opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: o, ...s}) {
    return x.useMemo( () => ({
        initial: r ?? um({
            ...s,
            opacity: e ?? t ?? 1,
            transformPerspective: n
        }),
        animate: o ?? um({
            opacity: t
        }),
        exit: i ?? um()
    }), [o, s, r, i, e, t, n])
}
function dz(e, t) {
    let n = ki()
      , r = fz(e)
      , i = e.styleAppearEffectEnabled
      , o = yC(i ? r.initial : r.animate, i)
      , s = x.useRef({
        isPlaying: !1,
        scheduledAppearState: void 0,
        lastAppearState: !e.styleAppearEffectEnabled
    })
      , a = x.useRef()
      , l = x.useCallback(async ({transition: d, ...p}, v) => {
        let g = d ?? r.animate.transition ?? e.transition;
        await a.current,
        a.current = Promise.all(ur.map(b => {
            v && o.values[b].set(r.initial[b] ?? Je[b]);
            let m = p[b] ?? Je[b]
              , h = Yn.get(t.current);
            return h && typeof m != "object" && h.setBaseTarget(b, m),
            new Promise(y => {
                if (n && b !== "opacity")
                    He(m) && o.values[b].set(m),
                    y();
                else {
                    let w = {
                        restDelta: b === "scale" ? .001 : void 0,
                        ...g,
                        onComplete: () => y()
                    };
                    typeof m == "number" && Zn(o.values[b], m, w)
                }
            }
            )
        }
        ))
    }
    , [])
      , c = e.animateOnce && s.current.lastAppearState === !0
      , u = !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !c;
    UD(t, d => {
        let {isPlaying: p, lastAppearState: v} = s.current;
        if (p) {
            s.current.scheduledAppearState = d;
            return
        }
        s.current.scheduledAppearState = void 0,
        s.current.lastAppearState = d,
        v !== d && l(d ? r.animate : r.exit, d)
    }
    , {
        enabled: u,
        animateOnce: !!e.animateOnce,
        threshold: {
            y: e.threshold
        }
    });
    let f = e.targets && i && !e.scrollDirection;
    return x.useEffect( () => {
        if (!f)
            return;
        let d = {
            initial: !0
        }
          , p = "initial";
        return jr( ({y: v}) => {
            let {targets: g} = e;
            if (!g || !g[0] || g[0].ref && !g[0].ref.current)
                return;
            let {inputRange: b, outputRange: m} = uz(g, (e.threshold ?? 0) * v.containerLength, !!e.exit);
            if (b.length === 0 || b.length !== m.length)
                return;
            let h = Rs(v.current, b, m);
            if (e.animateOnce && d[h] || (d[h] = !0,
            p === h))
                return;
            p = h;
            let y = rt(r)[h];
            y && l(y)
        }
        )
    }
    , [f]),
    az(e.scrollDirection, d => l(d ?? r.animate), {
        enabled: i,
        repeat: !e.animateOnce
    }),
    o
}
var hz = new Set(["transformViewportThreshold", "styleTransformEffectEnabled", "transformTargets", "spring", "transformTrigger"])
  , pz = (e, t) => {
    var n;
    let r = (n = e?.[0]) == null ? void 0 : n.target;
    return t ? {
        opacity: r?.opacity ?? 1
    } : r
}
  , xC = () => ({
    opacity: [],
    x: [],
    y: [],
    scale: [],
    rotate: [],
    rotateX: [],
    rotateY: [],
    skewX: [],
    skewY: [],
    transformPerspective: []
});
function mz(e, t) {
    let n = x.useRef({});
    x.useEffect( () => {
        if (t !== void 0)
            for (let r of Xi(e)) {
                let i = e[r];
                i.attach( (o, s) => {
                    let a = n.current[r];
                    if (a && a.stop(),
                    n.current[r] = td({
                        keyframes: [i.get(), o],
                        velocity: i.getVelocity(),
                        ...t,
                        restDelta: .001,
                        onUpdate: s
                    }),
                    !Ue.isProcessing) {
                        let l = performance.now() - Ue.timestamp;
                        l < 40 && (n.current[r].time = l / 1e3)
                    }
                    return i.get()
                }
                )
            }
    }
    , [JSON.stringify(t)])
}
function gz(e, t) {
    let n = xC();
    return {
        inputRange: bC(e, t, i => {
            var o, s, a;
            let l = (o = e[i - 1]) == null ? void 0 : o.target
              , c = (s = e[i]) == null ? void 0 : s.target;
            for (let u of ur)
                (a = n[u]) == null || a.unshift(l?.[u] ?? 0, c?.[u] ?? 0)
        }
        ),
        effectKeyOutputRange: n
    }
}
function vz(e) {
    var t;
    let n = xC();
    for (let {target: r} of e)
        for (let i of ur)
            (t = n[i]) == null || t.push(r[i]);
    return n
}
var T1 = [0, 1];
function yz({transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i=0}, o) {
    let s = ki()
      , a = yC(pz(n, s), t)
      , l = !t || !n
      , c = e === "onScrollTarget";
    return Ae( () => {
        if (!(l || !c))
            return jr( ({y: u}) => {
                if (!n[0] || n[0].ref && !n[0].ref.current)
                    return;
                let {inputRange: f, effectKeyOutputRange: d} = gz(n, i * u.containerLength);
                if (f.length !== 0)
                    for (let p of ur)
                        s && p !== "opacity" || f.length === d[p].length && d[p][0] !== void 0 && a.values[p].set(Rs(u.current, f, d[p]))
            }
            )
    }
    , [s, c, i, a, n, l]),
    Yi(o, u => {
        if (l || c || u === null)
            return;
        let f = vz(n);
        return jr( ({y: d}) => {
            for (let p of ur)
                s && p !== "opacity" || T1.length === f[p].length && f[p][0] !== void 0 && a.values[p].set(Rs(d.progress, T1, f[p]))
        }
        , e === "onInView" ? {
            target: u ?? void 0,
            offset: ["start end", "end end"]
        } : void 0)
    }
    , [s, e, c, a, n, l]),
    mz(a.values, r),
    x.useMemo( () => ({
        values: a.values,
        style: t ? {
            willChange: "transform"
        } : {}
    }), [a, t])
}
var wC = {
    parallax: Z3,
    styleAppear: lz,
    styleTransform: hz,
    loop: X3,
    presence: tz
}
  , bz = Xi(wC);
function R1(e, t, n) {
    return !(e in n) && t in n || n[e] === !0
}
function xz(e) {
    let t = {
        parallax: {},
        styleAppear: {},
        styleTransform: {},
        presence: {
            animate: e.animate,
            initial: e.initial,
            exit: e.exit
        },
        loop: {},
        forwardedProps: {}
    };
    for (let n in e) {
        let r = q3(n);
        if (r)
            for (let i of bz) {
                let o = wC[i];
                if (o?.has(r)) {
                    t[i][r] = rt(e)[n];
                    break
                }
            }
        else
            t.forwardedProps[n] = rt(e)[n]
    }
    return t.parallax.parallaxTransformEnabled = R1("parallaxTransformEnabled", "speed", t.parallax),
    t.styleAppear.styleAppearEffectEnabled = R1("styleAppearEffectEnabled", "animateOnce", t.styleAppear),
    t
}
var di = e => e.reduce( (t, n) => t += n, 0)
  , E1 = e => e.reduce( (t, n) => t = t * n, 1)
  , wz = "current";
function Sz(e) {
    return Re(e) && wz in e
}
function kz(e, t) {
    if (!e || !Re(e))
        return t;
    for (let n in e) {
        let r = e[n];
        !De(r) || !vC(n) || He(r.get()) && t[n].push(r)
    }
}
function ba(e) {
    return xe(e) || Array.isArray(e)
}
var b8 = e => x.forwardRef( (t, n) => {
    var r;
    if (t.__withFX)
        return k(e, {
            ...t,
            animate: void 0,
            initial: void 0,
            exit: void 0,
            ref: n
        });
    if (ue.current() === ue.canvas) {
        let Ye = ba(t.animate) ? t.animate : void 0
          , Ce = ba(t.initial) ? t.initial : void 0;
        return k(e, {
            ...t,
            animate: Ye,
            initial: Ce,
            exit: void 0,
            ref: n
        })
    }
    let {parallax: i={}, styleAppear: o={}, styleTransform: s={}, presence: a={}, loop: l={}, forwardedProps: c} = xz(t)
      , {__targetOpacity: u, __perspectiveFX: f, __smartComponentFX: d=!1} = t
      , p = Qn(u ?? 1)
      , v = aC(n)
      , {values: g} = nz(a, v, d, t.style, t[yl])
      , {values: b, style: m} = J3(i, v, (r = t.style) == null ? void 0 : r.visibility)
      , {values: h, style: y} = yz(s, v)
      , {values: w} = dz(o, v)
      , {values: C, style: S} = K3(l)
      , T = x.useMemo( () => ({
        scale: [w.scale, C.scale, g.scale, h.scale],
        opacity: [w.opacity, C.opacity, g.opacity, p, h.opacity],
        x: [w.x, C.x, g.x, h.x],
        y: [w.y, C.y, b.y, g.y, h.y],
        rotate: [w.rotate, C.rotate, g.rotate, h.rotate],
        rotateX: [w.rotateX, C.rotateX, g.rotateX, h.rotateX],
        rotateY: [w.rotateY, C.rotateY, g.rotateY, h.rotateY],
        skewX: [w.skewX, C.skewX, g.skewX, h.skewX],
        skewY: [w.skewY, C.skewY, g.skewY, h.skewY],
        transformPerspective: [h.transformPerspective, w.transformPerspective]
    }), [p, h, b, w, C, g]);
    kz(t.style, T);
    let E = Vt(T.scale, E1)
      , I = Vt(T.opacity, E1)
      , O = Vt(T.x, di)
      , B = Vt(T.y, di)
      , z = Vt(T.rotate, di)
      , j = Vt(T.rotateX, di)
      , J = Vt(T.rotateY, di)
      , H = Vt(T.skewX, di)
      , fe = Vt(T.skewY, di)
      , ie = Vt(T.transformPerspective, di)
      , {drag: q, dragConstraints: re} = c;
    JA(q && Sz(re) ? re : void 0);
    let U = {
        opacity: I,
        scale: E,
        x: O,
        y: B,
        rotate: z,
        rotateX: j,
        rotateY: J,
        skewX: H,
        skewY: fe
    };
    et(f) && (U.transformPerspective = ie);
    let pe = ba(t.animate) ? t.animate : void 0
      , me = ba(t.initial) ? t.initial : void 0
      , ae = ba(t.exit) ? t.exit : void 0
      , X = d && !a.presenceInitial ? {
        initial: me,
        animate: pe,
        exit: ae
    } : {};
    return k(e, {
        ...c,
        ...X,
        __withFX: !0,
        style: {
            ...t.style,
            ...m,
            ...y,
            ...S,
            ...U
        },
        values: g,
        ref: v
    })
}
);
function Uu(e) {
    let t = mt( () => Cz(e));
    return t.useSetup(e),
    t.cloneAsElement
}
function Cz(e) {
    let t = {
        forwardedRef: e,
        childRef: null,
        ref: null
    };
    t.ref = F1(t);
    let n = (s, a) => {
        if (!t.forwardedRef && t.forwardedRef === s) {
            t.ref = a;
            return
        }
        let l = !1;
        t.childRef !== a && (t.childRef = a,
        l = !0),
        t.forwardedRef !== s && (t.forwardedRef = s,
        l = !0),
        l && (t.ref = F1(t))
    }
      , r = !1;
    function i(s, a) {
        if (r)
            throw new ReferenceError("useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle.");
        return r = !0,
        mn.count(s) > 1 && e && (t.forwardedRef = void 0,
        t.ref = t.childRef),
        mn.map(s, l => {
            if (Ot(l)) {
                let c = "ref"in l ? l.ref : void 0;
                n(t.forwardedRef, c);
                let u = t.ref !== c ? {
                    ...a,
                    ref: t.ref
                } : a;
                return mr(l, u)
            }
            return l
        }
        )
    }
    let o = function(a, l) {
        return k(it, {
            children: i(a, l)
        })
    };
    return o.cloneAsArray = i,
    {
        useSetup: s => {
            r = !1,
            n(s, t.childRef)
        }
        ,
        cloneAsElement: o
    }
}
function F1(e) {
    if (!e.forwardedRef)
        return e.childRef;
    let {forwardedRef: t, childRef: n} = e;
    return r => {
        g1(n, r),
        g1(t, r)
    }
}
var SC = x.createContext({});
function T8() {
    return x.useContext(SC)
}
var R8 = x.forwardRef(function({width: t, height: n, y: r, children: i, ...o}, s) {
    let a = x.useMemo( () => ({
        width: t,
        height: n,
        y: r
    }), [t, n, r])
      , l = Uu(s);
    return k(SC.Provider, {
        value: a,
        children: l(i, o)
    })
})
  , Tz = e => x.forwardRef( (t, n) => {
    let r = Ba(t);
    return k(e, {
        layoutId: r,
        ...t,
        layoutIdKey: void 0,
        duplicatedFrom: void 0,
        ref: n
    })
}
);
function kC(e, t) {
    var n;
    if (typeof P > "u" || Math.random() > .01)
        return;
    let r = e instanceof Error && typeof e.stack == "string" ? e.stack : null
      , i = t?.componentStack;
    (n = nt.__framer_events) == null || n.push(["published_site_load_recoverable_error", {
        message: String(e),
        stack: r,
        componentStack: r ? void 0 : i
    }])
}
function Rz(...e) {
    console.error(...e)
}
function Ez() {
    return ue.current() !== ue.canvas
}
function Fz({errorMessage: e, fallback: t, children: n}) {
    return Ez() ? k(Pz, {
        fallback: t,
        errorMessage: e,
        children: k(_z, {
            fallback: t,
            children: n
        })
    }) : n
}
var Pz = class extends we {
    constructor() {
        super(...arguments),
        R(this, "state", {
            hasError: !1
        })
    }
    static getDerivedStateFromError() {
        return {
            hasError: !0
        }
    }
    componentDidCatch(e, t) {
        Rz(this.props.errorMessage, t?.componentStack),
        kC(e, t)
    }
    render() {
        let {children: e, fallback: t=null} = this.props
          , {hasError: n} = this.state;
        return n ? t : e
    }
}
;
function _z({children: e, fallback: t=null}) {
    return typeof P > "u" ? k(pr, {
        fallback: t,
        children: e
    }) : k(Hm, {
        children: e
    })
}
var Iz = class extends we {
    constructor() {
        super(...arguments),
        R(this, "state", {
            hasError: !1
        })
    }
    componentDidCatch(e, t) {
        let n = t?.componentStack;
        console.error("Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.", n),
        this.setState({
            hasError: !0
        }),
        kC(e, t)
    }
    render() {
        let {children: e} = this.props
          , {hasError: t} = this.state;
        return t ? null : e
    }
}
  , Oz = "code-crash:";
function Mz(e, t) {
    return `${Oz}${e}:${t}`
}
function Lz(e, t) {
    return Vz("component", e, t)
}
function Vz(e, t, n) {
    return `A code ${e} crashed while rendering due to the error above. To find and fix it, open the project in the editor \u2192 open Quick Actions (press Cmd+K or Ctrl+K) \u2192 paste this: ${Mz(t, n)} \u2192 click \u201CShow Layer\u201D.`
}
var Fm = ( () => x.createContext(0))();
function Az() {
    return x.useContext(Fm)
}
function Dz({children: e}) {
    let t = x.useContext(Fm);
    return k(Fm.Provider, {
        value: t + 1,
        children: e
    })
}
function zz(e, t, n, r) {
    return (t || n) && (e === 0 || e === 1 && r)
}
var Bz = x.forwardRef( ({children: e, layoutId: t, as: n, scopeId: r, nodeId: i, isAuthoredByUser: o, isModuleExternal: s, inComponentSlot: a, ...l}, c) => {
    let u = mt( () => t ? `${t}-container` : void 0)
      , f = za(n)
      , d = x.Children.map(e, v => x.isValidElement(v) ? x.cloneElement(v, {
        layoutId: t
    }) : v)
      , p = $z(d, r, i, o, s, a);
    return k(f, {
        layoutId: u,
        ...l,
        ref: c,
        children: k(ts.Provider, {
            value: !0,
            children: k(XL, {
                enabled: !1,
                children: k(j0, {
                    id: t ?? "",
                    inherit: "id",
                    children: p
                })
            })
        })
    })
}
)
  , A8 = Tz(Bz);
function $z(e, t, n, r, i, o) {
    let s = Az();
    return et(t) || et(n) ? k(Iz, {
        children: e
    }) : (zz(s, r ?? !1, i ?? !1, o ?? !1) && (e = k(Fz, {
        errorMessage: Lz(t, n),
        fallback: null,
        children: e
    })),
    i && (e = k(Dz, {
        children: e
    })),
    e)
}
var Nz = x.createContext(void 0)
  , jz = "style[data-framer-css-ssr-minified]"
  , Hz = ( () => {
    var e;
    if (!Vr())
        return new Set;
    let t = (e = document.querySelector(jz)) == null ? void 0 : e.getAttribute("data-framer-components");
    return t ? new Set(t.split(" ")) : new Set
}
)()
  , Wz = "data-framer-css-ssr"
  , CC = (e, t, n) => x.forwardRef( (r, i) => {
    let {sheet: o, cache: s} = x.useContext(Nz) ?? {};
    if (!Vr()) {
        jn(t) && (t = t(ue.current()));
        let a = Array.isArray(t) ? t.join(`
`) : t;
        return he(it, {
            children: [k("style", {
                [Wz]: !0,
                "data-framer-component": n,
                dangerouslySetInnerHTML: {
                    __html: a
                }
            }), k(e, {
                ...r,
                ref: i
            })]
        })
    }
    return x.useInsertionEffect( () => {
        if (n && Hz.has(n))
            return;
        (jn(t) ? t(ue.current()) : Array.isArray(t) ? t : t.split(`
`)).forEach(l => l && $k(l, o, s))
    }
    , []),
    k(e, {
        ...r,
        ref: i
    })
}
)
  , ng = ve({
    onRegisterCursors: () => () => {}
    ,
    registerCursors: () => {}
})
  , wu = "framer-cursor-none"
  , Pm = "framer-pointer-events-none"
  , Uz = qa(function({children: t}) {
    let n = mt( () => {
        let i = new Set
          , o = {};
        return {
            onRegisterCursors: s => (s(o),
            i.add(s),
            () => i.delete(s)),
            registerCursors: s => {
                let a = {};
                for (let l in s) {
                    let c = o[l] ?? s[l];
                    c && (a[l] = c)
                }
                o = a;
                for (let l of i)
                    l(o)
            }
        }
    }
    )
      , r = ki();
    return he(ng.Provider, {
        value: n,
        children: [t, !r && k(Kz, {})]
    })
})
  , Gz = ( () => CC(Uz, [`.${wu}, .${wu} * { cursor: none !important; }`, `.${Pm}, .${Pm} * { pointer-events: none !important; }`]))()
  , qz = ( () => ({
    position: "fixed",
    top: 0,
    left: 0,
    zIndex: 12 + 1,
    pointerEvents: "none"
}))();
function Xz(e) {
    return !(!e || e.placement || e.alignment)
}
function tu(e) {
    switch (e) {
    case "start":
        return "0%";
    case "center":
        return "-50%";
    case "end":
        return "-100%";
    default:
        ke(e)
    }
}
function Yz(e, t="center") {
    switch (e) {
    case "top":
        return `${tu(t)}, -100%`;
    case "right":
        return `0%, ${tu(t)}`;
    case "bottom":
        return `${tu(t)}, 0%`;
    case "left":
        return `-100%, ${tu(t)}`;
    default:
        return "-50%, -50%"
    }
}
var P1 = "data-framer-portal-id";
function _1(e, t) {
    let n = document.elementFromPoint(e, t);
    for (; n; ) {
        if (n === document.body)
            return;
        let r = n.getAttribute("data-framer-cursor");
        if (r)
            return r;
        if (n.hasAttribute(P1)) {
            let i = n.getAttribute(P1);
            n = n.parentElement,
            i && (n = document.getElementById(i) ?? n)
        } else
            n = n.parentElement
    }
}
function I1(e) {
    for (let t in e)
        return !1;
    return !0
}
var Kz = qa(function() {
    let {onRegisterCursors: t} = D(ng)
      , [n,r] = Oe(!1)
      , i = Qn(0)
      , o = Qn(0)
      , s = Qn(0)
      , a = V(null)
      , l = V({
        cursors: {},
        cursorHash: void 0
    })
      , c = ju();
    Ae( () => {
        let T = nt.matchMedia("(any-hover: none)");
        function E(I) {
            I.matches ? Mt( () => r(!1)) : r(!0)
        }
        return T.addEventListener("change", E),
        T.matches || r(!0),
        () => {
            T.removeEventListener("change", E)
        }
    }
    , []),
    $( () => {
        if (!n)
            return;
        let T = 0
          , E = 0;
        function I() {
            i.set(T),
            o.set(E),
            Zn(s, 1, {
                type: "tween",
                duration: .2
            })
        }
        let O = () => {
            if (I1(l.current.cursors))
                return;
            let j = _1(T, E);
            j !== l.current.cursorHash && (l.current.cursorHash = j,
            Z.update( () => c()))
        }
        ;
        function B(j) {
            if (j.pointerType === "touch") {
                Lt(O);
                return
            }
            Z.read(O, !0),
            T = j.clientX,
            E = j.clientY,
            Z.update(I)
        }
        function z(j) {
            if (j.target === a.current || !a.current)
                return;
            let J = new PointerEvent(j.type,{
                bubbles: !0,
                cancelable: j.cancelable,
                pointerType: j.pointerType,
                pointerId: j.pointerId,
                composed: j.composed,
                isPrimary: j.isPrimary,
                buttons: j.buttons,
                button: j.button
            });
            Z.update( () => {
                var H;
                (H = a.current) == null || H.dispatchEvent(J)
            }
            )
        }
        return nt.addEventListener("pointermove", B),
        document.addEventListener("pointerdown", z),
        document.addEventListener("pointerup", z),
        Z.read(O, !0),
        () => {
            nt.removeEventListener("pointermove", B),
            document.removeEventListener("pointerdown", z),
            document.removeEventListener("pointerup", z),
            Lt(O)
        }
    }
    , [s, i, o, c, n]),
    $( () => {
        if (!n)
            return;
        function T() {
            Zn(s, 0, {
                type: "tween",
                duration: .2
            })
        }
        return document.addEventListener("mouseleave", T),
        nt.addEventListener("blur", T),
        () => {
            document.removeEventListener("mouseleave", T),
            nt.removeEventListener("blur", T)
        }
    }
    , [s, n]),
    Ae( () => {
        function T(I) {
            l.current.cursors = I,
            l.current.cursorHash = I1(I) ? null : _1(i.get(), o.get()),
            c()
        }
        let E = t(T);
        return () => {
            E(),
            document.body.classList.toggle(wu, !1)
        }
    }
    , [i, o, t, c]);
    let {cursors: u, cursorHash: f} = l.current
      , d = f ? u[f] : null
      , p = Xz(d);
    Ae( () => {
        n && document.body.classList.toggle(wu, p)
    }
    , [p, n]);
    let v = d?.component
      , g = d?.transition ?? {
        duration: 0
    }
      , b = Id(i, g)
      , m = Id(o, g)
      , h = Vt( () => {
        var T;
        return b.get() + (((T = d?.offset) == null ? void 0 : T.x) ?? 0)
    }
    )
      , y = Vt( () => {
        var T;
        return m.get() + (((T = d?.offset) == null ? void 0 : T.y) ?? 0)
    }
    )
      , w = d?.alignment
      , C = d?.placement
      , S = K( (T, E) => `translate(${Yz(C, w)}) ${E}`, [w, C]);
    return !n || !d || !v ? null : k(v, {
        transformTemplate: S,
        style: {
            ...qz,
            x: h,
            y,
            opacity: s
        },
        globalTapTarget: !0,
        variant: d?.variant,
        ref: a,
        className: Pm
    })
});
function j8(e) {
    let {registerCursors: t} = D(ng)
      , n = mt( () => e);
    Ae( () => {
        t(n)
    }
    , [n, t])
}
var TC = x.createContext(void 0)
  , rg = class {
    constructor(e) {
        this.resolver = e,
        R(this, "status")
    }
    static is(e) {
        return e instanceof rg
    }
    preload() {
        if (this.status) {
            let t = this.status;
            return t.type !== "pending" ? void 0 : t.promise
        }
        let e = this.resolver().then(t => {
            this.status = {
                type: "fulfilled",
                value: t
            }
        }
        , t => {
            this.status = {
                type: "rejected",
                error: t
            }
        }
        );
        return this.status = {
            type: "pending",
            promise: e
        },
        e
    }
    waitFor() {
        return this.resolver()
    }
    read() {
        let e = this.status;
        if (!e)
            throw new Error("Need to call preload() before read()");
        switch (e.type) {
        case "pending":
            throw new Error("Need to wait for preload() to resolve");
        case "fulfilled":
            return e.value;
        case "rejected":
            throw e.error;
        default:
            ke(e)
        }
    }
}
  , RC = x.createContext(void 0)
  , X8 = ( () => RC.Provider)()
  , Gu = () => x.useContext(RC) ?? {};
function ig(e, t) {
    return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : ig(e.parentElement, t) : null
}
function Qz({children: e}) {
    let {useGranularSuspense: t} = Gu();
    return t ? k(Hm, {
        children: e
    }) : e
}
function EC(e) {
    return Ie(function(n, r) {
        return k(Qz, {
            children: k(e, {
                ...n,
                ref: r
            })
        })
    })
}
var O1 = "element"
  , Zz = "collection"
  , Jz = "collectionItemId"
  , e5 = "pathVariables"
  , FC = "framer/page-link,";
function PC(e) {
    return xe(e) && e.startsWith(`data:${FC}`)
}
function og(e) {
    if (PC(e))
        try {
            let t = new URL(e), n = t.pathname.substring(FC.length), r = t.searchParams, i = r.has(O1) ? r.get(O1) : void 0, o, s = r.get(Zz), a = r.get(Jz), l = r.get(e5);
            if (s && a && l) {
                let c = Object.fromEntries(new URLSearchParams(l).entries());
                o = {
                    collection: s,
                    collectionItemId: a,
                    pathVariables: c
                }
            }
            return {
                target: n === "none" ? null : n,
                element: i === "none" ? void 0 : i,
                collectionItem: o
            }
        } catch {
            return
        }
}
function t5(e, t, n) {
    var r;
    let i = t.getAttribute("data-framer-page-link-target"), o, s;
    if (i) {
        o = t.getAttribute("data-framer-page-link-element") ?? void 0;
        let l = t.getAttribute("data-framer-page-link-path-variables");
        l && (s = Object.fromEntries(new URLSearchParams(l).entries()))
    } else {
        let l = t.getAttribute("href");
        if (!l)
            return !1;
        let c = og(l);
        if (!c || !c.target)
            return !1;
        i = c.target,
        o = c.element ?? void 0,
        s = (r = c.collectionItem) == null ? void 0 : r.pathVariables
    }
    let a = o ? t.dataset.framerSmoothScroll !== void 0 : void 0;
    return e(i, o, Object.assign({}, n, s), a),
    !0
}
var n5 = class {
    constructor() {
        R(this, "links", new Map)
    }
    clear() {
        this.links.clear()
    }
    getLinks() {
        return this.links
    }
    addLink(e, t) {
        if (typeof P < "u" || !e || !t)
            return;
        this.links.has(e) || this.links.set(e, new Set),
        this.links.get(e).add(t)
    }
}
  , r5 = new n5
  , i5 = 500
  , o5 = .9
  , s5 = 1.7
  , a5 = 4
  , l5 = 1 / 0
  , Wo = new WeakMap
  , nu = new Set
  , Uo = new Map;
function c5() {
    var e;
    let t = Fe.connection || Fe.mozConnection || Fe.webkitConnection || {}, n = Fe.deviceMemory && Fe.deviceMemory > s5, r, i, o;
    function s() {
        r = t.effectiveType || "",
        i = t.saveData || r.includes("2g"),
        o = r === "3g" || n ? a5 : l5
    }
    (e = t.addEventListener) == null || e.call(t, "change", s),
    s();
    let a = new IntersectionObserver(u,{
        threshold: o5
    })
      , l = 0;
    async function c(f, d) {
        if (i)
            return;
        let p = Uo.get(f);
        if (!p?.size || nu.has(f))
            return;
        ++l,
        nu.add(f);
        let v = Pk(f).catch( () => {}
        );
        a.unobserve(d),
        Wo.delete(d);
        for (let g of p)
            a.unobserve(g),
            Wo.delete(g);
        p.clear(),
        Uo.delete(f),
        await v,
        --l
    }
    function u(f) {
        var d;
        for (let p of f) {
            let v = p.target
              , g = Wo.get(v);
            if (!g || nu.has(g)) {
                a.unobserve(v),
                Wo.delete(v);
                continue
            }
            let b = Uo.get(g)
              , m = ((d = Uo.get(g)) == null ? void 0 : d.size) ?? 0;
            if (p.isIntersecting) {
                if (l >= o)
                    continue;
                b ? b.add(v) : Uo.set(g, new Set([v])),
                setTimeout(c.bind(void 0, g, v), i5)
            } else
                b && b.delete(v),
                m <= 1 && Uo.delete(g)
        }
    }
    return (f, d) => {
        if (!nu.has(f))
            return Wo.set(d, f),
            a.observe(d),
            () => {
                Wo.delete(d),
                a.unobserve(d)
            }
    }
}
var u5 = !Wm || typeof IntersectionObserver > "u" ? null : c5()
  , fm = Symbol("noLocale")
  , ru = new Map;
function _C(e, t, n) {
    var r, i;
    let o = (i = (r = ru?.get(n?.id ?? fm)) == null ? void 0 : r.get(e.collectionId)) == null ? void 0 : i.get(e.collectionItemId);
    if (o)
        return o;
    let s = ru.get(n?.id ?? fm) ?? new Map;
    ru.set(n?.id ?? fm, s);
    let a = s.get(e.collectionId) ?? new Map;
    s.set(e.collectionId, a);
    let l = new rg(async () => {
        try {
            let c = t[e.collectionId];
            if (!c)
                throw new Error(`Key not found in collection utils for collection id: "${e.collectionId}`);
            let u = await c();
            if (!u)
                throw new Error("Collection does not contain utility functions");
            return await u.getSlugByRecordId(e.collectionItemId, n ?? void 0)
        } catch (c) {
            // console.warn(`Failed to resolve slug: ${cinstanceof Error ? c.message : "Unknown error"}`);
            // return
        }
    }
    );
    return a.set(e.collectionItemId, l),
    l
}
function ns() {
    return ue.current() === ue.canvas
}
var f5 = "webPageId";
function Oa(e) {
    return !!(e && typeof e == "object" && f5 in e)
}
function d5(e) {
    if (!e)
        return;
    let t = {};
    for (let n in e.pathVariables) {
        let r = e.pathVariables[n];
        r && (t[n] = r)
    }
    return t
}
function Ma(e) {
    if (!PC(e))
        return e;
    let t = og(e);
    if (!t)
        return;
    let {target: n, element: r, collectionItem: i} = t;
    if (n)
        return {
            webPageId: n,
            hash: r ?? void 0,
            pathVariables: d5(i)
        }
}
var IC = /:([a-z]\w*)/gi
  , h5 = ve(void 0);
function OC() {
    var e;
    let t = D(h5)
      , n = (e = La()) == null ? void 0 : e.pathVariables;
    return t || n
}
function MC(e, {webPageId: t, hash: n, pathVariables: r}, i) {
    if (t !== e.id || n)
        return !1;
    if (e.path && e.pathVariables) {
        let o = Object.assign({}, i, r);
        for (let[,s] of e.path.matchAll(IC))
            if (!s || e.pathVariables[s] !== o[s])
                return !1
    }
    return !0
}
function sg(e) {
    return e === void 0 ? !1 : !!(e.startsWith("#") || e.startsWith("/") || e.startsWith("."))
}
function p5(e, t) {
    try {
        return !!new URL(e).protocol
    } catch {}
    return t
}
function ag(e, t) {
    return e !== void 0 ? e ? "_blank" : void 0 : t ? void 0 : "_blank"
}
function uu(e, t=void 0) {
    let n = sg(e)
      , r = ag(t, n);
    return {
        href: e === "" || p5(e, n) ? e : `https://${e}`,
        target: r,
        rel: n ? void 0 : "noopener"
    }
}
function lg(e, t, n, r, i) {
    var o, s;
    let a = (o = e.getRoute) == null ? void 0 : o.call(e, t);
    a && hk(a?.page) && a.page.preload(),
    (s = e.navigate) == null || s.call(e, t, n, r, i)
}
function LC(e, t, n, r, i) {
    return async o => {
        if (o.metaKey)
            return;
        let s = ig(o.target);
        !s || s.getAttribute("target") === "_blank" || (o.preventDefault(),
        lg(e, t, n, r, i))
    }
}
function iu(e, t, n) {
    let r = document.createElement("a");
    r.href = e,
    t && (r.rel = t),
    n && (r.target = n),
    document.body.appendChild(r),
    r.click(),
    r.remove()
}
function m5(e, t, n, r) {
    let i = [];
    function o(a) {
        if (!a || !n)
            return;
        let l = {};
        for (let c in a) {
            let u = a[c];
            A(u, "unresolvedSlug should be defined");
            let f = _C(u, n, r)
              , d = f.preload();
            if (d)
                i.push(d);
            else {
                let p = f.read();
                p && (l[c] = p)
            }
        }
        return l
    }
    let s = {
        path: o(e),
        hash: o(t)
    };
    if (i.length)
        throw Promise.allSettled(i);
    return s
}
function g5(e, t, n, r, i, o, s, a) {
    var l;
    let c = {
        ...i,
        ...o,
        ...a?.path
    }
      , u = {
        ...i,
        ...s,
        ...a?.hash
    }
      , f = (l = e.getRoute) == null ? void 0 : l.call(e, n)
      , d = Bu(f, {
        currentRoutePath: t?.path,
        currentPathVariables: t?.pathVariables,
        hash: r,
        pathVariables: c,
        hashVariables: u,
        preserveQueryParams: e.preserveQueryParams
    })
      , p = d.split("#", 2)[1];
    return {
        routeId: n,
        route: f,
        href: d,
        elementId: p,
        pathVariables: c
    }
}
function v5(e, t, n) {
    if (!(!e.routes || !e.getRoute || !sg(t)))
        try {
            let[i,o] = t.split("#", 2);
            A(i !== void 0, "A href must have a defined pathname.");
            let[s] = i.split("?", 2);
            A(s !== void 0, "A href must have a defined pathname.");
            let {routeId: a, pathVariables: l} = Fk(e.routes, s)
              , c = e.getRoute(a);
            if (c) {
                let u = Object.assign({}, n, l);
                return {
                    routeId: a,
                    route: c,
                    href: t,
                    elementId: o,
                    pathVariables: u
                }
            }
        } catch {}
}
function y5(e, t, n, r, i) {
    let {webPageId: o, hash: s, pathVariables: a, hashVariables: l, unresolvedHashSlugs: c, unresolvedPathSlugs: u} = n
      , f = m5(u, c, e.collectionUtils, r);
    return g5(e, t, o, s, i, a, l, f)
}
function b5(e, t, n, r, i, o) {
    if (!r)
        return uu(e, t);
    let s = v5(n, e, i);
    if (!s)
        return uu(e, t);
    let {routeId: a, route: l, elementId: c, pathVariables: u} = s;
    if (!l)
        return uu(e, t);
    let f = Bu(l, {
        currentRoutePath: r.path,
        currentPathVariables: r.pathVariables,
        hash: c,
        pathVariables: u,
        preserveQueryParams: n.preserveQueryParams
    })
      , d = ag(t, !0);
    return {
        href: f,
        target: d,
        onClick: LC(n, a, c, u, o),
        navigate: () => lg(n, a, c, u, o),
        "data-framer-page-link-current": !c && r.id === a || void 0
    }
}
function VC(e, t, n) {
    var r;
    if (xe(e)) {
        let o = sg(e);
        if (!t.routes || !t.getRoute || !n || !o)
            return;
        let[s] = e.split("#", 2);
        if (s === void 0)
            return;
        let[a] = s.split("?", 2);
        if (a === void 0)
            return;
        let {routeId: l} = Fk(t.routes, a);
        return t.getRoute(l)
    }
    let {webPageId: i} = e;
    return (r = t.getRoute) == null ? void 0 : r.call(t, i)
}
var J8 = EC(Ie(function({children: t, href: n, openInNewTab: r, smoothScroll: i, nodeId: o, ...s}, a) {
    let l = Ki()
      , c = La()
      , u = OC()
      , {activeLocale: f} = Ek()
      , d = Uu(a)
      , p = se( () => {
        if (!n)
            return {};
        let S = Oa(n) ? n : Ma(n);
        if (!S)
            return {};
        if (xe(S))
            return b5(S, r, l, c, u, i);
        let {routeId: T, href: E, elementId: I, pathVariables: O} = y5(l, c, S, f, u)
          , B = ag(r, !0);
        return {
            href: E,
            target: B,
            onClick: LC(l, T, I, O, i),
            navigate: () => lg(l, T, I, O, i),
            "data-framer-page-link-current": c && MC(c, S, u) || void 0
        }
    }
    , [n, l, f, u, r, c, i])
      , [v,g] = x5(o, n, p)
      , b = K(S => {
        var T;
        let E = Oa(n) ? n : Ma(n);
        if (!E)
            return;
        let I = VC(E, l, c);
        if (I)
            return (T = u5) == null ? void 0 : T(I, S)
    }
    , [c, n, l])
      , m = Ot(t) && "ref"in t
      , h = aC(m ? t.ref : void 0);
    Yi(h, S => {
        S !== null && g(S)
    }
    , [g]),
    Yi(h, S => {
        if (S !== null)
            return b(S)
    }
    , [b]);
    let {navigate: y, ...w} = p
      , C = d.cloneAsArray(t, {
        ...s,
        ...w,
        ref: h
    });
    return v(C)
}))
  , M1 = ve(void 0);
function x5(e, t, n) {
    let r = D(M1)
      , i = ns()
      , o = Ki()
      , s = La()
      , {replaceNestedLinks: a} = Gu()
      , l = se( () => {
        let b = Oa(t) ? t : Ma(t);
        if (b)
            return VC(b, o, s)
    }
    , [s, t, o])
      , c = Object.keys(n).length > 0
      , u = !!(a && !i && (r || !c))
      , f = K(b => {
        var m;
        if (!n.href)
            return;
        if (b.preventDefault(),
        b.stopPropagation(),
        /Mac|iPod|iPhone|iPad/u.test(Fe.userAgent) ? b.metaKey : b.ctrlKey) {
            iu(n.href, "", "_blank");
            return
        }
        l ? (m = n.navigate) == null || m.call(n) : iu(n.href, n.rel, n.target)
    }
    , [n, l])
      , d = K(b => {
        n.href && (b.preventDefault(),
        b.stopPropagation(),
        iu(n.href, "", "_blank"))
    }
    , [n])
      , p = K(b => {
        var m;
        n.href && b.key === "Enter" && (b.preventDefault(),
        b.stopPropagation(),
        l ? (m = n.navigate) == null || m.call(n) : iu(n.href, n.rel, n.target))
    }
    , [n, l])
      , v = K(b => {
        let m = {
            "data-nested-link": !0,
            role: "link",
            tabIndex: 0,
            onClick: f,
            onAuxClick: d,
            onKeyDown: p
        }
          , h = u ? mn.map(b, y => {
            if (!S5(y))
                return y;
            r5.addLink(r, e);
            let w = Su(y.type)
              , {children: C, ...S} = y.props
              , T = c ? {
                ...S,
                ...m,
                as: S.as && Su(S.as)
            } : S
              , E = "ref"in y ? y.ref : void 0;
            return Ji(w, {
                ...T,
                ref: E
            }, C)
        }
        ) : b;
        return k(M1.Provider, {
            value: e,
            children: h
        })
    }
    , [c, e, d, f, p, u, r])
      , g = K(b => {
        i || !u || !c || (b.dataset.hydrated = "true")
    }
    , [i, c, u]);
    return [v, g]
}
function w5(e, t, n, r) {
    let i = Oa(e) ? e : Ma(e);
    if (!Oa(i))
        return xe(e) ? uu(e).href : void 0;
    if (!t.getRoute || !t.currentRouteId)
        return;
    let o = t.getRoute(t.currentRouteId)
      , {webPageId: s, hash: a, pathVariables: l, hashVariables: c, unresolvedHashSlugs: u, unresolvedPathSlugs: f} = i
      , d = t.getRoute(s)
      , p = f || u ? r?.(f, u) : void 0
      , v = Object.assign({}, t.currentPathVariables, n, l, p?.path)
      , g = Object.assign({}, t.currentPathVariables, n, c, p?.hash);
    return Bu(d, {
        currentRoutePath: o?.path,
        currentPathVariables: t.currentPathVariables,
        hash: a,
        pathVariables: v,
        hashVariables: g,
        relative: !1,
        preserveQueryParams: t.preserveQueryParams
    })
}
function S5(e) {
    return Ot(e) && (Su(e.type) !== e.type || Su(e.props.as) !== e.props.as)
}
function Su(e) {
    return e === "a" ? "span" : Rl(e) && Vd(e) === "a" ? Jt.span : e
}
var k5 = class extends we {
    constructor() {
        super(...arguments),
        R(this, "state", {
            error: void 0
        })
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
;
var AC = x.createContext(void 0);
function C5(e) {
    return new Promise( (t, n) => {
        try {
            new URL(e);
            let r = new Image;
            r.onload = () => t(),
            r.onerror = n,
            r.src = e
        } catch (r) {
            n(r)
        }
    }
    )
}
function T5(e) {
    return typeof e == "object" && e !== null
}
function R5(e, t) {
    if (t === "")
        return e;
    let n = t.split(/[.[\]]+/u).filter(i => i.length > 0)
      , r = e;
    for (let i of n) {
        if (!T5(r))
            return;
        r = r[i]
    }
    return r
}
function xa(e) {
    return `${e.credentials}:${e.url}`
}
var E5 = {
    status: "loading",
    data: void 0
};
function F5(e) {
    return xe(e) && !Number.isNaN(Number(e))
}
function P5(e, t) {
    switch (e) {
    case "string":
        return xe(t) || He(t);
    case "color":
        return xe(t);
    case "boolean":
        return qm(t);
    case "number":
        return He(t) || F5(t);
    case "link":
    case "image":
        return xe(t) && _m(t);
    default:
        {
            let n = e;
            return !1
        }
    }
}
function _5(e, t) {
    if (e.status === "loading")
        return t.fallbackValue;
    if (e.status === "error")
        throw e.error;
    let n = R5(e.data, t.resultKeyPath);
    if (et(n))
        throw new Error(`Key '${t.resultKeyPath}' not found in response`);
    if (!P5(t.resultOutputType, n))
        throw new Error(`Resolved value '${n}' is not valid for type '${t.resultOutputType}'`);
    return n
}
function _m(e) {
    try {
        return !!new URL(e).protocol
    } catch {}
}
function dm(e, t) {
    if (ue.current() === ue.canvas)
        return !1;
    let n = t === 0 ? 500 : t * 1e3
      , r = Date.now()
      , i = e + n;
    return r >= i
}
var L1 = () => {}
, Ir, fu, Bi, $i, wa, hi, du = class {
    constructor() {
        R(this, "responseValues", new Map),
        Qt(this, Ir, new Map),
        Qt(this, fu, new Set),
        Qt(this, Bi, new Map),
        Qt(this, $i, new Map),
        Qt(this, wa, new Map),
        Qt(this, hi, new Map),
        R(this, "persistCache", N3( () => {
            let e = {};
            for (let[t,n] of this.responseValues) {
                if (!n || n.status !== "success")
                    continue;
                let r = de(this, Bi).get(t);
                if (!r || r === 0)
                    continue;
                let i = de(this, $i).get(t);
                i && (i && dm(i, r) || (e[t] = [i, r, n.data]))
            }
            try {
                localStorage.setItem(du.cacheKey, JSON.stringify(e))
            } catch {}
        }
        , 500))
    }
    unmount() {
        for (let[e,t] of de(this, hi))
            clearInterval(t),
            de(this, hi).delete(e)
    }
    stopQueryRefetching(e) {
        let t = xa(e)
          , n = de(this, hi).get(t);
        n && (clearInterval(n),
        de(this, hi).delete(t))
    }
    startQueryRefetching(e) {
        let t = xa(e)
          , n = de(this, hi).get(t)
          , r = de(this, Bi).get(t);
        if (n || !r)
            return;
        let i = nt.setInterval( () => {
            if (document.visibilityState === "hidden")
                return;
            let o = de(this, $i).get(t);
            !r || !o || this.fetchWithCache({
                ...e,
                cacheDuration: r
            })
        }
        , r);
        de(this, hi).set(t, i)
    }
    hydrateCache() {
        try {
            let e = localStorage.getItem(du.cacheKey);
            if (!e)
                return;
            let t = JSON.parse(e);
            if (typeof t != "object")
                throw new Error("Invalid cache data");
            for (let n in t) {
                let r = t[n];
                if (!Array.isArray(r) || r.length !== 3)
                    throw new Error("Invalid cache data");
                let[i,o,s] = r;
                dm(i, o) || (de(this, $i).set(n, i),
                de(this, Bi).set(n, o),
                this.responseValues.set(n, {
                    status: "success",
                    data: s
                }))
            }
        } catch {
            try {
                localStorage.removeItem(du.cacheKey)
            } catch {}
        }
    }
    setResponseValue(e, t) {
        this.responseValues.set(e, t),
        this.persistCache();
        let n = de(this, Ir).get(e);
        if (n)
            for (let r of n)
                r()
    }
    async prefetch(e) {
        if (!Vr() || !_m(e.url))
            return;
        let t = xa(e);
        de(this, fu).add(t),
        await this.fetchWithCache(e);
        let n = this.getValue(t);
        if (!n || n.status === "loading")
            throw new Error("Unexpected result status for prefetch");
        let r = de(this, Ir).get(t);
        for (let o of r ?? [])
            o();
        let i = _5(n, e);
        return e.resultOutputType === "image" && xe(i) && await C5(i).catch(L1),
        i
    }
    async fetchWithCache(e) {
        if (!Vr())
            return;
        let t = xa(e)
          , n = de(this, wa).get(t);
        if (n)
            return n;
        let r = de(this, $i).get(t)
          , i = r && dm(r, e.cacheDuration);
        if (this.responseValues.has(t) && !i)
            return;
        this.responseValues.get(t) || this.setResponseValue(t, E5);
        let a = (async () => {
            try {
                let l = await fetch(e.url, {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    credentials: e.credentials
                });
                if (!l.ok) {
                    this.setResponseValue(t, {
                        status: "error",
                        error: new Error("Invalid Response Status"),
                        data: void 0
                    });
                    return
                }
                let c = await l.json();
                this.setResponseValue(t, {
                    status: "success",
                    data: c
                }),
                de(this, $i).set(t, Date.now())
            } catch (l) {
                this.setResponseValue(t, {
                    status: "error",
                    error: l,
                    data: void 0
                })
            }
        }
        )();
        return de(this, wa).set(t, a),
        a.finally( () => {
            de(this, wa).delete(t)
        }
        ),
        a
    }
    getValue(e, t=!1) {
        if (!(t && !de(this, fu).has(e)))
            return this.responseValues.get(e)
    }
    subscribe(e, t, n=!1) {
        let {url: r, cacheDuration: i} = e;
        if (!_m(r))
            return L1;
        let o = xa(e)
          , s = de(this, Bi).get(o);
        (!s || i < s) && de(this, Bi).set(o, i),
        n || (this.startQueryRefetching(e),
        this.fetchWithCache(e));
        let a = de(this, Ir).get(o) ?? new Set;
        return a.add(t),
        de(this, Ir).set(o, a),
        () => {
            let l = de(this, Ir).get(o);
            l && (l.delete(t),
            l.size === 0 && de(this, Ir).delete(o),
            de(this, Ir).size === 0 && this.stopQueryRefetching(e))
        }
    }
}
, DC = du;
Ir = new WeakMap;
fu = new WeakMap;
Bi = new WeakMap;
$i = new WeakMap;
wa = new WeakMap;
hi = new WeakMap;
R(DC, "cacheKey", "framer-fetch-client-cache");
var I5 = ve(void 0), O5 = ve(!0), M5 = ({children: e, client: t}) => {
    let[n] = Oe( () => t ?? new DC)
      , [r,i] = Oe(!0);
    return $( () => (n.hydrateCache(),
    Mt( () => {
        i(!1)
    }
    ),
    () => n.unmount()), [n]),
    k(O5.Provider, {
        value: r,
        children: k(I5.Provider, {
            value: n,
            children: e
        })
    })
}
, L5, V5, A5, D5, z5;
L5 = new WeakMap;
V5 = new WeakMap;
A5 = new WeakMap;
D5 = new WeakMap;
z5 = new WeakMap;
function sW({RootComponent: e, isWebsite: t, routeId: n, framerSiteId: r, pathVariables: i, routes: o, collectionUtils: s, notFoundPage: a, isReducedMotion: l=!1, includeDataObserver: c=!1, localeId: u, locales: f, preserveQueryParams: d, EditorBar: p}) {
    let {enableAsyncURLUpdates: v} = Gu();
    if (x.useEffect( () => {
        t || Mk.start()
    }
    , []),
    t)
        return k(B0, {
            reducedMotion: l ? "user" : "never",
            children: k(M5, {
                children: k(Gz, {
                    children: k(AC.Provider, {
                        value: r,
                        children: k(gL, {
                            initialRoute: n,
                            initialPathVariables: i,
                            initialLocaleId: u,
                            routes: o,
                            collectionUtils: s,
                            notFoundPage: a,
                            locales: f,
                            defaultPageStyle: {
                                minHeight: "100vh",
                                width: "auto"
                            },
                            preserveQueryParams: d,
                            enableAsyncURLUpdates: v,
                            editorBar: k(B5, {
                                EditorBar: p
                            })
                        })
                    })
                })
            })
        });
    {
        let g = c ? U3 : x.Fragment;
        return k(g, {
            children: k(aL, {
                routes: o,
                children: k($3, {
                    children: x.isValidElement(e) ? e : x.createElement(e, {
                        key: n
                    })
                })
            })
        })
    }
}
function B5({EditorBar: e}) {
    let[t,n] = Oe(!1)
      , r = D(AC);
    return $( () => {
        Mt( () => {
            n(!0)
        }
        )
    }
    , []),
    !e || !r || !t ? null : k(k5, {
        children: k(pr, {
            children: k(e, {
                framerSiteId: r
            })
        })
    })
}
function $5(e, t, n) {
    let r = mn.map(e, i => Ot(i) ? mr(i, t) : i);
    return n ? r : k(it, {
        children: r
    })
}
var cg = x.createContext(void 0)
  , zC = "ssr-variant";
function V1(e, t, n, r, i, o, s, a) {
    let l = x.Children.toArray(t)
      , c = l[0];
    if (l.length !== 1 || !x.isValidElement(c))
        return console.warn("PropertyOverrides: expected exactly one React element for a child", t),
        s(t, n);
    let u = []
      , f = [];
    for (let[g] of Object.entries(r)) {
        if (g === i)
            continue;
        let b = e[g];
        if (!b || !j5(c.props, b)) {
            f.push(g);
            continue
        }
        let m = A1([g], o);
        m.length && u.push({
            variants: m,
            propOverrides: b
        })
    }
    if (u.length === 0)
        return s(c, n);
    let d = [i, ...f]
      , p = A1(d, o);
    p.length && u.unshift({
        variants: p
    });
    let v = [];
    for (let {variants: g, propOverrides: b} of u) {
        if (a && !g.includes(a))
            continue;
        let m = g.join("+")
          , h = k(cg.Provider, {
            value: new Set(g),
            children: s(c, b ? {
                ...n,
                ...b
            } : n)
        }, m)
          , y = N5(g, o, r);
        y.length ? (A(u.length > 1, "Must branch out when there are hiddenClassNames"),
        h = k("div", {
            className: `${zC} ${y.join(" ")}`,
            children: h
        }, m)) : A(u.length === 1, "Cannot branch out when hiddenClassNames is empty"),
        v.push(h)
    }
    return A(!a || v.length === 1, "Must render exactly one branch when activeVariantId is given"),
    v
}
function BC(e) {
    return e.split("-")[2]
}
function N5(e, t, n) {
    let r = [];
    for (let[i,o] of Object.entries(n)) {
        let s = t && !t.has(i);
        e.includes(i) || s || r.push(`hidden-${BC(o)}`)
    }
    return r
}
function A1(e, t) {
    return t ? e.filter(n => t.has(n)) : e
}
function j5(e, t) {
    for (let n of Object.keys(t))
        if (!Qm(e[n], t[n], !0))
            return !0;
    return !1
}
function H5(e, t, n) {
    return !n || !e ? t : {
        ...t,
        ...n[e]
    }
}
var W5 = x.forwardRef(function({breakpoint: t, overrides: n, children: r, ...i}, o) {
    let s = Uu(o)
      , a = x.useContext(cg)
      , l = iL()
      , c = mt( () => l.current ? Vr() ? 1 : 2 : 0)
      , u = x.useContext(TC);
    if (!u)
        return console.warn("PropertyOverrides is missing GeneratedComponentContext"),
        s(r, i);
    let {primaryVariantId: f, variantClassNames: d} = u;
    switch (c) {
    case 0:
        return s(r, H5(t, i, n));
    case 1:
        return V1(n, r, i, d, f, a, s, t);
    case 2:
        return V1(n, r, i, d, f, a, $5, void 0);
    default:
        ke(c)
    }
})
  , uW = ( () => CC(W5, `.${zC} { display: contents }`, "PropertyOverrides"))()
  , dW = EC(Ie(function({links: t, children: n, ...r}, i) {
    let o = Ki()
      , {activeLocale: s} = Ek()
      , a = Uu(i)
      , l = []
      , c = t.map(f => w5(f.href, o, f.implicitPathVariables, (d, p) => {
        function v(g) {
            let b = {};
            for (let m in g) {
                let h = g[m];
                A(o.collectionUtils, "collectionUtils should be defined"),
                A(h, "unresolvedSlug be defined");
                let y = _C(h, o.collectionUtils, s)
                  , w = y.preload();
                if (w)
                    l.push(w);
                else {
                    let C = y.read();
                    C && (b[m] = C)
                }
            }
            return b
        }
        return {
            path: v(d),
            hash: v(p)
        }
    }
    ));
    if (l.length > 0)
        throw Promise.allSettled(l);
    let u = n(c);
    return a(u, r)
}));
function U5(e) {
    return {
        trace(...t) {
            var n;
            return (n = pt.getLogger(e)) == null ? void 0 : n.trace(...t)
        },
        debug(...t) {
            var n;
            return (n = pt.getLogger(e)) == null ? void 0 : n.debug(...t)
        },
        info(...t) {
            var n;
            return (n = pt.getLogger(e)) == null ? void 0 : n.info(...t)
        },
        warn(...t) {
            var n;
            return (n = pt.getLogger(e)) == null ? void 0 : n.warn(...t)
        },
        error(...t) {
            var n;
            return (n = pt.getLogger(e)) == null ? void 0 : n.error(...t)
        }
    }
}
function G5(e) {
    return $u(e) && e.every(Re)
}
function $C(e) {
    return Re(e) && jn(e.read) && jn(e.preload)
}
function q5(e) {
    return G5(e) || $C(e)
}
function NC(e) {
    return Re(e) && Re(e.schema)
}
function X5(e) {
    return Re(e) && Re(e.collectionByLocaleId)
}
async function D1(e, t) {
    return $C(e) ? (await e.preload(t),
    e.read(t)) : e
}
var Y5 = class {
    constructor(e, t) {
        this.collection = e,
        this.locale = t,
        R(this, "schema"),
        R(this, "indexes", []);
        let n = CA(e);
        A(n, "Collection does not have properties");
        let r = {
            id: {
                type: "string",
                isNullable: !1
            }
        }
          , i = Object.entries(n);
        for (let[o,s] of i) {
            if (!s)
                continue;
            let a = s.type;
            A(a !== "array", "Array properties are not supported"),
            A(a !== "object", "Object properties are not supported"),
            r[o] = {
                type: a,
                isNullable: !0
            }
        }
        this.schema = r
    }
    getDatabaseItem(e, t) {
        let n = {};
        for (let r in this.schema) {
            let i = e[r];
            if (yA(i))
                continue;
            let o = this.schema[r];
            et(o) || (A(o.type !== "unknown", "Invalid definition type"),
            n[r] = {
                type: o.type,
                value: i
            })
        }
        return {
            pointer: t,
            data: n
        }
    }
    async resolveRichText(e) {
        if (rg.is(e)) {
            let t = e.preload();
            return t && await t,
            e.read()
        }
        return e
    }
    async scanItems() {
        return (await D1(this.collection, this.locale)).map( (t, n) => {
            let r = String(n);
            return this.getDatabaseItem(t, r)
        }
        )
    }
    async resolveItems(e) {
        let t = await D1(this.collection, this.locale);
        return e.map(n => {
            let r = Number(n)
              , i = t[r];
            return A(i, "Can't find collection item"),
            this.getDatabaseItem(i, n)
        }
        )
    }
    compareItems(e, t) {
        return Number(e.pointer) - Number(t.pointer)
    }
}
;
function K5(e, t) {
    switch (e?.type) {
    case "array":
        return {
            type: "array",
            value: e.value.map(r => _e.cast(r, t.definition))
        }
    }
    return null
}
function jC(e) {
    switch (e?.type) {
    case "boolean":
        return e;
    case "number":
    case "string":
        return {
            type: "boolean",
            value: !!e.value
        }
    }
    return null
}
function Ar(e) {
    let t = jC(e);
    return t?.value ?? !1
}
function Q5(e) {
    switch (e?.type) {
    case "color":
        return e
    }
    return null
}
function Z5(e) {
    switch (e?.type) {
    case "date":
        return e;
    case "number":
    case "string":
        {
            let t = new Date(e.value);
            return jk(t) ? {
                type: "date",
                value: t.toISOString()
            } : null
        }
    }
    return null
}
function J5(e) {
    switch (e?.type) {
    case "enum":
        return e;
    case "string":
        return {
            type: "enum",
            value: e.value
        }
    }
    return null
}
function e4(e) {
    switch (e?.type) {
    case "file":
        return e
    }
    return null
}
function t4(e) {
    switch (e?.type) {
    case "link":
        return e;
    case "string":
        try {
            let {protocol: t} = new URL(e.value);
            return t === "http:" || t === "https:" ? {
                type: "link",
                value: e.value
            } : null
        } catch {
            return null
        }
    }
    return null
}
function HC(e) {
    switch (e?.type) {
    case "number":
    case "string":
        {
            let t = Number(e.value);
            return Number.isFinite(t) ? {
                type: "number",
                value: t
            } : null
        }
    }
    return null
}
function WC(e) {
    let t = HC(e);
    return t?.value ?? null
}
function n4(e, t) {
    switch (e?.type) {
    case "object":
        {
            let n = {}
              , r = Object.entries(t.definitions);
            for (let[i,o] of r) {
                let s = e.value[i] ?? null;
                n[i] = _e.cast(s, o)
            }
            return {
                type: "object",
                value: n
            }
        }
    }
    return null
}
function r4(e) {
    switch (e?.type) {
    case "responsiveimage":
        return e
    }
    return null
}
function i4(e) {
    switch (e?.type) {
    case "richtext":
        return e
    }
    return null
}
function UC(e) {
    switch (e?.type) {
    case "string":
        return e;
    case "number":
        return {
            type: "string",
            value: String(e.value)
        }
    }
    return null
}
function Go(e) {
    let t = UC(e);
    return t?.value ?? null
}
var _e = {
    cast(e, t) {
        switch (t.type) {
        case "array":
            return K5(e, t);
        case "boolean":
            return jC(e);
        case "color":
            return Q5(e);
        case "date":
            return Z5(e);
        case "enum":
            return J5(e);
        case "file":
            return e4(e);
        case "link":
            return t4(e);
        case "number":
            return HC(e);
        case "object":
            return n4(e, t);
        case "responsiveimage":
            return r4(e);
        case "richtext":
            return i4(e);
        case "string":
            return UC(e);
        case "unknown":
            return e;
        default:
            ke(t, "Unsupported cast")
        }
    },
    parse(e) {
        return qm(e) ? {
            type: "boolean",
            value: e
        } : jk(e) ? {
            type: "date",
            value: e.toISOString()
        } : He(e) ? {
            type: "number",
            value: e
        } : xe(e) ? {
            type: "string",
            value: e
        } : $u(e) ? {
            type: "array",
            value: e.map(_e.parse)
        } : null
    },
    equal(e, t, n) {
        return e?.type !== t?.type ? !1 : Ni(e, t, n) === 0
    },
    lessThan(e, t, n) {
        return e?.type !== t?.type ? !1 : Ni(e, t, n) < 0
    },
    lessThanOrEqual(e, t, n) {
        return e?.type !== t?.type ? !1 : Ni(e, t, n) <= 0
    },
    greaterThan(e, t, n) {
        return e?.type !== t?.type ? !1 : Ni(e, t, n) > 0
    },
    greaterThanOrEqual(e, t, n) {
        return e?.type !== t?.type ? !1 : Ni(e, t, n) >= 0
    },
    in(e, t, n) {
        return t?.type !== "array" ? !1 : t.value.some(r => _e.equal(r, e, n))
    },
    indexOf(e, t, n) {
        return e?.type !== "array" ? -1 : e.value.findIndex(r => _e.equal(r, t, n))
    },
    contains(e, t, n) {
        let r = Go(e)
          , i = Go(t);
        return ar(r) || ar(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
        i = i.toLowerCase()),
        r.includes(i))
    },
    startsWith(e, t, n) {
        let r = Go(e)
          , i = Go(t);
        return ar(r) || ar(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
        i = i.toLowerCase()),
        r.startsWith(i))
    },
    endsWith(e, t, n) {
        let r = Go(e)
          , i = Go(t);
        return ar(r) || ar(i) ? !1 : (n.type === 0 && (r = r.toLowerCase(),
        i = i.toLowerCase()),
        r.endsWith(i))
    },
    length(e) {
        switch (e?.type) {
        case "array":
            return e.value.length
        }
        return 0
    },
    stringify(e) {
        if (e === null)
            return "null";
        switch (e.type) {
        case "array":
            return `[${e.value.map(_e.stringify).join(", ")}]`;
        case "boolean":
        case "number":
            return String(e.value);
        case "string":
            return `'${e.value}'`;
        case "enum":
            return `'${e.value}' /* Enum */`;
        case "color":
            return `'${e.value}' /* Color */`;
        case "date":
            return `'${e.value}' /* Date */`;
        case "richtext":
            return "RichText";
        case "responsiveimage":
            return "ResponsiveImage";
        case "file":
            return "File";
        case "link":
            return xe(e.value) ? `'${e.value}' /* Link */` : "Link";
        case "object":
            return "Object";
        default:
            ke(e)
        }
    }
};
function Ni(e, t, n) {
    if (ar(e) || ar(t))
        return A(e === t),
        0;
    switch (e.type) {
    case "array":
        {
            A(e.type === t.type);
            let r = e.value.length
              , i = t.value.length;
            if (r < i)
                return -1;
            if (r > i)
                return 1;
            for (let o = 0; o < r; o++) {
                let s = e.value[o]
                  , a = t.value[o];
                A(!et(s), "Left item must exist"),
                A(!et(a), "Right item must exist");
                let l = Ni(s, a, n);
                if (l !== 0)
                    return l
            }
            return 0
        }
    case "boolean":
        return A(e.type === t.type),
        e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    case "color":
        return A(e.type === t.type),
        e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    case "date":
        {
            A(e.type === t.type);
            let r = new Date(e.value)
              , i = new Date(t.value);
            return r < i ? -1 : r > i ? 1 : 0
        }
    case "enum":
        return A(e.type === t.type),
        e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    case "file":
        return A(e.type === t.type),
        e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    case "link":
        {
            A(e.type === t.type);
            let r = JSON.stringify(e.value)
              , i = JSON.stringify(t.value);
            return r < i ? -1 : r > i ? 1 : 0
        }
    case "number":
        return A(e.type === t.type),
        e.value < t.value ? -1 : e.value > t.value ? 1 : 0;
    case "object":
        {
            A(e.type === t.type);
            let r = Object.keys(e.value).sort()
              , i = Object.keys(t.value).sort();
            if (r.length < i.length)
                return -1;
            if (r.length > i.length)
                return 1;
            for (let o = 0; o < r.length; o++) {
                let s = r[o]
                  , a = i[o];
                if (A(!et(s), "Left key must exist"),
                A(!et(a), "Left key must exist"),
                s < a)
                    return -1;
                if (s > a)
                    return 1;
                let l = e.value[s]
                  , c = t.value[a];
                A(!et(l), "Left value must exist"),
                A(!et(c), "Right value must exist");
                let u = Ni(l, c, n);
                if (u !== 0)
                    return u
            }
            return 0
        }
    case "responsiveimage":
        {
            A(e.type === t.type);
            let r = JSON.stringify(e.value)
              , i = JSON.stringify(t.value);
            return r < i ? -1 : r > i ? 1 : 0
        }
    case "richtext":
        {
            A(e.type === t.type);
            let r = e.value
              , i = t.value;
            return r < i ? -1 : r > i ? 1 : 0
        }
    case "string":
        {
            A(e.type === t.type);
            let r = e.value
              , i = t.value;
            return n.type === 0 && (r = e.value.toLowerCase(),
            i = t.value.toLowerCase()),
            r < i ? -1 : r > i ? 1 : 0
        }
    default:
        ke(e)
    }
}
var z1 = {
    type: "unknown",
    isNullable: !0
};
function o4() {
    return 25
}
function s4() {
    return 100 * 125
}
var ku = 1e3
  , oe = class {
    constructor(e) {
        this.network = e
    }
    static estimate(e, t) {
        let n = o4()
          , r = s4()
          , i = e * n + t / r;
        return new oe(i)
    }
    static max(e, t) {
        let n = Math.max(e.network, t.network);
        return new oe(n)
    }
    static compare(e, t) {
        return e.network < t.network ? -1 : e.network > t.network ? 1 : 0
    }
    add(e) {
        return this.network += e.network,
        this
    }
    toString() {
        return `${this.network}ms`
    }
}
;
var GC = class {
    constructor(e, t) {
        this.id = e,
        this.relational = t,
        R(this, "nodes", []),
        R(this, "winners", new Map)
    }
    addNode(e) {
        this.nodes.push(e),
        e.setGroup(this)
    }
    getWinner(e) {
        let t = e.getHash()
          , n = this.winners.get(t);
        if (n)
            return n;
        let r = new a4;
        return this.winners.set(t, r),
        r
    }
    getOptimized(e) {
        let t = this.getWinner(e);
        A(t.node, "Group not optimized");
        let n = t.node.getOptimized(e);
        return n.setGroup(this),
        n
    }
}
  , a4 = class {
    constructor() {
        R(this, "node"),
        R(this, "cost", new oe(1 / 0)),
        R(this, "nodes", [])
    }
    update(e, t) {
        this.nodes.push(e),
        oe.compare(t, this.cost) < 0 && (this.node = e,
        this.cost = t)
    }
}
;
function qC(e) {
    let t = e.next();
    return A(t.done, "Generator must not yield"),
    t.value
}
async function qu(e, t=e.next()) {
    for (; !t.done; ) {
        let n = await t.value;
        t = e.next(n)
    }
    return t.value
}
function *We(e) {
    let t = {}
      , n = Object.keys(e)
      , r = [];
    for (let i of n) {
        let o = e[i];
        if (Hk(o)) {
            let s = o.next();
            s.done ? t[i] = s.value : r.push(qu(o, s).then(a => {
                t[i] = a
            }
            ))
        } else
            t[i] = o
    }
    return r.length > 0 && (yield Promise.all(r)),
    t
}
function *Cu(e) {
    let t = []
      , n = e.keys()
      , r = [];
    for (let i of n) {
        let o = e[i];
        if (Hk(o)) {
            let s = o.next();
            s.done ? t[i] = s.value : r.push(qu(o, s).then(a => {
                t[i] = a
            }
            ))
        } else
            t[i] = o
    }
    return r.length > 0 && (yield Promise.all(r)),
    t
}
var XC = class {
    constructor(e) {
        this.isSynchronous = e
    }
}
  , _n = class extends XC {
    constructor() {
        super(...arguments),
        R(this, "group")
    }
    getGroup() {
        return A(this.group, "Node must be in a group"),
        this.group
    }
    setGroup(e) {
        A(!this.group, "Node is already in a group"),
        this.group = e
    }
    evaluateSync() {
        let e = this.evaluate(void 0);
        return qC(e)
    }
    evaluateAsync() {
        let e = this.evaluate(void 0);
        return qu(e)
    }
}
;
function l4(e) {
    return Re(e) && jn(e.getHash)
}
function le(e, ...t) {
    let n = t.map(r => {
        let i = r instanceof KC;
        A(!i, "Pass CollectionMetadata.id instead");
        let o = r instanceof Sa;
        A(!o, "Pass FieldMetadata.id instead");
        let s = r instanceof QC;
        A(!s, "Pass IndexMetadata.id instead");
        let a = r instanceof _n;
        A(!a, "Pass RelationalNode.group.id instead");
        let l = r instanceof GC;
        return A(!l, "Pass Group.id instead"),
        l4(r) ? r.getHash() : JSON.stringify(r)
    }
    );
    return `${e}(${n.join(", ")})`
}
var ug = class {
    constructor(e, t) {
        this.data = e,
        this.pointer = t,
        R(this, "cached")
    }
    resolve() {
        return this.cached ?? (this.cached = this.data.resolveRichText(this.pointer)),
        this.cached
    }
}
  , Jo = "index"
  , YC = class extends Set {
    merge(e) {
        for (let t of e)
            this.add(t)
    }
    equals(e) {
        if (this === e)
            return !0;
        if (this.size !== e.size)
            return !1;
        for (let t of this)
            if (!e.has(t))
                return !1;
        return !0
    }
    subsetOf(e) {
        if (this === e)
            return !0;
        if (this.size > e.size)
            return !1;
        for (let t of this)
            if (!e.has(t))
                return !1;
        return !0
    }
    getHash() {
        let e = [];
        for (let t of this)
            e.push(t.id);
        return e.sort( (t, n) => t - n),
        le(this.name, ...e)
    }
}
;
var KC = class {
    constructor(e, t, n) {
        this.id = e,
        this.name = t,
        this.data = n,
        R(this, "indexes", new c4),
        R(this, "fields", new W)
    }
}
;
var QC = class {
    constructor(e, t, n, r, i, o) {
        this.id = e,
        this.data = t,
        this.collection = n,
        this.lookupNodes = r,
        this.constraint = i,
        this.ordering = o,
        R(this, "resolvedFields", new W);
        for (let s in t.schema)
            for (let a of n.fields)
                a.name === s && this.resolvedFields.add(a)
    }
}
  , c4 = class extends YC {
    constructor() {
        super(...arguments),
        R(this, "name", "Indexes")
    }
}
;
var Sa = class {
    constructor(e, t, n, r) {
        this.id = e,
        this.name = t,
        this.definition = n,
        this.collection = r
    }
    getValue(e) {
        A(this.name, "Can only get value of field with a name");
        let t = e.data[this.name];
        return t?.type === "richtext" ? (A(this.collection, "Rich text field must have a collection"),
        {
            type: "richtext",
            value: new ug(this.collection.data,t.value)
        }) : t ?? null
    }
}
  , W = class extends YC {
    constructor() {
        super(...arguments),
        R(this, "name", "Fields")
    }
}
  , fn = class {
    constructor(e, t) {
        this.ordering = e,
        this.resolvedFields = t
    }
    getHash() {
        return le("RequiredProps", this.ordering, this.resolvedFields)
    }
    get isMinimal() {
        return this.ordering.length === 0 && this.resolvedFields.size === 0
    }
    canProvide(e) {
        return this.canProvideOrdering(e) && this.canProvideResolvedFields(e)
    }
    canProvideOrdering(e) {
        return this.ordering.length === 0 ? !0 : e.canProvideOrdering(this.ordering)
    }
    canProvideResolvedFields(e) {
        return this.resolvedFields.size === 0 ? !0 : e.canProvideResolvedFields(this.resolvedFields)
    }
}
  , fr = class {
    constructor() {
        R(this, "pointers", new Map),
        R(this, "values", new Map)
    }
    getKey() {
        let e = [];
        for (let[t,n] of this.pointers)
            e.push(`${t.id}-${n}`);
        return e.sort().join("-")
    }
    addValue(e, t) {
        this.values.set(e, t)
    }
    getValue(e) {
        return this.values.get(e) ?? null
    }
    mergeValues(e) {
        for (let[t,n] of e.values)
            this.addValue(t, n)
    }
    addPointer(e, t) {
        this.pointers.set(e, t)
    }
    getPointer(e) {
        return this.pointers.get(e)
    }
    mergePointers(e) {
        for (let[t,n] of e.pointers)
            this.addPointer(t, n)
    }
    merge(e) {
        this.mergeValues(e),
        this.mergePointers(e)
    }
}
  , Fn = class {
    constructor(e, t=[]) {
        this.fields = e,
        this.tuples = t
    }
    push(e) {
        this.tuples.push(e)
    }
    filter(e) {
        let t = this.tuples.filter(e);
        return new Fn(this.fields,t)
    }
    map(e, t) {
        let n = this.tuples.map(t);
        return new Fn(e,n)
    }
    sort(e) {
        let t = Array.from(this.tuples).sort(e);
        return new Fn(this.fields,t)
    }
    slice(e, t) {
        let n = this.tuples.slice(e, t);
        return new Fn(this.fields,n)
    }
    union(e) {
        let t = new W;
        for (let i of this.fields)
            e.fields.has(i) && t.add(i);
        let n = new Set
          , r = new Fn(t);
        for (let i of this.tuples) {
            let o = i.getKey();
            n.add(o),
            r.push(i)
        }
        for (let i of e.tuples) {
            let o = i.getKey();
            n.has(o) || r.push(i)
        }
        return r
    }
    intersection(e) {
        let t = new W;
        for (let i of this.fields)
            e.fields.has(i) && t.add(i);
        let n = new Set
          , r = new Fn(t);
        for (let i of this.tuples) {
            let o = i.getKey();
            n.add(o)
        }
        for (let i of e.tuples) {
            let o = i.getKey();
            n.has(o) && r.push(i)
        }
        return r
    }
}
  , Im = class {
    constructor(e, t) {
        this.input = e,
        this.field = t
    }
    getHash() {
        return le("ProjectionField", this.input, this.field.id)
    }
}
  , Om = class extends _n {
    constructor(e, t, n) {
        let r = e.isSynchronous;
        for (let i of t)
            r && (r = i.input.isSynchronous);
        super(r),
        this.input = e,
        this.projections = t,
        this.passthrough = n,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("RelationalProject", this.inputGroup.id, ...this.projections, this.passthrough)
    }
    getOutputFields() {
        let e = new W;
        e.merge(this.passthrough);
        for (let t of this.projections)
            e.add(t.field);
        return e
    }
    canProvideOrdering(e) {
        let t = new W;
        for (let n of this.projections)
            t.add(n.field);
        for (let {field: n} of e.fields)
            if (t.has(n))
                return !1;
        return !0
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new W(e.resolvedFields);
        for (let n of this.projections)
            t.merge(n.input.referencedFields),
            t.delete(n.field);
        return new fn(e.ordering,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n)
          , i = new oe(0);
        for (let o of this.projections) {
            let s = o.input.optimize(e);
            i = oe.max(i, s)
        }
        return new oe(0).add(oe.max(r, i))
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t)
          , r = this.projections.map(i => {
            let o = i.input.getOptimized();
            return new Im(o,i.field)
        }
        );
        return new Om(n,r,this.passthrough)
    }
    *evaluate(e) {
        let t = this.getOutputFields()
          , n = yield*this.input.evaluate(e)
          , r = yield*Cu(n.tuples.map(i => Cu(this.projections.map(o => We({
            field: o.field,
            value: o.input.evaluate(e, i)
        })))));
        return n.map(t, (i, o) => {
            let s = new fr;
            s.mergePointers(i);
            for (let l of this.passthrough) {
                let c = i.getValue(l);
                s.addValue(l, c)
            }
            let a = r[o];
            A(a, "Projections must exist");
            for (let {field: l, value: c} of a)
                s.addValue(l, c);
            return s
        }
        )
    }
}
  , rs = {
    type: 0
}
  , Xe = class extends XC {
    constructor(e, t, n) {
        super(n),
        this.referencedFields = e,
        this.referencedOuterFields = t,
        this.isSynchronous = n
    }
    evaluateSync() {
        let e = this.evaluate(void 0, void 0);
        return qC(e)
    }
    evaluateAsync() {
        let e = this.evaluate(void 0, void 0);
        return qu(e)
    }
}
  , u4 = {
    type: 0
}
  , fg = class {
    constructor(e, t) {
        this.when = e,
        this.then = t
    }
    getHash() {
        return le("CaseCondition", this.when, this.then)
    }
}
  , ZC = class extends Xe {
    constructor(e, t, n) {
        let r = new W
          , i = new W
          , o = !0;
        e && (r.merge(e.referencedFields),
        i.merge(e.referencedOuterFields),
        o && (o = e.isSynchronous));
        for (let {when: s, then: a} of t)
            r.merge(s.referencedFields),
            i.merge(s.referencedOuterFields),
            o && (o = s.isSynchronous),
            r.merge(a.referencedFields),
            i.merge(a.referencedOuterFields),
            o && (o = a.isSynchronous);
        n && (r.merge(n.referencedFields),
        i.merge(n.referencedOuterFields),
        o && (o = n.isSynchronous)),
        super(r, i, o),
        this.input = e,
        this.conditions = t,
        this.otherwise = n,
        R(this, "definition", {
            type: "unknown",
            isNullable: !0
        })
    }
    getHash() {
        return le("ScalarCase", this.input, ...this.conditions, this.otherwise)
    }
    toString() {
        let e = "CASE";
        this.input && (e = `${e} ${this.input}`);
        for (let {when: t, then: n} of this.conditions)
            e = `${e} WHEN ${t} THEN ${n}`;
        return this.otherwise && (e = `${e} ELSE ${this.otherwise}`),
        `${e} END`
    }
    optimize(e) {
        var t, n;
        (t = this.input) == null || t.optimize(e);
        for (let r of this.conditions)
            r.when.optimize(e),
            r.then.optimize(e);
        return (n = this.otherwise) == null || n.optimize(e),
        new oe(0)
    }
    getOptimized() {
        var e, t;
        let n = (e = this.input) == null ? void 0 : e.getOptimized()
          , r = this.conditions.map(o => {
            let s = o.when.getOptimized()
              , a = o.then.getOptimized();
            return new fg(s,a)
        }
        )
          , i = (t = this.otherwise) == null ? void 0 : t.getOptimized();
        return new ZC(n,r,i)
    }
    *evaluate(e, t) {
        var n, r;
        let {input: i, conditions: o, otherwise: s} = yield*We({
            input: ((n = this.input) == null ? void 0 : n.evaluate(e, t)) ?? null,
            conditions: Cu(this.conditions.map(a => We({
                when: a.when.evaluate(e, t),
                then: a.then.evaluate(e, t)
            }))),
            otherwise: ((r = this.otherwise) == null ? void 0 : r.evaluate(e, t)) ?? null
        });
        if (this.input) {
            for (let {when: a, then: l} of o)
                if (_e.equal(i, a, u4))
                    return l
        } else
            for (let {when: a, then: l} of o)
                if (Ar(a))
                    return l;
        return s
    }
}
  , hm = class {
    constructor(e, t="asc") {
        this.field = e,
        this.direction = t
    }
    getHash() {
        return le("OrderingField", this.field.id, this.direction)
    }
}
  , lr = class {
    constructor(e) {
        R(this, "fields", []),
        e && this.merge(e)
    }
    get length() {
        return this.fields.length
    }
    getHash() {
        return le("Ordering", ...this.fields)
    }
    push(e) {
        this.fields.push(e)
    }
    merge(e) {
        this.fields.push(...e.fields)
    }
    equals(e) {
        return this === e ? !0 : this.length !== e.length ? !1 : this.getHash() === e.getHash()
    }
    providedByFields(e) {
        for (let {field: t} of this.fields)
            if (!e.has(t) && t.name !== Jo)
                return !1;
        return !0
    }
}
  , Mm = class {
    constructor(e) {
        this.parent = e,
        R(this, "node"),
        R(this, "ordering"),
        R(this, "fields", [])
    }
    takeNode() {
        let e = this.node;
        return A(e, "Node is missing"),
        this.node = void 0,
        e
    }
    setNode(e) {
        A(!this.node, "Node already set"),
        this.node = e
    }
    setOrdering(e) {
        this.ordering = e
    }
    push() {
        return new Mm(this)
    }
    replace() {
        return new Mm(this.parent)
    }
    addField(e) {
        this.fields.push(e)
    }
    addFieldsFromScope(e) {
        for (let t of e.fields)
            this.addField(t)
    }
    resolveField(e, t) {
        var n;
        let r = [];
        for (let i of this.fields)
            i.name === e && (t && i.collectionName !== t || r.push(i));
        if (r.length === 1)
            return r[0];
        if (r.length > 1)
            throw new Error("Ambiguous fields");
        return (n = this.parent) == null ? void 0 : n.resolveField(e, t)
    }
    has(e) {
        var t;
        return this.fields.includes(e) ? !0 : ((t = this.parent) == null ? void 0 : t.has(e)) ?? !1
    }
    getRequiredOrdering() {
        return this.ordering ?? new lr
    }
    getRequiredResolvedFields() {
        let e = new W;
        for (let {field: t} of this.fields)
            t.collection && e.add(t);
        return e
    }
    getRequiredProps() {
        let e = this.getRequiredOrdering()
          , t = this.getRequiredResolvedFields();
        return new fn(e,t)
    }
    getNamedFields() {
        let e = {};
        for (let {name: t, field: n} of this.fields)
            e[t] = n;
        return e
    }
    getSingleField() {
        A(this.fields.length === 1, "Scope must contain exactly one field");
        let e = this.fields[0];
        return A(e, "Field must exist"),
        e.field
    }
}
  , f4 = class {
    constructor(e, t, n) {
        this.normalizer = e,
        this.query = t,
        this.locale = n,
        R(this, "collectionId", 0),
        R(this, "indexId", 0),
        R(this, "fieldId", 0),
        R(this, "subqueries", [])
    }
    build() {
        let e = new Mm;
        return this.buildQuery(e, this.query)
    }
    buildQuery(e, t) {
        let n = {
            type: "Select",
            ...t
        };
        return this.buildSelect(e, n)
    }
    buildSelect(e, t) {
        let n = this.buildFrom(e, t.from)
          , r = n.getRequiredOrdering();
        if (t.where) {
            let l = n.takeNode()
              , c = this.buildExpression(n, t.where)
              , u = this.normalizer.newRelationalFilter(l, c);
            n.setNode(u)
        }
        let i = [], o = new W, s;
        if (t.orderBy) {
            s = new lr;
            for (let l of t.orderBy)
                if (l.type === "Identifier") {
                    let c = n.resolveField(l.name, l.collection);
                    if (et(c))
                        continue;
                    o.add(c.field);
                    let u = new hm(c.field,l.direction);
                    s.push(u)
                } else {
                    let c = this.buildExpression(n, l)
                      , u = this.fieldId++
                      , f = new Sa(u,void 0,c.definition,void 0)
                      , d = new Im(c,f);
                    i.push(d);
                    let p = new hm(f,l.direction);
                    s.push(p)
                }
            s.merge(r)
        } else
            s = r;
        let a = this.buildSelectList(n, t.select, o, i);
        if (a.setOrdering(s),
        t.offset) {
            let l = a.takeNode()
              , c = this.buildExpression(e, t.offset)
              , u = this.normalizer.newRelationalOffset(l, c, s);
            a.setNode(u)
        }
        if (t.limit) {
            let l = a.takeNode()
              , c = this.buildExpression(e, t.limit)
              , u = this.normalizer.newRelationalLimit(l, c, s);
            a.setNode(u)
        }
        return a
    }
    buildSelectList(e, t, n, r) {
        let i = e.push()
          , o = new W(n)
          , s = [...r];
        for (let c of t)
            if (c.type === "Identifier") {
                let u = e.resolveField(c.name, c.collection);
                if (et(u))
                    continue;
                o.add(u.field),
                i.addField({
                    ...u,
                    name: c.alias ?? u.name
                })
            } else {
                let u = this.buildExpression(e, c);
                A(c.alias, "Subqueries should have an alias");
                let f = this.fieldId++
                  , d = c.alias
                  , p = new Sa(f,d,u.definition,void 0)
                  , v = new Im(u,p);
                s.push(v),
                i.addField({
                    field: p,
                    name: d
                })
            }
        let a = e.takeNode()
          , l = this.normalizer.newRelationalProject(a, s, o);
        return i.setNode(l),
        i
    }
    buildFrom(e, t) {
        switch (t.type) {
        case "Collection":
            return this.buildCollection(e, t);
        case "LeftJoin":
            return this.buildJoin(e, t);
        default:
            ke(t, "Unsupported from type")
        }
    }
    buildCollection(e, t) {
        let n = e.push()
          , r = d4(t.data, this.locale)
          , i = t.alias
          , o = this.collectionId++
          , s = new KC(o,i,r);
        for (let[l,c] of Object.entries(r.schema)) {
            let u = this.fieldId++
              , f = new Sa(u,l,c,s);
            n.addField({
                field: f,
                name: l,
                collectionName: i
            }),
            s.fields.add(f)
        }
        {
            let l = {
                type: "number",
                isNullable: !1
            }
              , c = this.fieldId++
              , u = new Sa(c,Jo,l,s);
            n.addField({
                field: u,
                name: Jo,
                collectionName: i
            });
            let f = new lr
              , d = new hm(u);
            f.push(d),
            n.setOrdering(f)
        }
        for (let l of r.indexes) {
            let c = [];
            for (let v of l.fields) {
                let g = this.buildExpression(n, v);
                c.push(g)
            }
            let u;
            l.where && (u = this.buildExpression(n, l.where));
            let f = new lr
              , d = this.indexId++
              , p = new QC(d,l,s,c,u,f);
            s.indexes.add(p)
        }
        let a = this.normalizer.newRelationalScan(s);
        return n.setNode(a),
        n
    }
    buildJoin(e, t) {
        let n = this.buildFrom(e, t.left)
          , r = this.buildFrom(e, t.right)
          , i = new lr
          , o = n.getRequiredOrdering();
        i.merge(o);
        let s = r.getRequiredOrdering();
        i.merge(s);
        let a = e.push();
        a.addFieldsFromScope(n),
        a.addFieldsFromScope(r),
        a.setOrdering(i);
        let l = this.buildExpression(a, t.constraint), c = n.takeNode(), u = r.takeNode(), f;
        switch (t.type) {
        case "LeftJoin":
            f = this.normalizer.newRelationalLeftJoin(c, u, l);
            break;
        default:
            ke(t.type, "Unsupported join type")
        }
        return a.setNode(f),
        a
    }
    buildExpression(e, t) {
        switch (t.type) {
        case "Identifier":
            return this.buildIdentifier(e, t);
        case "LiteralValue":
            return this.buildLiteralValue(t);
        case "FunctionCall":
            return this.buildFunctionCall(e, t);
        case "Case":
            return this.buildCase(e, t);
        case "UnaryOperation":
            return this.buildUnaryOperation(e, t);
        case "BinaryOperation":
            return this.buildBinaryOperation(e, t);
        case "TypeCast":
            return this.buildTypeCast(e, t);
        case "Select":
            throw new Error("Subqueries are only supported inside subquery function calls");
        default:
            ke(t, "Unsupported expression")
        }
    }
    buildIdentifier(e, t) {
        let n = e.resolveField(t.name, t.collection);
        if (n) {
            let r = !1;
            for (let i of this.subqueries)
                r ? i.referencedOuterFields.add(n.field) : (r = i.inScope.has(n),
                r && i.referencedFields.add(n.field));
            return this.normalizer.newScalarVariable(n.field, r)
        }
        return this.normalizer.newScalarConstant(z1, null)
    }
    buildLiteralValue(e) {
        let t = _e.parse(e.value);
        return this.normalizer.newScalarConstant(z1, t)
    }
    buildFunctionCall(e, t) {
        let n = r => {
            let i = t.arguments[r];
            return A(i, "Missing argument"),
            this.buildExpression(e, i)
        }
        ;
        switch (t.functionName) {
        case "CONTAINS":
            {
                let r = n(0)
                  , i = n(1);
                return this.normalizer.newScalarContains(r, i)
            }
        case "STARTS_WITH":
            {
                let r = n(0)
                  , i = n(1);
                return this.normalizer.newScalarStartsWith(r, i)
            }
        case "ENDS_WITH":
            {
                let r = n(0)
                  , i = n(1);
                return this.normalizer.newScalarEndsWith(r, i)
            }
        case "LENGTH":
            {
                let r = n(0);
                return this.normalizer.newScalarLength(r)
            }
        case "INDEX_OF":
            {
                let r = n(0)
                  , i = n(1);
                return this.normalizer.newScalarIndexOf(r, i)
            }
        case "ARRAY":
            {
                let r = t.arguments[0];
                return A(r, "Missing argument"),
                A(r.type === "Select", "Subqueries require a select expression"),
                this.buildSubqueryArray(e, r)
            }
        case "FLAT_ARRAY":
            {
                let r = t.arguments[0];
                return A(r, "Missing argument"),
                A(r.type === "Select", "Subqueries require a select expression"),
                this.buildSubqueryFlatArray(e, r)
            }
        default:
            throw new Error("Unsupported function name")
        }
    }
    buildSubqueryArray(e, t) {
        try {
            let n = new B1(e);
            this.subqueries.push(n);
            let r = this.buildSelect(e, t)
              , i = r.takeNode()
              , o = r.getNamedFields()
              , s = r.getRequiredOrdering()
              , a = n.referencedFields
              , l = n.referencedOuterFields;
            return this.normalizer.newScalarArray(i, o, s, a, l)
        } finally {
            this.subqueries.pop()
        }
    }
    buildSubqueryFlatArray(e, t) {
        try {
            let n = new B1(e);
            this.subqueries.push(n);
            let r = this.buildSelect(e, t)
              , i = r.takeNode()
              , o = r.getSingleField()
              , s = r.getRequiredOrdering()
              , a = n.referencedFields
              , l = n.referencedOuterFields;
            return this.normalizer.newScalarFlatArray(i, o, s, a, l)
        } finally {
            this.subqueries.pop()
        }
    }
    buildCase(e, t) {
        let n;
        t.value && (n = this.buildExpression(e, t.value));
        let r = t.conditions.map(o => {
            let s = this.buildExpression(e, o.when)
              , a = this.buildExpression(e, o.then);
            return new fg(s,a)
        }
        ), i;
        return t.else && (i = this.buildExpression(e, t.else)),
        this.normalizer.newScalarCase(n, r, i)
    }
    buildUnaryOperation(e, t) {
        let n = this.buildExpression(e, t.value);
        switch (t.operator) {
        case "not":
            return this.normalizer.newScalarNot(n);
        default:
            ke(t.operator, "Unsupported unary operator")
        }
    }
    buildBinaryOperation(e, t) {
        let n = this.buildExpression(e, t.left)
          , r = this.buildExpression(e, t.right);
        switch (t.operator) {
        case "and":
            return this.normalizer.newScalarAnd(n, r);
        case "or":
            return this.normalizer.newScalarOr(n, r);
        case "==":
            return this.normalizer.newScalarEquals(n, r);
        case "!=":
            return this.normalizer.newScalarNotEquals(n, r);
        case "<":
            return this.normalizer.newScalarLessThan(n, r);
        case "<=":
            return this.normalizer.newScalarLessThanOrEqual(n, r);
        case ">":
            return this.normalizer.newScalarGreaterThan(n, r);
        case ">=":
            return this.normalizer.newScalarGreaterThanOrEqual(n, r);
        case "in":
            return this.normalizer.newScalarIn(n, r);
        default:
            ke(t.operator, "Unsupported binary operator")
        }
    }
    buildTypeCast(e, t) {
        let n = this.buildExpression(e, t.value);
        switch (t.dataType) {
        case "BOOLEAN":
            {
                let r = {
                    type: "boolean",
                    isNullable: !0
                };
                return this.normalizer.newScalarCast(n, r)
            }
        case "DATE":
            {
                let r = {
                    type: "date",
                    isNullable: !0
                };
                return this.normalizer.newScalarCast(n, r)
            }
        case "NUMBER":
            {
                let r = {
                    type: "number",
                    isNullable: !0
                };
                return this.normalizer.newScalarCast(n, r)
            }
        case "STRING":
            {
                let r = {
                    type: "string",
                    isNullable: !0
                };
                return this.normalizer.newScalarCast(n, r)
            }
        default:
            throw new Error("Unsupported data type")
        }
    }
}
;
function d4(e, t) {
    if (q5(e))
        return new Y5(e,t);
    if (NC(e))
        return e;
    if (X5(e)) {
        for (; t; ) {
            let n = e.collectionByLocaleId[t.id];
            if (n)
                return n;
            t = t.fallback
        }
        return e.collectionByLocaleId.default
    }
    ke(e, "Unsupported collection type")
}
var B1 = class {
    constructor(e) {
        this.inScope = e,
        R(this, "referencedFields", new W),
        R(this, "referencedOuterFields", new W)
    }
}
  , Tu = class extends _n {
    constructor(e, t) {
        super(e.isSynchronous && t.isSynchronous),
        this.input = e,
        this.predicate = t,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("RelationalFilter", this.inputGroup.id, this.predicate)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering() {
        return !0
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new W(e.resolvedFields);
        return t.merge(this.predicate.referencedFields),
        new fn(e.ordering,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n)
          , i = this.predicate.optimize(e);
        return new oe(0).add(oe.max(r, i))
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t)
          , r = this.predicate.getOptimized();
        return new Tu(n,r)
    }
    *evaluate(e) {
        let t = yield*this.input.evaluate(e)
          , n = yield*Cu(t.tuples.map(r => this.predicate.evaluate(e, r)));
        return t.filter( (r, i) => {
            let o = n[i] ?? null;
            return Ar(o)
        }
        )
    }
}
  , Rn = class extends _n {
    constructor(e, t) {
        super(!1),
        this.index = e,
        this.query = t
    }
    getHash() {
        return le("RelationalIndexLookup", this.index.id, ...this.query)
    }
    getOutputFields() {
        return this.index.collection.fields
    }
    canProvideOrdering(e) {
        return e.equals(this.index.ordering)
    }
    canProvideResolvedFields(e) {
        return e.subsetOf(this.index.resolvedFields)
    }
    optimize() {
        let e = this.query.every(t => t.type === "All");
        return oe.estimate(1, e ? 100 * ku : 50 * ku)
    }
    getOptimized() {
        return new Rn(this.index,this.query)
    }
    *evaluate() {
        let e = this.index
          , t = e.collection
          , n = this.getOutputFields()
          , i = (yield e.data.lookupItems(this.query)).map(o => {
            let s = new fr;
            for (let a of e.resolvedFields) {
                let l = a.getValue(o);
                s.addPointer(t, o.pointer),
                s.addValue(a, l)
            }
            return s
        }
        );
        return new Fn(n,i)
    }
}
  , JC = class extends _n {
    constructor(e, t) {
        super(e.isSynchronous && t.isSynchronous),
        this.left = e,
        this.right = t,
        R(this, "leftGroup", this.left.getGroup()),
        R(this, "rightGroup", this.right.getGroup())
    }
    getHash() {
        return le("RelationalIntersection", this.leftGroup.id, this.rightGroup.id)
    }
    getOutputFields() {
        let e = new W
          , t = this.leftGroup.relational.outputFields
          , n = this.rightGroup.relational.outputFields;
        for (let r of t)
            n.has(r) && e.add(r);
        return e
    }
    canProvideOrdering() {
        return !1
    }
    canProvideResolvedFields() {
        return !0
    }
    getChildRequiredProps(e) {
        let t = new lr;
        return new fn(t,e.resolvedFields)
    }
    optimize(e, t) {
        let n = this.getChildRequiredProps(t)
          , r = e.optimizeGroup(this.leftGroup, n)
          , i = this.getChildRequiredProps(t)
          , o = e.optimizeGroup(this.rightGroup, i);
        return oe.max(r, o)
    }
    getOptimized(e) {
        let t = this.getChildRequiredProps(e)
          , n = this.leftGroup.getOptimized(t)
          , r = this.getChildRequiredProps(e)
          , i = this.rightGroup.getOptimized(r);
        return new JC(n,i)
    }
    *evaluate(e) {
        let {left: t, right: n} = yield*We({
            left: this.left.evaluate(e),
            right: this.right.evaluate(e)
        });
        return t.intersection(n)
    }
}
  , es = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarEquals", this.left, this.right)
    }
    toString() {
        return `${this.left} == ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new es(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.equal(n, r, rs)
        }
    }
}
  , Ru = class extends _n {
    constructor(e, t, n) {
        super(e.isSynchronous && t.isSynchronous && n.isSynchronous),
        this.left = e,
        this.right = t,
        this.constraint = n,
        R(this, "leftGroup", this.left.getGroup()),
        R(this, "rightGroup", this.right.getGroup())
    }
    getHash() {
        return le("RelationalLeftJoin", this.leftGroup.id, this.rightGroup.id, this.constraint)
    }
    getOutputFields() {
        let e = new W;
        return e.merge(this.leftGroup.relational.outputFields),
        e.merge(this.rightGroup.relational.outputFields),
        e
    }
    canProvideOrdering() {
        return !1
    }
    canProvideResolvedFields() {
        return !0
    }
    getChildRequiredProps(e, t) {
        let n = new W
          , r = e.relational.outputFields;
        for (let o of t.resolvedFields)
            r.has(o) && n.add(o);
        for (let o of this.constraint.referencedFields)
            r.has(o) && n.add(o);
        let i = new lr;
        return new fn(i,n)
    }
    optimize(e, t) {
        let n = this.getChildRequiredProps(this.leftGroup, t)
          , r = e.optimizeGroup(this.leftGroup, n)
          , i = this.getChildRequiredProps(this.rightGroup, t)
          , o = e.optimizeGroup(this.rightGroup, i)
          , s = this.constraint.optimize(e);
        return oe.max(oe.max(r, o), s)
    }
    getOptimized(e) {
        let t = this.getChildRequiredProps(this.leftGroup, e)
          , n = this.leftGroup.getOptimized(t)
          , r = this.getChildRequiredProps(this.rightGroup, e)
          , i = this.rightGroup.getOptimized(r)
          , o = this.constraint.getOptimized();
        return new Ru(n,i,o)
    }
    *evaluateScalarEquals(e, t, n, r, i) {
        let o = new Map;
        for (let l of t.tuples) {
            let c = yield*r.evaluate(i, l)
              , u = JSON.stringify(c?.value ?? null)
              , f = o.get(u) ?? [];
            f.push(l),
            o.set(u, f)
        }
        let s = this.getOutputFields()
          , a = new Fn(s);
        for (let l of e.tuples) {
            let c = yield*n.evaluate(i, l)
              , u = JSON.stringify(c?.value ?? null)
              , f = o.get(u) ?? [];
            if (f.length === 0)
                a.push(l);
            else
                for (let d of f) {
                    let p = new fr;
                    p.merge(l),
                    p.merge(d),
                    a.push(p)
                }
        }
        return a
    }
    *evaluate(e) {
        let {left: t, right: n} = yield*We({
            left: this.left.evaluate(e),
            right: this.right.evaluate(e)
        });
        if (this.constraint instanceof es) {
            if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                return yield*this.evaluateScalarEquals(t, n, this.constraint.left, this.constraint.right, e);
            if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                return yield*this.evaluateScalarEquals(t, n, this.constraint.right, this.constraint.left, e)
        }
        let r = this.getOutputFields()
          , i = new Fn(r);
        for (let o of t.tuples) {
            let s = !1;
            for (let a of n.tuples) {
                let l = new fr;
                l.merge(o),
                l.merge(a);
                let c = yield*this.constraint.evaluate(e, l);
                Ar(c) && (i.push(l),
                s = !0)
            }
            s || i.push(o)
        }
        return i
    }
}
  , dg = class extends _n {
    constructor(e, t, n) {
        super(e.isSynchronous && t.isSynchronous && n.isSynchronous),
        this.left = e,
        this.right = t,
        this.constraint = n,
        R(this, "leftGroup", this.left.getGroup()),
        R(this, "rightGroup", this.right.getGroup())
    }
    getHash() {
        return le("RelationalRightJoin", this.leftGroup.id, this.rightGroup.id, this.constraint)
    }
    getOutputFields() {
        let e = new W;
        return e.merge(this.leftGroup.relational.outputFields),
        e.merge(this.rightGroup.relational.outputFields),
        e
    }
    canProvideOrdering() {
        return !1
    }
    canProvideResolvedFields() {
        return !0
    }
    getChildRequiredProps(e, t) {
        let n = new W
          , r = e.relational.outputFields;
        for (let o of t.resolvedFields)
            r.has(o) && n.add(o);
        for (let o of this.constraint.referencedFields)
            r.has(o) && n.add(o);
        let i = new lr;
        return new fn(i,n)
    }
    optimize(e, t) {
        let n = this.getChildRequiredProps(this.leftGroup, t)
          , r = e.optimizeGroup(this.leftGroup, n)
          , i = this.getChildRequiredProps(this.rightGroup, t)
          , o = e.optimizeGroup(this.rightGroup, i)
          , s = this.constraint.optimize(e);
        return oe.max(oe.max(r, o), s)
    }
    getOptimized(e) {
        let t = this.getChildRequiredProps(this.leftGroup, e)
          , n = this.leftGroup.getOptimized(t)
          , r = this.getChildRequiredProps(this.rightGroup, e)
          , i = this.rightGroup.getOptimized(r)
          , o = this.constraint.getOptimized();
        return new dg(n,i,o)
    }
    *evaluateScalarEquals(e, t, n, r, i) {
        let o = new Map;
        for (let l of e.tuples) {
            let c = yield*n.evaluate(i, l)
              , u = JSON.stringify(c?.value ?? null)
              , f = o.get(u) ?? [];
            f.push(l),
            o.set(u, f)
        }
        let s = this.getOutputFields()
          , a = new Fn(s);
        for (let l of t.tuples) {
            let c = yield*r.evaluate(i, l)
              , u = JSON.stringify(c?.value ?? null)
              , f = o.get(u) ?? [];
            if (f.length === 0)
                a.push(l);
            else
                for (let d of f) {
                    let p = new fr;
                    p.merge(l),
                    p.merge(d),
                    a.push(p)
                }
        }
        return a
    }
    *evaluate(e) {
        let {left: t, right: n} = yield*We({
            left: this.left.evaluate(e),
            right: this.right.evaluate(e)
        });
        if (this.constraint instanceof es) {
            if (this.constraint.left.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.right.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                return yield*this.evaluateScalarEquals(t, n, this.constraint.left, this.constraint.right, e);
            if (this.constraint.right.referencedFields.subsetOf(this.leftGroup.relational.outputFields) && this.constraint.left.referencedFields.subsetOf(this.rightGroup.relational.outputFields))
                return yield*this.evaluateScalarEquals(t, n, this.constraint.right, this.constraint.left, e)
        }
        let r = this.getOutputFields()
          , i = new Fn(r);
        for (let o of n.tuples) {
            let s = !1;
            for (let a of t.tuples) {
                let l = new fr;
                l.merge(o),
                l.merge(a);
                let c = yield*this.constraint.evaluate(e, l);
                Ar(c) && (i.push(l),
                s = !0)
            }
            s || i.push(o)
        }
        return i
    }
}
  , Eu = class extends _n {
    constructor(e) {
        super(!1),
        this.collection = e
    }
    getHash() {
        return le("RelationalScan", this.collection.id)
    }
    getOutputFields() {
        return this.collection.fields
    }
    canProvideOrdering() {
        return !1
    }
    canProvideResolvedFields(e) {
        return e.subsetOf(this.collection.fields)
    }
    optimize() {
        return oe.estimate(1, 200 * ku)
    }
    getOptimized() {
        return new Eu(this.collection)
    }
    *evaluate() {
        let e = this.collection
          , t = this.getOutputFields()
          , r = (yield e.data.scanItems()).map(i => {
            let o = new fr;
            for (let s of t) {
                let a = s.getValue(i);
                o.addPointer(e, i.pointer),
                o.addValue(s, a)
            }
            return o
        }
        );
        return new Fn(t,r)
    }
}
  , eT = class extends _n {
    constructor(e, t) {
        super(e.isSynchronous && t.isSynchronous),
        this.left = e,
        this.right = t,
        R(this, "leftGroup", this.left.getGroup()),
        R(this, "rightGroup", this.right.getGroup())
    }
    getHash() {
        return le("RelationalUnion", this.leftGroup.id, this.rightGroup.id)
    }
    getOutputFields() {
        let e = new W
          , t = this.leftGroup.relational.outputFields
          , n = this.rightGroup.relational.outputFields;
        for (let r of t)
            n.has(r) && e.add(r);
        return e
    }
    canProvideOrdering() {
        return !1
    }
    canProvideResolvedFields() {
        return !0
    }
    getChildRequiredProps(e) {
        let t = new lr;
        return new fn(t,e.resolvedFields)
    }
    optimize(e, t) {
        let n = this.getChildRequiredProps(t)
          , r = e.optimizeGroup(this.leftGroup, n)
          , i = this.getChildRequiredProps(t)
          , o = e.optimizeGroup(this.rightGroup, i);
        return oe.max(r, o)
    }
    getOptimized(e) {
        let t = this.getChildRequiredProps(e)
          , n = this.leftGroup.getOptimized(t)
          , r = this.getChildRequiredProps(e)
          , i = this.rightGroup.getOptimized(r);
        return new eT(n,i)
    }
    *evaluate(e) {
        let {left: t, right: n} = yield*We({
            left: this.left.evaluate(e),
            right: this.right.evaluate(e)
        });
        return t.union(n)
    }
}
  , Fu = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarAnd", this.left, this.right)
    }
    toString() {
        return `${this.left} && ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Fu(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: Ar(n) && Ar(r)
        }
    }
}
  , $n = class extends Xe {
    constructor(e, t) {
        let n = new W
          , r = new W;
        super(n, r, !0),
        this.definition = e,
        this.value = t
    }
    getHash() {
        return le("ScalarConstant", this.definition, this.value)
    }
    toString() {
        return _e.stringify(this.value)
    }
    optimize() {
        return new oe(0)
    }
    getOptimized() {
        return this
    }
    *evaluate() {
        return this.value
    }
}
  , h4 = {
    type: 0
}
  , hg = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.source = e,
        this.target = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarContains", this.source, this.target)
    }
    toString() {
        return `CONTAINS(${this.source}, ${this.target})`
    }
    optimize(e) {
        let t = this.source.optimize(e)
          , n = this.target.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.source.getOptimized()
          , t = this.target.getOptimized();
        return new hg(e,t)
    }
    *evaluate(e, t) {
        let {source: n, target: r} = yield*We({
            source: this.source.evaluate(e, t),
            target: this.target.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.contains(n, r, h4)
        }
    }
}
  , p4 = {
    type: 0
}
  , pg = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.source = e,
        this.target = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarEndsWith", this.source, this.target)
    }
    toString() {
        return `ENDS_WITH(${this.source}, ${this.target})`
    }
    optimize(e) {
        let t = this.source.optimize(e)
          , n = this.target.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.source.getOptimized()
          , t = this.target.getOptimized();
        return new pg(e,t)
    }
    *evaluate(e, t) {
        let {source: n, target: r} = yield*We({
            source: this.source.evaluate(e, t),
            target: this.target.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.endsWith(n, r, p4)
        }
    }
}
  , Pu = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarGreaterThan", this.left, this.right)
    }
    toString() {
        return `${this.left} > ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Pu(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.greaterThan(n, r, rs)
        }
    }
}
  , _u = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarGreaterThanOrEqual", this.left, this.right)
    }
    toString() {
        return `${this.left} >= ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new _u(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.greaterThanOrEqual(n, r, rs)
        }
    }
}
  , Iu = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarLessThan", this.left, this.right)
    }
    toString() {
        return `${this.left} < ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Iu(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.lessThan(n, r, rs)
        }
    }
}
  , Ou = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarLessThanOrEqual", this.left, this.right)
    }
    toString() {
        return `${this.left} <= ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Ou(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.lessThanOrEqual(n, r, rs)
        }
    }
}
  , Mu = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarNotEquals", this.left, this.right)
    }
    toString() {
        return `${this.left} != ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Mu(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: !_e.equal(n, r, rs)
        }
    }
}
  , Lu = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarOr", this.left, this.right)
    }
    toString() {
        return `${this.left} || ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new Lu(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: Ar(n) || Ar(r)
        }
    }
}
  , m4 = {
    type: 0
}
  , mg = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.source = e,
        this.target = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarStartsWith", this.source, this.target)
    }
    toString() {
        return `STARTS_WITH(${this.source}, ${this.target})`
    }
    optimize(e) {
        let t = this.source.optimize(e)
          , n = this.target.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.source.getOptimized()
          , t = this.target.getOptimized();
        return new mg(e,t)
    }
    *evaluate(e, t) {
        let {source: n, target: r} = yield*We({
            source: this.source.evaluate(e, t),
            target: this.target.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.startsWith(n, r, m4)
        }
    }
}
  , g4 = class {
    constructor(e) {
        this.normalizer = e,
        R(this, "memo", this.normalizer.memo)
    }
    explore(e) {
        let t = e.getGroup();
        if (e instanceof Ru) {
            let n = new dg(e.right,e.left,e.constraint);
            this.memo.addRelational(n, t)
        }
        if (e instanceof Tu) {
            if (e.predicate instanceof Fu) {
                let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left)
                  , r = this.normalizer.newRelationalFilter(e.input, e.predicate.right)
                  , i = new JC(n,r);
                this.memo.addRelational(i, t)
            }
            if (e.predicate instanceof Lu) {
                let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left)
                  , r = this.normalizer.newRelationalFilter(e.input, e.predicate.right)
                  , i = new eT(n,r);
                this.memo.addRelational(i, t)
            }
        }
        if (e instanceof Eu)
            for (let n of e.collection.indexes) {
                if (n.constraint)
                    continue;
                let r = sr(n.lookupNodes.length)
                  , i = new Rn(n,r);
                this.memo.addRelational(i, t)
            }
        if (e instanceof Tu) {
            for (let n of e.inputGroup.nodes)
                if (n instanceof Eu)
                    for (let r of n.collection.indexes) {
                        if (e.predicate instanceof es && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("Equals")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "Equals",
                                value: e.predicate.right.value
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof Mu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("NotEquals")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "NotEquals",
                                value: e.predicate.right.value
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof Iu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("LessThan")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "LessThan",
                                value: e.predicate.right.value,
                                inclusive: !1
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof Ou && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("LessThan")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "LessThan",
                                value: e.predicate.right.value,
                                inclusive: !0
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof Pu && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("GreaterThan")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "GreaterThan",
                                value: e.predicate.right.value,
                                inclusive: !1
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof _u && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof $n && r.data.supportedLookupTypes.includes("GreaterThan")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "GreaterThan",
                                value: e.predicate.right.value,
                                inclusive: !0
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof hg && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof $n && r.data.supportedLookupTypes.includes("Contains")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "Contains",
                                value: e.predicate.target.value
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof mg && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof $n && r.data.supportedLookupTypes.includes("StartsWith")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "StartsWith",
                                value: e.predicate.target.value
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                        if (e.predicate instanceof pg && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof $n && r.data.supportedLookupTypes.includes("EndsWith")) {
                            let i = sr(r.lookupNodes.length);
                            i[0] = {
                                type: "EndsWith",
                                value: e.predicate.target.value
                            };
                            let o = new Rn(r,i);
                            this.memo.addRelational(o, t)
                        }
                    }
        }
    }
}
;
function sr(e) {
    let t = {
        type: "All"
    };
    return new Array(e).fill(t)
}
var v4 = class {
    constructor(e) {
        this.outputFields = e
    }
    isCompatible(e) {
        return this.outputFields.equals(e.outputFields)
    }
}
  , y4 = class {
    constructor() {
        R(this, "nodes", new Map),
        R(this, "groups", [])
    }
    addGroup(e) {
        let t = this.groups.length
          , n = new GC(t,e);
        return this.groups.push(n),
        n
    }
    addRelational(e, t) {
        let n = e.getHash()
          , r = this.nodes.get(n);
        if (r)
            return r;
        this.nodes.set(n, e);
        let i = e.getOutputFields()
          , o = new v4(i);
        return t ?? (t = this.addGroup(o)),
        t.addNode(e),
        A(o.isCompatible(t.relational), "Group has inconsistent relational props"),
        e
    }
    addScalar(e) {
        let t = e.getHash()
          , n = this.nodes.get(t);
        return n || (this.nodes.set(t, e),
        e)
    }
}
  , tT = class extends _n {
}
  , nT = class extends tT {
    constructor(e, t) {
        super(!1),
        this.input = e,
        this.fields = t,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("EnforcerResolve", this.inputGroup.id, this.fields)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering() {
        return !0
    }
    canProvideResolvedFields(e) {
        return e.subsetOf(this.fields)
    }
    getInputRequiredProps(e) {
        let t = new W;
        return new fn(e.ordering,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n);
        return oe.estimate(0, 100 * ku).add(r)
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t);
        return new nT(n,this.fields)
    }
    *evaluate(e) {
        let t = yield*this.input.evaluate(e);
        A(this.fields.subsetOf(t.fields), "Fields can't be resolved");
        let n = new Set;
        for (let i of this.fields)
            A(i.collection, "Collection required to resolve field"),
            n.add(i.collection);
        for (let i of t.tuples)
            for (let o of this.fields) {
                let s = i.getValue(o);
                s?.type === "richtext" && (A(s.value instanceof ug, "Pointer must be wrapped"),
                s.value.resolve())
            }
        let r = yield Promise.all(Array.from(n).map(async i => {
            let o = [];
            for (let a of t.tuples) {
                let l = a.getPointer(i);
                l && o.push(l)
            }
            let s = await i.data.resolveItems(o);
            return A(s.length === o.length, "Invalid number of items"),
            [i, s]
        }
        ));
        return t.map(t.fields, i => {
            let o = new fr;
            o.merge(i);
            for (let[s,a] of r) {
                let l = i.getPointer(s);
                if (!l)
                    continue;
                let c = a.shift();
                A(c, "Item not found"),
                A(c.pointer === l, "Pointer mismatch");
                for (let u of s.fields) {
                    let f = u.getValue(c);
                    o.addValue(u, f)
                }
            }
            return o
        }
        )
    }
}
  , pm = {
    type: 0
}
  , rT = class extends tT {
    constructor(e, t) {
        super(e.isSynchronous),
        this.input = e,
        this.ordering = t,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("EnforcerSort", this.inputGroup.id, this.ordering)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering(e) {
        return e.equals(this.ordering)
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new W(e.resolvedFields);
        for (let {field: r} of this.ordering.fields)
            r.name !== Jo && (et(r.collection) || t.add(r));
        let n = new lr;
        return new fn(n,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n);
        return new oe(0).add(r)
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t);
        return new rT(n,this.ordering)
    }
    *evaluate(e) {
        return (yield*this.input.evaluate(e)).sort( (n, r) => {
            for (let {field: i, direction: o} of this.ordering.fields) {
                let s = o === "asc";
                if (i.name === Jo) {
                    let c = i.collection;
                    A(c, "Collection required for sorting");
                    let u = n.getPointer(c);
                    A(u, "Pointer required for sorting");
                    let f = {
                        pointer: u,
                        data: {}
                    }
                      , d = r.getPointer(c);
                    A(d, "Pointer required for sorting");
                    let p = {
                        pointer: d,
                        data: {}
                    }
                      , v = c.data.compareItems(f, p);
                    return s ? v : -v
                }
                let a = n.getValue(i)
                  , l = r.getValue(i);
                if (!_e.equal(a, l, pm)) {
                    if (ar(a) || _e.lessThan(a, l, pm))
                        return s ? -1 : 1;
                    if (ar(l) || _e.greaterThan(a, l, pm))
                        return s ? 1 : -1;
                    throw new Error("Invalid comparison")
                }
            }
            return 0
        }
        )
    }
}
;
var iT = class extends _n {
    constructor(e, t, n) {
        super(e.isSynchronous && t.isSynchronous),
        this.input = e,
        this.limit = t,
        this.ordering = n,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("RelationalLimit", this.inputGroup.id, this.limit)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering(e) {
        return e.equals(this.ordering)
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new W(e.resolvedFields);
        return t.merge(this.limit.referencedFields),
        new fn(this.ordering,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n)
          , i = this.limit.optimize(e);
        return new oe(0).add(oe.max(r, i))
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t)
          , r = this.limit.getOptimized();
        return new iT(n,r,this.ordering)
    }
    *evaluate(e) {
        let {input: t, limit: n} = yield*We({
            input: this.input.evaluate(e),
            limit: this.limit.evaluate(e, void 0)
        })
          , r = WC(n) ?? 1 / 0;
        return r === 1 / 0 ? t : t.slice(0, r)
    }
}
  , oT = class extends _n {
    constructor(e, t, n) {
        super(e.isSynchronous && t.isSynchronous),
        this.input = e,
        this.offset = t,
        this.ordering = n,
        R(this, "inputGroup", this.input.getGroup())
    }
    getHash() {
        return le("RelationalOffset", this.inputGroup.id, this.offset)
    }
    getOutputFields() {
        return this.inputGroup.relational.outputFields
    }
    canProvideOrdering(e) {
        return e.equals(this.ordering)
    }
    canProvideResolvedFields() {
        return !0
    }
    getInputRequiredProps(e) {
        let t = new W(e.resolvedFields);
        return t.merge(this.offset.referencedFields),
        new fn(this.ordering,t)
    }
    optimize(e, t) {
        let n = this.getInputRequiredProps(t)
          , r = e.optimizeGroup(this.inputGroup, n)
          , i = this.offset.optimize(e);
        return new oe(0).add(oe.max(r, i))
    }
    getOptimized(e) {
        let t = this.getInputRequiredProps(e)
          , n = this.inputGroup.getOptimized(t)
          , r = this.offset.getOptimized();
        return new oT(n,r,this.ordering)
    }
    *evaluate(e) {
        let {input: t, offset: n} = yield*We({
            input: this.input.evaluate(e),
            offset: this.offset.evaluate(e, void 0)
        })
          , r = WC(n) ?? 0;
        return r === 0 ? t : t.slice(r)
    }
}
  , sT = class extends Xe {
    constructor(e, t, n, r, i) {
        super(r, i, e.isSynchronous),
        this.input = e,
        this.namedFields = t,
        this.ordering = n,
        this.referencedFields = r,
        this.referencedOuterFields = i,
        R(this, "inputGroup", this.input.getGroup()),
        R(this, "definition");
        let o = {}
          , s = Object.entries(t);
        for (let[a,l] of s)
            o[a] = l.definition;
        this.definition = {
            type: "array",
            isNullable: !1,
            definition: {
                type: "object",
                isNullable: !1,
                definitions: o
            }
        }
    }
    getHash() {
        let e = {}
          , t = Object.entries(this.namedFields);
        for (let[n,r] of t)
            e[n] = r.id;
        return le("ScalarArray", this.inputGroup.id, e, this.ordering, this.referencedFields, this.referencedOuterFields)
    }
    toString() {
        return `ARRAY(${this.inputGroup.id})`
    }
    getInputRequiredProps() {
        let e = new W
          , t = Object.values(this.namedFields);
        for (let n of t)
            et(n.collection) || e.add(n);
        return new fn(this.ordering,e)
    }
    optimize(e) {
        let t = this.getInputRequiredProps()
          , n = e.optimizeGroup(this.inputGroup, t);
        return new oe(0).add(n)
    }
    getOptimized() {
        let e = this.getInputRequiredProps()
          , t = this.inputGroup.getOptimized(e);
        return new sT(t,this.namedFields,this.ordering,this.referencedFields,this.referencedOuterFields)
    }
    *evaluate(e, t) {
        let n = new fr;
        e && n.merge(e),
        t && n.merge(t);
        let r = yield*this.input.evaluate(n)
          , i = Object.entries(this.namedFields);
        return {
            type: "array",
            value: r.tuples.map(o => {
                let s = {};
                for (let[a,l] of i)
                    s[a] = o.getValue(l);
                return {
                    type: "object",
                    value: s
                }
            }
            )
        }
    }
}
  , aT = class extends Xe {
    constructor(e, t) {
        super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
        this.input = e,
        this.definition = t,
        A(t.isNullable, "Unsupported non-nullable cast")
    }
    getHash() {
        return le("ScalarCast", this.input, this.definition)
    }
    toString() {
        return `CAST(${this.input} AS ${this.definition.type.toUpperCase()})`
    }
    optimize(e) {
        return this.input.optimize(e)
    }
    getOptimized() {
        let e = this.input.getOptimized();
        return new aT(e,this.definition)
    }
    *evaluate(e, t) {
        let n = yield*this.input.evaluate(e, t);
        return _e.cast(n, this.definition)
    }
}
  , lT = class extends Xe {
    constructor(e, t, n, r, i) {
        super(r, i, e.isSynchronous),
        this.input = e,
        this.field = t,
        this.ordering = n,
        this.referencedFields = r,
        this.referencedOuterFields = i,
        R(this, "inputGroup", this.input.getGroup()),
        R(this, "definition"),
        this.definition = {
            type: "array",
            isNullable: !1,
            definition: this.field.definition
        }
    }
    getHash() {
        return le("ScalarFlatArray", this.inputGroup.id, this.field.id, this.ordering, this.referencedFields, this.referencedOuterFields)
    }
    toString() {
        return `FLAT_ARRAY(${this.inputGroup.id})`
    }
    getInputRequiredProps() {
        let e = new W;
        return et(this.field.collection) || e.add(this.field),
        new fn(this.ordering,e)
    }
    optimize(e) {
        let t = this.getInputRequiredProps()
          , n = e.optimizeGroup(this.inputGroup, t);
        return new oe(0).add(n)
    }
    getOptimized() {
        let e = this.getInputRequiredProps()
          , t = this.inputGroup.getOptimized(e);
        return new lT(t,this.field,this.ordering,this.referencedFields,this.referencedOuterFields)
    }
    *evaluate(e, t) {
        let n = new fr;
        return e && n.merge(e),
        t && n.merge(t),
        {
            type: "array",
            value: (yield*this.input.evaluate(n)).tuples.map(i => i.getValue(this.field))
        }
    }
}
  , b4 = {
    type: 0
}
  , cT = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarIn", this.left, this.right)
    }
    toString() {
        return `${this.left} IN ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new cT(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: _e.in(n, r, b4)
        }
    }
}
  , x4 = {
    type: 1
}
  , uT = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.source = e,
        this.target = t,
        R(this, "definition", {
            type: "number",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarIndexOf", this.source, this.target)
    }
    toString() {
        return `INDEX_OF(${this.source}, ${this.target})`
    }
    optimize(e) {
        let t = this.source.optimize(e)
          , n = this.target.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.source.getOptimized()
          , t = this.target.getOptimized();
        return new uT(e,t)
    }
    *evaluate(e, t) {
        let {source: n, target: r} = yield*We({
            source: this.source.evaluate(e, t),
            target: this.target.evaluate(e, t)
        });
        return {
            type: "number",
            value: _e.indexOf(n, r, x4)
        }
    }
}
  , fT = class extends Xe {
    constructor(e) {
        super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
        this.input = e,
        R(this, "definition", {
            type: "number",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarLength", this.input)
    }
    toString() {
        return `LENGTH(${this.input})`
    }
    optimize(e) {
        return this.input.optimize(e)
    }
    getOptimized() {
        let e = this.input.getOptimized();
        return new fT(e)
    }
    *evaluate(e, t) {
        let n = yield*this.input.evaluate(e, t);
        return {
            type: "number",
            value: _e.length(n)
        }
    }
}
  , Lm = class extends Xe {
    constructor(e) {
        super(e.referencedFields, e.referencedOuterFields, e.isSynchronous),
        this.input = e,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarNot", this.input)
    }
    toString() {
        return `NOT ${this.input}`
    }
    optimize(e) {
        return this.input.optimize(e)
    }
    getOptimized() {
        let e = this.input.getOptimized();
        return new Lm(e)
    }
    *evaluate(e, t) {
        let n = yield*this.input.evaluate(e, t);
        return {
            type: "boolean",
            value: !Ar(n)
        }
    }
}
  , w4 = {
    type: 0
}
  , dT = class extends Xe {
    constructor(e, t) {
        let n = new W;
        n.merge(e.referencedFields),
        n.merge(t.referencedFields);
        let r = new W;
        r.merge(e.referencedOuterFields),
        r.merge(t.referencedOuterFields);
        let i = e.isSynchronous && t.isSynchronous;
        super(n, r, i),
        this.left = e,
        this.right = t,
        R(this, "definition", {
            type: "boolean",
            isNullable: !1
        })
    }
    getHash() {
        return le("ScalarNotIn", this.left, this.right)
    }
    toString() {
        return `${this.left} NOT IN ${this.right}`
    }
    optimize(e) {
        let t = this.left.optimize(e)
          , n = this.right.optimize(e);
        return oe.max(t, n)
    }
    getOptimized() {
        let e = this.left.getOptimized()
          , t = this.right.getOptimized();
        return new dT(e,t)
    }
    *evaluate(e, t) {
        let {left: n, right: r} = yield*We({
            left: this.left.evaluate(e, t),
            right: this.right.evaluate(e, t)
        });
        return {
            type: "boolean",
            value: !_e.in(n, r, w4)
        }
    }
}
  , ln = class extends Xe {
    constructor(e, t) {
        A(e.name !== Jo, "Invalid field name");
        let n = new W
          , r = new W;
        t ? r.add(e) : n.add(e),
        super(n, r, !0),
        this.field = e,
        this.isOuterField = t,
        R(this, "definition", this.field.definition)
    }
    getHash() {
        return le("ScalarVariable", this.field.id, this.isOuterField)
    }
    toString() {
        return `"${this.field.name}" /* ${this.field.id} */`
    }
    optimize() {
        return new oe(0)
    }
    getOptimized() {
        return this
    }
    *evaluate(e, t) {
        return this.isOuterField ? (A(e, "Context must exist"),
        e.getValue(this.field)) : (A(t, "Tuple must exist"),
        t.getValue(this.field))
    }
}
  , S4 = class {
    constructor(e) {
        this.memo = e
    }
    finishRelational(e) {
        return this.memo.addRelational(e)
    }
    newRelationalScan(e) {
        let t = new Eu(e);
        return this.finishRelational(t)
    }
    newRelationalIndexLookup(e, t) {
        let n = new Rn(e,t);
        return this.finishRelational(n)
    }
    newRelationalLeftJoin(e, t, n) {
        let r = new Ru(e,t,n);
        return this.finishRelational(r)
    }
    newRelationalRightJoin(e, t, n) {
        return this.newRelationalLeftJoin(t, e, n)
    }
    newRelationalFilter(e, t) {
        if (e instanceof Ru && t.referencedFields.subsetOf(e.leftGroup.relational.outputFields)) {
            let r = this.newRelationalFilter(e.left, t);
            return this.newRelationalLeftJoin(r, e.right, e.constraint)
        }
        if (e instanceof dg && t.referencedFields.subsetOf(e.rightGroup.relational.outputFields)) {
            let r = this.newRelationalFilter(e.right, t);
            return this.newRelationalLeftJoin(e.left, r, e.constraint)
        }
        let n = new Tu(e,t);
        return this.finishRelational(n)
    }
    newRelationalProject(e, t, n) {
        let r = new Om(e,t,n);
        return this.finishRelational(r)
    }
    newRelationalLimit(e, t, n) {
        if (e instanceof Om && t.referencedFields.subsetOf(e.inputGroup.relational.outputFields) && n.providedByFields(e.inputGroup.relational.outputFields)) {
            let i = this.newRelationalLimit(e.input, t, n);
            return this.newRelationalProject(i, e.projections, e.passthrough)
        }
        let r = new iT(e,t,n);
        return this.finishRelational(r)
    }
    newRelationalOffset(e, t, n) {
        let r = new oT(e,t,n);
        return this.finishRelational(r)
    }
    finishScalar(e) {
        if (!(e instanceof $n) && e.isSynchronous && e.referencedFields.size === 0 && e.referencedOuterFields.size === 0) {
            let n = e.evaluateSync();
            return this.newScalarConstant(e.definition, n)
        }
        return this.memo.addScalar(e)
    }
    removeUnknown(e, t) {
        if (e.definition.type !== "unknown" || t.type === "unknown")
            return e;
        let n = {
            ...t,
            isNullable: !0
        };
        return this.newScalarCast(e, n)
    }
    newScalarVariable(e, t) {
        let n = new ln(e,t);
        return this.finishScalar(n)
    }
    newScalarConstant(e, t) {
        let n = new $n(e,t);
        return this.finishScalar(n)
    }
    newScalarNot(e) {
        if (e instanceof Lm) {
            if (e.input.definition.type === "boolean")
                return e.input;
            let n = {
                type: "boolean",
                isNullable: !0
            };
            return this.newScalarCast(e.input, n)
        }
        if (e instanceof es)
            return this.newScalarNotEquals(e.left, e.right);
        if (e instanceof Mu)
            return this.newScalarEquals(e.left, e.right);
        if (e instanceof Iu)
            return this.newScalarGreaterThanOrEqual(e.left, e.right);
        if (e instanceof Ou)
            return this.newScalarGreaterThan(e.left, e.right);
        if (e instanceof Pu)
            return this.newScalarLessThanOrEqual(e.left, e.right);
        if (e instanceof _u)
            return this.newScalarLessThan(e.left, e.right);
        if (e instanceof Fu) {
            let n = this.newScalarNot(e.left)
              , r = this.newScalarNot(e.right);
            return this.newScalarOr(n, r)
        }
        if (e instanceof Lu) {
            let n = this.newScalarNot(e.left)
              , r = this.newScalarNot(e.right);
            return this.newScalarAnd(n, r)
        }
        let t = new Lm(e);
        return this.finishScalar(t)
    }
    newScalarAnd(e, t) {
        let n = new Fu(e,t);
        return this.finishScalar(n)
    }
    newScalarOr(e, t) {
        let n = new Lu(e,t);
        return this.finishScalar(n)
    }
    newScalarEquals(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarEquals(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new es(e,t);
        return this.finishScalar(i)
    }
    newScalarNotEquals(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarNotEquals(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new Mu(e,t);
        return this.finishScalar(i)
    }
    newScalarLessThan(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarGreaterThan(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new Iu(e,t);
        return this.finishScalar(i)
    }
    newScalarLessThanOrEqual(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarGreaterThanOrEqual(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new Ou(e,t);
        return this.finishScalar(i)
    }
    newScalarGreaterThan(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarLessThan(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new Pu(e,t);
        return this.finishScalar(i)
    }
    newScalarGreaterThanOrEqual(e, t) {
        let n = e instanceof ln;
        if (t instanceof ln && !n)
            return this.newScalarLessThanOrEqual(t, e);
        e = this.removeUnknown(e, t.definition),
        t = this.removeUnknown(t, e.definition);
        let i = new _u(e,t);
        return this.finishScalar(i)
    }
    newScalarIn(e, t) {
        t.definition.type === "array" && (e = this.removeUnknown(e, t.definition.definition));
        let n = {
            type: "array",
            isNullable: !0,
            definition: e.definition
        };
        t = this.removeUnknown(t, n);
        let r = new cT(e,t);
        return this.finishScalar(r)
    }
    newScalarNotIn(e, t) {
        t.definition.type === "array" && (e = this.removeUnknown(e, t.definition.definition));
        let n = {
            type: "array",
            isNullable: !0,
            definition: e.definition
        };
        t = this.removeUnknown(t, n);
        let r = new dT(e,t);
        return this.finishScalar(r)
    }
    newScalarCase(e, t, n) {
        if (e) {
            let i = [];
            for (let {when: o, then: s} of t) {
                let a = this.removeUnknown(o, e.definition)
                  , l = new fg(a,s);
                i.push(l)
            }
            t = i
        }
        let r = new ZC(e,t,n);
        return this.finishScalar(r)
    }
    newScalarContains(e, t) {
        let n = new hg(e,t);
        return this.finishScalar(n)
    }
    newScalarStartsWith(e, t) {
        let n = new mg(e,t);
        return this.finishScalar(n)
    }
    newScalarEndsWith(e, t) {
        let n = new pg(e,t);
        return this.finishScalar(n)
    }
    newScalarLength(e) {
        let t = new fT(e);
        return this.finishScalar(t)
    }
    newScalarIndexOf(e, t) {
        let n = new uT(e,t);
        return this.finishScalar(n)
    }
    newScalarArray(e, t, n, r, i) {
        let o = new sT(e,t,n,r,i);
        return this.finishScalar(o)
    }
    newScalarFlatArray(e, t, n, r, i) {
        let o = new lT(e,t,n,r,i);
        return this.finishScalar(o)
    }
    newScalarCast(e, t) {
        if (e.definition.type === t.type)
            return e;
        let n = new aT(e,t);
        return this.finishScalar(n)
    }
}
  , k4 = class {
    constructor(e, t) {
        this.query = e,
        this.locale = t,
        R(this, "memo", new y4),
        R(this, "normalizer", new S4(this.memo)),
        R(this, "explorer", new g4(this.normalizer))
    }
    optimize() {
        let t = new f4(this.normalizer,this.query,this.locale).build()
          , r = t.takeNode().getGroup()
          , i = t.getRequiredProps();
        this.optimizeGroup(r, i);
        let o = r.getOptimized(i)
          , s = t.getNamedFields();
        return [o, s]
    }
    optimizeGroup(e, t) {
        let n = e.getWinner(t);
        if (n.node)
            return n.cost;
        let r = e.nodes[0];
        A(r, "Normalized node not found"),
        this.createEnforcer(n, r, t);
        for (let i of e.nodes) {
            if (t.canProvide(i)) {
                let o = i.optimize(this, t);
                n.update(i, o)
            }
            t.isMinimal && this.explorer.explore(i)
        }
        return n.cost
    }
    createEnforcer(e, t, n) {
        if (n.resolvedFields.size > 0) {
            let r = new nT(t,n.resolvedFields)
              , i = r.optimize(this, n);
            e.update(r, i)
        }
        if (n.ordering.length > 0) {
            let r = new rT(t,n.ordering)
              , i = r.optimize(this, n);
            e.update(r, i)
        }
    }
}
;
function C4(e) {
    return e.collection ? `"${e.collection}"."${e.name}"` : `"${e.name}"`
}
function T4(e) {
    return typeof e.value == "string" ? `'${e.value}'` : e.value
}
function R4(e) {
    return `${e.functionName}(${e.arguments.map(t => Bt(t)).join(", ")})`
}
function E4(e) {
    let t = "CASE";
    e.value && (t += ` ${Bt(e.value)}`);
    for (let n of e.conditions)
        t += ` WHEN ${Bt(n.when)} THEN ${Bt(n.then)}`;
    return e.else && (t += ` ELSE ${Bt(e.else)}`),
    t += " END",
    t
}
function F4(e) {
    let t = Bt(e.value);
    return `${e.operator.toUpperCase()} ${t}`
}
function P4(e) {
    let t = Bt(e.left)
      , n = Bt(e.right)
      , r = e.operator.toUpperCase();
    return `${t} ${r} ${n}`
}
function _4(e) {
    return `CAST(${Bt(e.value)} as ${e.dataType})`
}
function Bt(e) {
    switch (e.type) {
    case "Identifier":
        return C4(e);
    case "LiteralValue":
        return T4(e);
    case "FunctionCall":
        return R4(e);
    case "Case":
        return E4(e);
    case "UnaryOperation":
        return F4(e);
    case "BinaryOperation":
        return P4(e);
    case "TypeCast":
        return _4(e);
    case "Select":
        return `${hT(e)}`;
    default:
        ke(e)
    }
}
function I4(e) {
    return NC(e.data) ? "Collection" : e.alias ? `"${e.data.displayName}" AS "${e.alias}"` : `"${e.data.displayName}"`
}
function O4(e) {
    let t = `${Vm(e.left)} LEFT JOIN ${Vm(e.right)}`;
    return e.constraint && (t += ` ON ${Bt(e.constraint)}`),
    t
}
function Vm(e) {
    switch (e.type) {
    case "Collection":
        return I4(e);
    case "LeftJoin":
        return O4(e);
    default:
        ke(e)
    }
}
function M4(e) {
    let t = "";
    return e.split(/\s+/u).forEach(r => {
        r !== "" && (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(r) ? t += `
${r}` : ["AND", "OR"].includes(r) ? t += `
	${r}` : t += ` ${r}`)
    }
    ),
    t.trim()
}
function hT(e) {
    let t = "";
    return t += `SELECT ${e.select.map(n => {
        letr = Bt(n);
        return n.alias ? `${r} AS "${n.alias}"` : r
    }
    ).join(", ")}`,
    t += ` FROM ${Vm(e.from)}`,
    e.where && (t += ` WHERE ${Bt(e.where)}`),
    e.orderBy && (t += ` ORDER BY ${e.orderBy.map(n => `${Bt(n)} ${n.direction ?? "asc"}`).join(", ")}`),
    e.limit && (t += ` LIMIT ${Bt(e.limit)}`),
    e.offset && (t += ` OFFSET ${Bt(e.offset)}`),
    M4(t)
}
var L4 = U5("query-engine"), hW = class {
    async query(e, t) {
        L4.debug(`Query:
${hT(e)}`);
        let n = new k4(e,t)
          , [r,i] = n.optimize()
          , o = await r.evaluateAsync()
          , s = Object.entries(i);
        return await Promise.all(o.tuples.map(async l => {
            let c = await Promise.all(s.map(async ([u,f]) => {
                let d = l.getValue(f)
                  , p = await this.resolveValue(d);
                return [u, p]
            }
            ));
            return Object.fromEntries(c)
        }
        ))
    }
    async resolveValue(e) {
        if (e?.type === "richtext")
            return A(e.value instanceof ug, "Pointer must be wrapped"),
            e.value.resolve();
        if (e?.type === "array")
            return Promise.all(e.value.map(async t => this.resolveValue(t)));
        if (e?.type === "object") {
            let t = Object.entries(e.value)
              , n = await Promise.all(t.map(async ([r,i]) => {
                let o = await this.resolveValue(i);
                return [r, o]
            }
            ));
            return Object.fromEntries(n)
        }
        return e?.value ?? null
    }
}
, hu = "default", V4 = new Set([hu]), pu, A4 = class {
    constructor() {
        R(this, "entries", new Map),
        Qt(this, pu, {})
    }
    set(e, t, n, r) {
        switch (t) {
        case "transformTemplate":
            {
                A(typeof n == "string", `transformTemplate must be a string, received: ${n}`),
                this.setHash(e, r, {
                    transformTemplate: n,
                    legacy: !0
                });
                break
            }
        case "initial":
        case "animate":
            {
                A(typeof n == "object", `${t} must be a valid object, received: ${n}`),
                this.setHash(e, r, {
                    [t]: n,
                    legacy: !0
                });
                break
            }
        default:
            break
        }
    }
    setHash(e, t=hu, n) {
        let r = this.entries.get(e) ?? {}
          , i = r[t] ?? {};
        r[t] = n === null ? null : {
            ...i,
            ...n
        },
        this.entries.set(e, r)
    }
    variantHash(e, t) {
        if (e === t?.primaryVariantId)
            return hu;
        let n = de(this, pu)[e];
        if (n)
            return n;
        let r = t?.variantClassNames[e];
        return r ? de(this, pu)[e] = BC(r) : hu
    }
    setAll(e, t=V4, n, r) {
        var i;
        if (n === null) {
            for (let c of t)
                this.setHash(e, this.variantHash(c, r), null);
            return
        }
        let o = jn(n.transformTemplate) ? (i = n.transformTemplate) == null ? void 0 : i.call(n, {}, z4) : void 0
          , s = n.__framer__presenceInitial ?? n.initial
          , a = n.__framer__presenceAnimate ?? n.animate
          , l = {
            initial: Re(s) ? s : void 0,
            animate: Re(a) ? a : void 0,
            transformTemplate: xe(o) ? o : void 0
        };
        for (let c of t)
            this.setHash(e, this.variantHash(c, r), l)
    }
    clear() {
        this.entries.clear()
    }
    toObject() {
        return Object.fromEntries(this.entries)
    }
}
;
pu = new WeakMap;
var D4 = new A4;
function gW(e) {
    return x.forwardRef( ({optimized: t, ...n}, r) => {
        let i = x.useContext(TC)
          , o = x.useContext(cg)
          , s = n[B4];
        return s && !Vr() && D4.setAll(s, o, t ? n : null, i),
        k(e, {
            ref: r,
            ...n
        })
    }
    )
}
var z4 = "__Appear_Animation_Transform__";
var B4 = "data-framer-appear-id"
  , vW = "data-framer-appear-animation";
function mm(e, t) {
    e.forEach(n => clearTimeout(n)),
    e.clear(),
    t.forEach(n => n && n("Callback cancelled by variant change")),
    t.clear()
}
function $1() {
    return new Set
}
function bW(e) {
    let t = mt($1)
      , n = mt($1);
    return uC( () => () => mm(n, t)),
    x.useEffect( () => () => mm(n, t), [t, n]),
    x.useEffect( () => {
        mm(n, t)
    }
    , [e, t, n]),
    x.useRef({
        activeVariantCallback: r => (...i) => new Promise( (o, s) => {
            t.add(s),
            r(...i).then(o)
        }
        ).catch( () => {}
        ),
        delay: async (r, i) => {
            await new Promise(o => n.add(globalThis.setTimeout( () => o(!0), i))),
            r()
        }
    }).current
}
function $4(e, t, n) {
    return x.useCallback(r => {
        var i, o, s;
        return n ? e ? t ? Object.assign({}, (i = n[e]) == null ? void 0 : i[r], (o = n[t]) == null ? void 0 : o[r]) : ((s = n[e]) == null ? void 0 : s[r]) || {} : {} : {}
    }
    , [e, t, n])
}
function N4(e) {
    for (let[t,n] of Object.entries(e))
        if (nt.matchMedia(n).matches)
            return t
}
function j4(e) {
    var t;
    for (let {hash: n, mediaQuery: r} of e) {
        if (!r)
            continue;
        if (nt.matchMedia(r).matches)
            return n
    }
    return (t = e[0]) == null ? void 0 : t.hash
}
function SW(e, t, n=!0) {
    let r = D(pC)
      , i = V(Vr() ? N4(t) ?? e : e)
      , o = V(n && r ? e : i.current)
      , s = ju()
      , a = ib()
      , l = K(c => {
        (c !== i.current || c !== o.current) && a( () => {
            i.current = o.current = c,
            Mt( () => {
                s()
            }
            )
        }
        )
    }
    , [a, s]);
    return Xk( () => {
        !n || r !== !0 || l(i.current)
    }
    , []),
    $( () => {
        let c = [];
        for (let[u,f] of Object.entries(t)) {
            let d = nt.matchMedia(f)
              , p = v => {
                v.matches && l(u)
            }
            ;
            H4(d, p),
            c.push([d, p])
        }
        return () => c.forEach( ([u,f]) => W4(u, f))
    }
    , [t, l]),
    [i.current, o.current]
}
function H4(e, t) {
    e.addEventListener ? e.addEventListener("change", t) : e.addListener(t)
}
function W4(e, t) {
    e.removeEventListener ? e.removeEventListener("change", t) : e.removeListener(t)
}
var U4 = "style[data-framer-breakpoint-css]";
function G4(e) {
    setTimeout(e, 1)
}
function kW(e) {
    var t, n;
    let r = j4(e);
    if (r)
        for (let o of document.querySelectorAll(".hidden-" + r))
            (t = o.parentNode) == null || t.removeChild(o);
    (nt.requestIdleCallback ?? G4)( () => {
        var o;
        (o = document.querySelector(U4)) == null || o.remove()
    }
    );
    for (let o of document.querySelectorAll(".ssr-variant:empty"))
        (n = o.parentNode) == null || n.removeChild(o)
}
function N1(e, t) {
    if (e[t])
        return e[t];
    if (!(t in e))
        return e.default
}
function PW(e, t) {
    if (ns())
        return;
    let r = x.useRef(!0)
      , i = x.useRef(t);
    uC( (o, s) => {
        let a = o && !s;
        if (!r.current && a) {
            let l = N1(i.current, e);
            l && l()
        }
        r.current = a
    }
    , []),
    x.useEffect( () => {
        if (r.current) {
            let o = N1(i.current, e);
            o && o()
        }
    }
    , [e])
}
function j1(e, t) {
    return `${e}-${t}`
}
function q4(e, t) {
    let r = e.indexOf(t) + 1;
    r >= e.length && (r = 0);
    let i = e[r];
    return A(i !== void 0, "nextVariant should be defined"),
    i
}
function X4(e, t) {
    if (e) {
        if (t) {
            let n = e[t];
            if (n)
                return n
        }
        return e.default
    }
}
function H1(e, t, n, r, i) {
    let {hover: o, pressed: s, loading: a, error: l} = e || {};
    if (l && i)
        return "error";
    if (a && r)
        return "loading";
    if (s && n)
        return "pressed";
    if (o && t)
        return "hover"
}
function Y4(e, t) {
    let n = t[e];
    return n || `framer-v-${e}`
}
function W1(e, t, n) {
    return e && n.has(e) ? e : t
}
var K4 = Symbol("cycle");
function VW({variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i=[], variantProps: o={}, variantClassNames: s={}}) {
    let a = ju()
      , l = ns()
      , c = mt( () => new Set(i))
      , {wrapUpdatesInTransitions: u} = Gu()
      , f = x.useRef({
        isHovered: !1,
        isPressed: !1,
        isError: !1,
        hasPressedVariants: !0,
        baseVariant: W1(e, t, c),
        lastVariant: e,
        gestureVariant: void 0,
        loadedBaseVariant: {},
        defaultVariant: t,
        enabledGestures: r,
        cycleOrder: i,
        transitions: n
    })
      , d = x.useCallback(I => {
        let {isHovered: O, isPressed: B, isError: z, enabledGestures: j, defaultVariant: J} = f.current
          , H = W1(I, J, c)
          , fe = H1(j?.[H], O, B, !1, z)
          , ie = fe ? j1(H, fe) : void 0;
        return [H, ie]
    }
    , [c])
      , p = x.useCallback( ({isHovered: I, isPressed: O, isError: B}) => {
        I !== void 0 && (f.current.isHovered = I),
        O !== void 0 && (f.current.isPressed = O),
        B !== void 0 && (f.current.isError = B);
        let {baseVariant: z, gestureVariant: j, defaultVariant: J} = f.current
          , [H,fe] = d(z);
        (H !== z || fe !== j) && (f.current.baseVariant = H || J,
        f.current.gestureVariant = fe,
        B || u ? x.startTransition( () => {
            a()
        }
        ) : a())
    }
    , [d, a, u])
      , v = x.useCallback(I => {
        let {defaultVariant: O, cycleOrder: B, baseVariant: z, gestureVariant: j} = f.current
          , J = I === K4 ? q4(B || [], z || O) : I
          , [H,fe] = d(J);
        (H !== z || fe !== j) && (f.current.isError = !1,
        f.current.baseVariant = H || O,
        f.current.gestureVariant = fe,
        u ? x.startTransition( () => {
            a()
        }
        ) : a())
    }
    , [d, u, a])
      , g = x.useCallback( () => {
        let {baseVariant: I} = f.current;
        f.current.loadedBaseVariant[I] = !0,
        x.startTransition( () => {
            a()
        }
        )
    }
    , [a]);
    if (e !== f.current.lastVariant) {
        let[I,O] = d(e);
        f.current.lastVariant = I,
        (I !== f.current.baseVariant || O !== f.current.gestureVariant) && (f.current.baseVariant = I,
        f.current.gestureVariant = O)
    }
    let {baseVariant: b, gestureVariant: m, defaultVariant: h, enabledGestures: y, isHovered: w, isPressed: C, isError: S, loadedBaseVariant: T} = f.current
      , E = $4(f.current.baseVariant, f.current.gestureVariant, o);
    return x.useMemo( () => {
        var I;
        let O = [];
        b !== h && O.push(b);
        let B = (I = y?.[b]) == null ? void 0 : I.loading
          , z = !S && !l && !!B && !T[b]
          , j = z ? j1(b, "loading") : m;
        j && O.push(j);
        let J = y?.[b]
          , H = {
            onMouseEnter: () => p({
                isHovered: !0
            }),
            onMouseLeave: () => p({
                isHovered: !1
            })
        };
        return J?.pressed && Object.assign(H, {
            onTapStart: () => p({
                isPressed: !0
            }),
            onTapCancel: () => p({
                isPressed: !1
            }),
            onTap: () => p({
                isPressed: !1
            })
        }),
        {
            variants: O,
            baseVariant: b,
            gestureVariant: j,
            isLoading: z,
            transition: X4(f.current.transitions, b),
            setVariant: v,
            setGestureState: p,
            clearLoadingGesture: g,
            addVariantProps: E,
            gestureHandlers: H,
            classNames: bu(Y4(b, s), H1(J, w, C, z, S))
        }
    }
    , [b, m, w, C, T, E, v, h, y, p, g, s])
}
var Q4 = x.createContext(void 0)
  , Z4 = () => x.useContext(Q4);
var J4 = {
    Arial: {
        Regular: {
            selector: "Arial",
            weight: void 0
        },
        Black: {
            selector: "Arial-Black",
            weight: void 0
        },
        Narrow: {
            selector: "Arial Narrow",
            weight: void 0
        },
        "Rounded Bold": {
            selector: "Arial Rounded MT Bold",
            weight: void 0
        }
    },
    Avenir: {
        Book: {
            selector: "Avenir",
            weight: void 0
        },
        Light: {
            selector: "Avenir-Light",
            weight: void 0
        },
        Medium: {
            selector: "Avenir-Medium",
            weight: void 0
        },
        Heavy: {
            selector: "Avenir-Heavy",
            weight: void 0
        },
        Black: {
            selector: "Avenir-Black",
            weight: void 0
        }
    },
    "Avenir Next": {
        Regular: {
            selector: "Avenir Next",
            weight: void 0
        },
        "Ultra Light": {
            selector: "AvenirNext-UltraLight",
            weight: void 0
        },
        Medium: {
            selector: "AvenirNext-Medium",
            weight: void 0
        },
        "Demi Bold": {
            selector: "AvenirNext-DemiBold",
            weight: void 0
        },
        Heavy: {
            selector: "AvenirNext-Heavy",
            weight: void 0
        }
    },
    "Avenir Next Condensed": {
        Regular: {
            selector: "Avenir Next Condensed",
            weight: void 0
        },
        "Ultra Light": {
            selector: "AvenirNextCondensed-UltraLight",
            weight: void 0
        },
        Medium: {
            selector: "AvenirNextCondensed-Medium",
            weight: void 0
        },
        "Demi Bold": {
            selector: "AvenirNextCondensed-DemiBold",
            weight: void 0
        },
        Heavy: {
            selector: "AvenirNextCondensed-Heavy",
            weight: void 0
        }
    },
    Baskerville: {
        Regular: {
            selector: "Baskerville",
            weight: void 0
        },
        "Semi Bold": {
            selector: "Baskerville-SemiBold",
            weight: void 0
        }
    },
    "Bodoni 72": {
        Book: {
            selector: "Bodoni 72",
            weight: void 0
        },
        Oldstyle: {
            selector: "Bodoni 72 Oldstyle",
            weight: void 0
        },
        Smallcaps: {
            selector: "Bodoni 72 Smallcaps",
            weight: void 0
        }
    },
    Courier: {
        Regular: {
            selector: "Courier",
            weight: void 0
        }
    },
    "Courier New": {
        Regular: {
            selector: "Courier New",
            weight: void 0
        }
    },
    Futura: {
        Medium: {
            selector: "Futura",
            weight: void 0
        },
        Condensed: {
            selector: "Futura-CondensedMedium",
            weight: void 0
        },
        "Condensed ExtraBold": {
            selector: "Futura-CondensedExtraBold",
            weight: void 0
        }
    },
    Georgia: {
        Regular: {
            selector: "Georgia",
            weight: void 0
        }
    },
    "Gill Sans": {
        Regular: {
            selector: "Gill Sans",
            weight: void 0
        },
        Light: {
            selector: "GillSans-Light",
            weight: void 0
        },
        SemiBold: {
            selector: "GillSans-SemiBold",
            weight: void 0
        },
        UltraBold: {
            selector: "GillSans-UltraBold",
            weight: void 0
        }
    },
    Helvetica: {
        Regular: {
            selector: "Helvetica",
            weight: void 0
        },
        Light: {
            selector: "Helvetica-Light",
            weight: void 0
        },
        Bold: {
            selector: "Helvetica-Bold",
            weight: void 0
        },
        Oblique: {
            selector: "Helvetica-Oblique",
            weight: void 0
        },
        "Light Oblique": {
            selector: "Helvetica-LightOblique",
            weight: void 0
        },
        "Bold Oblique": {
            selector: "Helvetica-BoldOblique",
            weight: void 0
        }
    },
    "Helvetica Neue": {
        Regular: {
            selector: "Helvetica Neue",
            weight: void 0
        },
        UltraLight: {
            selector: "HelveticaNeue-UltraLight",
            weight: void 0
        },
        Thin: {
            selector: "HelveticaNeue-Thin",
            weight: void 0
        },
        Light: {
            selector: "HelveticaNeue-Light",
            weight: void 0
        },
        Medium: {
            selector: "HelveticaNeue-Medium",
            weight: void 0
        },
        Bold: {
            selector: "HelveticaNeue-Bold",
            weight: void 0
        },
        Italic: {
            selector: "HelveticaNeue-Italic",
            weight: void 0
        },
        "UltraLight Italic": {
            selector: "HelveticaNeue-UltraLightItalic",
            weight: void 0
        },
        "Thin Italic": {
            selector: "HelveticaNeue-ThinItalic",
            weight: void 0
        },
        "Light Italic": {
            selector: "HelveticaNeue-LightItalic",
            weight: void 0
        },
        "Medium Italic": {
            selector: "HelveticaNeue-MediumItalic",
            weight: void 0
        },
        "Bold Italic": {
            selector: "HelveticaNeue-BoldItalic",
            weight: void 0
        },
        "Condensed Bold": {
            selector: "HelveticaNeue-CondensedBold",
            weight: void 0
        },
        "Condensed Black": {
            selector: "HelveticaNeue-CondensedBlack",
            weight: void 0
        }
    },
    "Hoefler Text": {
        Regular: {
            selector: "Hoefler Text",
            weight: void 0
        }
    },
    Impact: {
        Regular: {
            selector: "Impact",
            weight: void 0
        }
    },
    "Lucida Grande": {
        Regular: {
            selector: "Lucida Grande",
            weight: void 0
        }
    },
    Menlo: {
        Regular: {
            selector: "Menlo",
            weight: void 0
        }
    },
    Monaco: {
        Regular: {
            selector: "Monaco",
            weight: void 0
        }
    },
    Optima: {
        Regular: {
            selector: "Optima",
            weight: void 0
        },
        ExtraBlack: {
            selector: "Optima-ExtraBlack",
            weight: void 0
        }
    },
    Palatino: {
        Regular: {
            selector: "Palatino",
            weight: void 0
        }
    },
    "SF Pro Display": {
        Regular: {
            selector: "__SF-UI-Display-Regular__",
            weight: 400
        },
        Ultralight: {
            selector: "__SF-UI-Display-Ultralight__",
            weight: 100
        },
        Thin: {
            selector: "__SF-UI-Display-Thin__",
            weight: 200
        },
        Light: {
            selector: "__SF-UI-Display-Light__",
            weight: 300
        },
        Medium: {
            selector: "__SF-UI-Display-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Display-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Display-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Display-Heavy__",
            weight: 800
        },
        Black: {
            selector: "__SF-UI-Display-Black__",
            weight: 900
        },
        Italic: {
            selector: "__SF-UI-Display-Italic__",
            weight: 400
        },
        "Ultralight Italic": {
            selector: "__SF-UI-Display-Ultralight-Italic__",
            weight: 100
        },
        "Thin Italic": {
            selector: "__SF-UI-Display-Thin-Italic__",
            weight: 200
        },
        "Light Italic": {
            selector: "__SF-UI-Display-Light-Italic__",
            weight: 300
        },
        "Medium Italic": {
            selector: "__SF-UI-Display-Medium-Italic__",
            weight: 500
        },
        "Semibold Italic": {
            selector: "__SF-UI-Display-Semibold-Italic__",
            weight: 600
        },
        "Bold Italic": {
            selector: "__SF-UI-Display-Bold-Italic__",
            weight: 700
        },
        "Heavy Italic": {
            selector: "__SF-UI-Display-Heavy-Italic__",
            weight: 800
        },
        "Black Italic": {
            selector: "__SF-UI-Display-Black-Italic__",
            weight: 900
        }
    },
    "SF Pro Display Condensed": {
        Regular: {
            selector: "__SF-UI-Display-Condensed-Regular__",
            weight: 400
        },
        Ultralight: {
            selector: "__SF-UI-Display-Condensed-Ultralight__",
            weight: 100
        },
        Thin: {
            selector: "__SF-UI-Display-Condensed-Thin__",
            weight: 200
        },
        Light: {
            selector: "__SF-UI-Display-Condensed-Light__",
            weight: 300
        },
        Medium: {
            selector: "__SF-UI-Display-Condensed-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Display-Condensed-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Display-Condensed-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Display-Condensed-Heavy__",
            weight: 800
        },
        Black: {
            selector: "__SF-UI-Display-Condensed-Black__",
            weight: 900
        }
    },
    "SF Pro Text": {
        Regular: {
            selector: "__SF-UI-Text-Regular__",
            weight: 400
        },
        Light: {
            selector: "__SF-UI-Text-Light__",
            weight: 200
        },
        Medium: {
            selector: "__SF-UI-Text-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Text-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Text-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Text-Heavy__",
            weight: 800
        },
        Italic: {
            selector: "__SF-UI-Text-Italic__",
            weight: 400
        },
        "Light Italic": {
            selector: "__SF-UI-Text-Light-Italic__",
            weight: 200
        },
        "Medium Italic": {
            selector: "__SF-UI-Text-Medium-Italic__",
            weight: 500
        },
        "Semibold Italic": {
            selector: "__SF-UI-Text-Semibold-Italic__",
            weight: 600
        },
        "Bold Italic": {
            selector: "__SF-UI-Text-Bold-Italic__",
            weight: 700
        },
        "Heavy Italic": {
            selector: "__SF-UI-Text-Heavy-Italic__",
            weight: 800
        }
    },
    "SF Pro Text Condensed": {
        Regular: {
            selector: "__SF-UI-Text-Condensed-Regular__",
            weight: 400
        },
        Light: {
            selector: "__SF-UI-Text-Condensed-Light__",
            weight: 200
        },
        Medium: {
            selector: "__SF-UI-Text-Condensed-Medium__",
            weight: 500
        },
        Semibold: {
            selector: "__SF-UI-Text-Condensed-Semibold__",
            weight: 600
        },
        Bold: {
            selector: "__SF-UI-Text-Condensed-Bold__",
            weight: 700
        },
        Heavy: {
            selector: "__SF-UI-Text-Condensed-Heavy__",
            weight: 800
        }
    },
    Tahoma: {
        Regular: {
            selector: "Tahoma",
            weight: void 0
        }
    },
    Times: {
        Regular: {
            selector: "Times",
            weight: void 0
        }
    },
    "Times New Roman": {
        Regular: {
            selector: "Times New Roman",
            weight: void 0
        }
    },
    Trebuchet: {
        Regular: {
            selector: "Trebuchet MS",
            weight: void 0
        }
    },
    Verdana: {
        Regular: {
            selector: "Verdana",
            weight: void 0
        }
    }
}
  , eB = {
    "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular",
    "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight",
    "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin",
    "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light",
    "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium",
    "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold",
    "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy",
    "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black",
    "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold",
    "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText",
    "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light",
    "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium",
    "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold",
    "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold",
    "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy",
    "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic",
    "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic",
    "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic",
    "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic",
    "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic",
    "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic",
    "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular",
    "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light",
    "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium",
    "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold",
    "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold",
    "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy",
    "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic",
    "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic",
    "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic",
    "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic",
    "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic",
    "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic",
    "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular",
    "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight",
    "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin",
    "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light",
    "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium",
    "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold",
    "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold",
    "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy",
    "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black",
    "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay",
    "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight",
    "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin",
    "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light",
    "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium",
    "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold",
    "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold",
    "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy",
    "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black",
    "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic",
    "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic",
    "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic",
    "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic",
    "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic",
    "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic",
    "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic",
    "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic",
    "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic",
    "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular",
    "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light",
    "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium",
    "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold",
    "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold",
    "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy",
    "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular",
    "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight",
    "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin",
    "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light",
    "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium",
    "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold",
    "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold",
    "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy",
    "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black"
}
  , U1 = J4;
function Vu(e) {
    return e.weight !== void 0 && e.style !== void 0
}
var tB = "System Default"
  , nB = class {
    constructor() {
        R(this, "name", "local"),
        R(this, "fontFamilies", []),
        R(this, "byFamilyName", new Map),
        R(this, "fontAliasBySelector", new Map),
        R(this, "fontAliases", new Map)
    }
    getFontFamilyByName(e) {
        return this.byFamilyName.get(e) ?? null
    }
    createFontFamily(e) {
        let t = {
            name: e,
            fonts: [],
            source: this.name
        };
        return this.addFontFamily(t),
        t
    }
    addFontFamily(e) {
        this.fontFamilies.push(e),
        this.byFamilyName.set(e.name, e)
    }
    importFonts() {
        let e = [];
        for (let r of Object.keys(U1)) {
            let i = U1[r];
            if (!i)
                continue;
            let o = this.createFontFamily(r);
            for (let s of Object.keys(i)) {
                let a = i[s];
                if (!a)
                    continue;
                let {selector: l, weight: c} = a
                  , u = {
                    variant: s,
                    selector: l,
                    weight: c,
                    family: o
                };
                o.fonts.push(u)
            }
            e.push(...o.fonts)
        }
        for (let[r,i] of Object.entries(eB))
            this.addFontAlias(r, i);
        let {fontFamily: t, aliases: n} = this.getSystemFontFamily();
        this.addFontFamily(t);
        for (let[r,i] of n)
            this.addFontAlias(r, i);
        return e.push(...t.fonts),
        e
    }
    addFontAlias(e, t) {
        this.fontAliases.set(e, t),
        this.fontAliasBySelector.set(t, e)
    }
    getSystemFontFamily() {
        let e = "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif"
          , t = {
            name: tB,
            fonts: [],
            source: this.name
        }
          , n = new Map
          , r = [400, 100, 200, 300, 500, 600, 700, 800, 900]
          , i = ["normal", "italic"];
        for (let o of i)
            for (let s of r) {
                let a = rB(s, o)
                  , l = `__SystemDefault-${s}-${o}__`
                  , c = {
                    variant: a,
                    selector: l,
                    style: o,
                    weight: s,
                    family: t
                };
                t.fonts.push(c),
                n.set(l, e)
            }
        return {
            fontFamily: t,
            aliases: n
        }
    }
    getFontAliasBySelector(e) {
        return this.fontAliasBySelector.get(e) || null
    }
    getFontSelectorByAlias(e) {
        return this.fontAliases.get(e) || null
    }
    isFontFamilyAlias(e) {
        return !!(e && /^__.*__$/u.exec(e))
    }
}
  , G1 = {
    100: "Thin",
    200: "Extra Light",
    300: "Light",
    400: "Normal",
    500: "Medium",
    600: "Semi Bold",
    700: "Bold",
    800: "Extra Bold",
    900: "Black"
};
function rB(e, t) {
    let n = t === "normal" ? "Regular" : "Italic";
    return e === 400 ? n : t !== "normal" ? `${G1[e]} ${n}` : `${G1[e]}`
}
var iB = hr(Bm(), 1);
function pT(e) {
    return !!e.variationAxes
}
function gm(e) {
    return pT(e) && e.family.source !== "custom" ? oB(e.family.name) : e.family.name
}
function oB(e) {
    return `${e} Variable`
}
var Yo = "CUSTOM;";
function sB(e, t) {
    if (!t)
        return e.substring(0, e.lastIndexOf("."));
    let {font: n} = t
      , r = n.preferredFamily || n.fontFamily
      , i = Array.isArray(n.variationAxes);
    if (i && r.toLowerCase().includes("variable"))
        return r;
    let o = i ? "Variable" : n.preferredSubFamily || n.fontSubFamily;
    return `${r} ${o}`
}
var aB = class {
    constructor() {
        R(this, "name", "custom"),
        R(this, "fontFamilies", []),
        R(this, "byFamilyName", new Map),
        R(this, "assetsByFamily", new Map)
    }
    importFonts(e) {
        var t, n, r;
        this.fontFamilies.length = 0,
        this.byFamilyName.clear(),
        this.assetsByFamily.clear();
        let i = [];
        for (let o of e) {
            if (!this.isValidCustomFontAsset(o))
                continue;
            let s = (t = o.properties) == null ? void 0 : t.font.variationAxes
              , a = Array.isArray(s)
              , l = sB(o.name, o.properties)
              , c = this.createFontFamily(l)
              , u = (n = o.properties) == null ? void 0 : n.font.openTypeData
              , f = a ? "variable" : this.inferVariantName(l)
              , d = {
                family: c,
                selector: `${Yo}${l}`,
                variant: f,
                postscriptName: (r = o.properties) == null ? void 0 : r.font.postscriptName,
                file: o.url,
                openTypeFeatures: this.validateOpenTypeData(u),
                variationAxes: this.validateVariationAxes(s)
            };
            c.fonts.push(d),
            c.owner = o.ownerType === "team" ? "team" : "project",
            this.assetsByFamily.set(l, o),
            i.push(...c.fonts)
        }
        return i
    }
    isValidCustomFontAsset(e) {
        var t;
        return !e.mimeType.startsWith("font/") || ((t = e.properties) == null ? void 0 : t.kind) !== "font" || !e.properties.font ? !1 : "fontFamily"in e.properties.font
    }
    validateOpenTypeData(e) {
        if (e && Array.isArray(e))
            return e.map(t => {
                if (this.isOpenTypeFeature(t))
                    return {
                        tag: t.tag,
                        coverage: t.coverage
                    }
            }
            )
    }
    validateVariationAxes(e) {
        if (!e || !Array.isArray(e))
            return;
        let t = [];
        for (let n of e)
            this.isVariationAxis(n) && t.push({
                tag: n.tag,
                name: n.name,
                minValue: n.minValue,
                maxValue: n.maxValue,
                defaultValue: n.defaultValue
            });
        return t
    }
    isOpenTypeFeature(e) {
        return !(typeof e != "object" || e === null || !("tag"in e) || typeof e.tag != "string" || "coverage"in e && typeof e.coverage < "u" && !Array.isArray(e.coverage))
    }
    isVariationAxis(e) {
        return !(typeof e != "object" || e === null || !("tag"in e) || typeof e.tag != "string" || !("name"in e) || typeof e.name != "string" || !("minValue"in e) || typeof e.minValue != "number" || !("maxValue"in e) || typeof e.maxValue != "number" || !("defaultValue"in e) || typeof e.defaultValue != "number")
    }
    inferVariantName(e) {
        let t = ["thin", "ultra light", "extra light", "light", "normal", "medium", "semi bold", "bold", "extra bold", "black"]
          , n = [...t.map(s => `${s} italic`), ...t]
          , r = e.toLowerCase()
          , i = [...r.split(" "), ...r.split("-"), ...r.split("_")]
          , o = n.find(s => i.includes(s) || i.includes(s.replace(/\s+/gu, "")));
        return o ? o.replace(/^\w|\s\w/gu, s => s.toUpperCase()) : "Regular"
    }
    createFontFamily(e) {
        let t = this.byFamilyName.get(e);
        if (t)
            return t;
        let n = {
            source: this.name,
            name: e,
            fonts: []
        };
        return this.addFontFamily(n),
        n
    }
    addFontFamily(e) {
        this.fontFamilies.push(e),
        this.byFamilyName.set(e.name, e)
    }
    parseSelector(e) {
        if (!e.startsWith(Yo))
            return null;
        let t = e.split(Yo);
        return t[1] === void 0 ? null : {
            source: "custom",
            name: t[1]
        }
    }
    getFontBySelector(e, t=!0) {
        let n = this.parseSelector(e);
        if (!n || !t && !this.byFamilyName.get(n.name))
            return;
        let r = this.getFontFamilyByName(n.name).fonts;
        return r.find(o => {
            var s;
            return (s = o.file) == null ? void 0 : s.endsWith(".woff2")
        }
        ) || r[0]
    }
    getFontFamilyByName(e) {
        let t = this.byFamilyName.get(e);
        if (t)
            return t;
        let n = {
            source: "custom",
            name: e,
            fonts: []
        };
        return n.fonts.push({
            selector: `${Yo}${e}`,
            variant: this.inferVariantName(e),
            family: n
        }),
        n
    }
}
;
function mT(e, t) {
    return {
        ...lB(e, t),
        ...cB(e, t)
    }
}
function lB(e, t) {
    if (t.length === 0)
        return {
            variantBold: void 0,
            variantBoldItalic: void 0,
            variantItalic: void 0
        };
    let {weight: n, style: r} = e
      , i = new Map
      , o = new Map;
    for (let u of t)
        u.isVariable === e.isVariable && (i.set(`${u.weight}-${u.style}`, u),
        !(u.weight <= n) && (o.has(u.style) || o.set(u.style, u)));
    let s = o.get(r)
      , a = o.get("italic")
      , l = e.weight;
    l <= 300 ? (s = i.get(`400-${r}`) ?? s,
    a = i.get("400-italic") ?? a) : l <= 500 ? (s = i.get(`700-${r}`) ?? s,
    a = i.get("700-italic") ?? a) : (s = i.get(`900-${r}`) ?? s,
    a = i.get("900-italic") ?? a);
    let c = i.get(`${n}-italic`);
    return {
        variantBold: s,
        variantItalic: c,
        variantBoldItalic: a
    }
}
function cB(e, t) {
    if (t.length === 0)
        return {
            variantVariable: void 0,
            variantVariableItalic: void 0
        };
    let n = new Map;
    for (let r of t)
        r.isVariable && n.set(`${r.weight}-${r.style}`, r);
    return {
        variantVariable: n.get(`${e.weight}-normal`) ?? n.get("400-normal") ?? void 0,
        variantVariableItalic: n.get(`${e.weight}-italic`) ?? n.get("400-italic") ?? void 0
    }
}
var uB = ["display", "sans", "serif", "slab", "handwritten", "script"];
function fB(e) {
    return e.split(",").map(t => t.trim().toLowerCase()).filter(dB)
}
function dB(e) {
    return uB.includes(e)
}
var ka = "FS;"
  , gT = {
    thin: 100,
    hairline: 100,
    extralight: 200,
    light: 300,
    regular: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    ultra: 800,
    black: 900,
    heavy: 900
}
  , vT = Object.keys(gT)
  , hB = ( () => new RegExp(`^(?:${[...vT, "italic", "variable"].join("|")})`,"u"))()
  , Ra = class {
    constructor() {
        R(this, "name", "fontshare"),
        R(this, "fontFamilies", []),
        R(this, "byFamilyName", new Map)
    }
    getFontFamilyByName(e) {
        return this.byFamilyName.get(e) ?? null
    }
    static parseVariant(e) {
        let t = e.toLowerCase().split(" ")
          , n = vT.find(s => t.includes(s))
          , r = e.toLowerCase().includes("italic") ? "italic" : "normal";
        return {
            weight: n && gT[n] || 400,
            style: r === "italic" ? r : "normal"
        }
    }
    parseSelector(e) {
        if (!e.startsWith(ka))
            return null;
        let t = e.split("-");
        if (t.length !== 2)
            return null;
        let[n,r] = t;
        return !n || !r ? null : {
            name: n.replace(ka, ""),
            variant: r,
            source: this.name,
            isVariable: r.toLowerCase().includes("variable")
        }
    }
    static createSelector(e, t) {
        return `${ka}${e}-${t.toLowerCase()}`
    }
    static createVariationAxesSelector(e) {
        return `${ka}${e}`
    }
    addFontFamily(e) {
        this.fontFamilies.push(e),
        this.byFamilyName.set(e.name, e)
    }
    importFonts(e, t) {
        this.fontFamilies.length = 0,
        this.byFamilyName.clear();
        let n = [];
        for (let r of e) {
            let o = r.font_styles.filter(u => {
                let f = u.name.toLowerCase();
                return !(!hB.exec(f) || f.split(" ").includes("wide"))
            }
            ).map(u => ({
                ...Ra.parseVariant(u.name),
                selector: Ra.createSelector(r.name, u.name),
                isVariable: u.is_variable,
                fontshareVariantName: u.name,
                file: u.file
            }))
              , s = Ra.createVariationAxesSelector(r.name)
              , a = t?.[s]
              , l = r.name
              , c = this.getFontFamilyByName(l);
            c || (c = {
                name: l,
                fonts: [],
                source: this.name
            },
            this.addFontFamily(c));
            for (let u of o) {
                let {variantBold: f, variantBoldItalic: d, variantItalic: p, variantVariable: v, variantVariableItalic: g} = mT(u, o)
                  , b = {
                    family: c,
                    variant: u.fontshareVariantName.toLowerCase(),
                    selector: u.selector,
                    selectorBold: f?.selector,
                    selectorBoldItalic: d?.selector,
                    selectorItalic: p?.selector,
                    selectorVariable: v?.selector,
                    selectorVariableItalic: g?.selector,
                    weight: u.weight,
                    style: u.style,
                    file: u.file,
                    category: pB(r.category),
                    variationAxes: u.isVariable ? a : void 0
                };
                c.fonts.push(b),
                n.push(b)
            }
        }
        return n
    }
}
;
function pB(e) {
    let t = {
        serif: "serif",
        sans: "sans-serif",
        slab: "slab",
        display: "display",
        handwritten: "handwriting",
        script: "handwriting"
    }
      , n = fB(e)[0];
    return n && t[n]
}
var mB = "Inter"
  , gB = "FR;"
  , vB = {
    Thin: 100,
    ExtraLight: 200,
    Light: 300,
    "": 400,
    Medium: 500,
    SemiBold: 600,
    Bold: 700,
    ExtraBold: 800,
    Black: 900
}
  , Am = class {
    constructor() {
        R(this, "name", "framer"),
        R(this, "fontFamilies", []),
        R(this, "byFamilyName", new Map)
    }
    getFontFamilyByName(e) {
        return this.byFamilyName.get(e) ?? null
    }
    addFontFamily(e) {
        let t = {
            name: e,
            fonts: [],
            source: this.name
        };
        return this.fontFamilies.push(t),
        this.byFamilyName.set(t.name, t),
        t
    }
    static getDraftFontPropertiesBySelector(e) {
        if (!e.startsWith(gB) && !e.startsWith(mB))
            return null;
        let t = e.split("-")
          , [n,r=""] = t;
        if (!n)
            return null;
        let i = r.includes("Italic") ? "italic" : "normal"
          , o = r.replace("Italic", "")
          , s = o && vB[o] || 400;
        return {
            family: n,
            style: i,
            weight: s,
            source: "framer",
            variant: void 0,
            category: "sans-serif"
        }
    }
    static createVariationAxesKey(e) {
        return e.familyName
    }
    importFonts(e, t) {
        this.fontFamilies.length = 0,
        this.byFamilyName.clear();
        let n = [];
        return e.forEach(r => {
            let {familyName: i, ...o} = r
              , s = Am.createVariationAxesKey(r)
              , a = t?.[s]
              , l = this.getFontFamilyByName(i);
            l || (l = this.addFontFamily(i));
            let c = r.selector === r.selectorVariable || r.selector === r.selectorVariableItalic
              , u = {
                ...o,
                family: l,
                variationAxes: c ? a : void 0
            };
            l.fonts.push(u),
            n.push(u)
        }
        ),
        n
    }
}
  , Ca = "GF;"
  , ji = class {
    constructor() {
        R(this, "name", "google"),
        R(this, "fontFamilies", []),
        R(this, "byFamilyName", new Map)
    }
    getFontFamilyByName(e) {
        return this.byFamilyName.get(e) ?? null
    }
    static parseVariant(e) {
        if (e === "regular")
            return {
                style: "normal",
                weight: 400
            };
        let t = /(\d*)(normal|italic)?/u.exec(e);
        if (!t)
            return {};
        let n = parseInt(t[1] || "400")
          , r = t[2] === "italic" ? "italic" : "normal";
        return {
            weight: n,
            style: r
        }
    }
    parseSelector(e) {
        if (!e.startsWith(Ca))
            return null;
        let t = e.includes("-variable-")
          , n = t ? e.split("-variable-") : e.split("-");
        if (n.length !== 2)
            return null;
        let[r,i] = n;
        return !r || !i ? null : {
            name: r.replace(Ca, ""),
            variant: i,
            source: this.name,
            isVariable: t
        }
    }
    static createSelector(e, t, n) {
        return `${Ca}${e}-${n ? "variable-" : ""}${t}`
    }
    static createVariationAxesSelector(e) {
        return `${Ca}${e}`
    }
    addFontFamily(e) {
        let t = {
            name: e,
            fonts: [],
            source: this.name
        };
        return this.fontFamilies.push(t),
        this.byFamilyName.set(t.name, t),
        t
    }
    importFonts(e, t, n) {
        var r;
        this.fontFamilies.length = 0,
        this.byFamilyName.clear();
        let i = []
          , o = q1(e, a => a.family)
          , s = q1(t, a => a.family);
        for (let a in o) {
            let l = o[a];
            if (!l)
                continue;
            let c = this.getFontFamilyByName(l.family);
            c || (c = this.addFontFamily(l.family));
            let f = l.variants.map(h => ({
                ...ji.parseVariant(h),
                googleFontsVariantName: h,
                selector: ji.createSelector(a, h, !1),
                isVariable: !1,
                file: l.files[h]
            }))
              , d = s[a]
              , p = d?.axes ? d.variants.map(h => ({
                ...ji.parseVariant(h),
                googleFontsVariantName: h,
                selector: ji.createSelector(a, h, !0),
                isVariable: !0,
                file: d.files[h]
            })) : []
              , v = ji.createVariationAxesSelector(l.family)
              , g = n?.[v]
              , b = [...f, ...p]
              , m = b.filter(Vu);
            for (let h of b) {
                let {weight: y, style: w, selector: C, googleFontsVariantName: S} = h
                  , T = Vu(h) ? mT(h, m) : void 0
                  , {variantBold: E, variantItalic: I, variantBoldItalic: O, variantVariable: B, variantVariableItalic: z} = T ?? {}
                  , j = {
                    family: c,
                    variant: S,
                    selector: C,
                    selectorBold: E?.selector,
                    selectorBoldItalic: O?.selector,
                    selectorItalic: I?.selector,
                    selectorVariable: B?.selector,
                    selectorVariableItalic: z?.selector,
                    weight: y,
                    style: w,
                    category: yB(l.category),
                    file: (r = h.file) == null ? void 0 : r.replace("http://", "https://"),
                    variationAxes: h.isVariable ? g : void 0
                };
                c.fonts.push(j),
                i.push(j)
            }
        }
        return i
    }
}
;
function yB(e) {
    let t = {
        serif: "serif",
        "sans-serif": "sans-serif",
        display: "display",
        handwriting: "handwriting",
        monospace: "monospace"
    };
    if (e)
        return t[e]
}
function q1(e, t) {
    return e.reduce( (n, r) => (n[t(r)] = r,
    n), {})
}
var bB = hr(cM(), 1)
  , X1 = 5e3
  , xB = 3
  , yT = class extends Error {
    constructor(e) {
        super(e),
        this.name = "FontLoadingError"
    }
}
  , vm = new Map
  , ym = new Map
  , Y1 = (e, t) => bT(e, t);
async function bT(e, t, n=0) {
    let {family: r, url: i, stretch: o, unicodeRange: s, isVariableFont: a} = e
      , l = a ? e.weight : e.weight || 500
      , c = e.style || "normal"
      , u = `${r}-${c}-${l}-${i}`;
    if (!vm.has(u) || n > 0) {
        let f = new FontFace(r,`url(${i})`,{
            weight: xe(l) ? l : l?.toString(),
            style: c,
            stretch: o,
            unicodeRange: s
        })
          , d = f.load().then( () => (t.fonts.add(f),
        xT(r, c, l))).catch(p => {
            if (p.name !== "NetworkError")
                throw p;
            if (n < xB)
                return bT(e, t, n + 1);
            throw new yT(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({
                family: r,
                style: c,
                weight: l,
                url: i,
                stretch: o,
                unicodeRange: s
            })}`)
        }
        );
        vm.set(u, d)
    }
    await vm.get(u)
}
async function xT(e, t, n) {
    let r = `${e}-${t}-${n}`;
    if (!ym.has(r)) {
        let o = new bB.default(e,{
            style: t,
            weight: n
        }).load(null, X1);
        ym.set(r, o)
    }
    try {
        await ym.get(r)
    } catch {
        throw new yT(`Failed to check if font is ready (${X1}ms timeout exceeded): ${JSON.stringify({
            family: e,
            style: t,
            weight: n
        })}`)
    }
}
var K1 = {
    Inter: [{
        tag: "opsz",
        minValue: 14,
        maxValue: 32,
        defaultValue: 14,
        name: "Optical size"
    }, {
        tag: "wght",
        minValue: 100,
        maxValue: 900,
        defaultValue: 400,
        name: "Weight"
    }]
};
function bm(e) {
    try {
        if (e === "framer")
            return Q1(K1) ? K1 : void 0;
        {
            let t = (async () => {
                switch (e) {
                case "google":
                    return (await import("./google-5Y2W5CAB-KAMWJK7N.mjs")).default;
                case "fontshare":
                    return (await import("./fontshare-XR4PZDC4-PHFHRCTW.mjs")).default;
                default:
                    ke(e)
                }
            }
            )();
            return Q1(t) ? t : void 0
        }
    } catch (t) {
        console.error(t);
        return
    }
}
function Q1(e) {
    return Re(e) && Object.values(e).every(SB)
}
function wB(e) {
    return Re(e) && xe(e.tag)
}
function SB(e) {
    return Array.isArray(e) && e.every(wB)
}
var kB = class {
    constructor() {
        R(this, "enabled", !1),
        R(this, "bySelector", new Map),
        R(this, "getGoogleFontsListPromise"),
        R(this, "getFontshareFontsListPromise"),
        R(this, "loadedSelectors", new Set),
        R(this, "local"),
        R(this, "google"),
        R(this, "fontshare"),
        R(this, "framer"),
        R(this, "custom"),
        this.local = new nB,
        this.google = new ji,
        this.fontshare = new Ra,
        this.framer = new Am,
        this.custom = new aB,
        this.bySelector = new Map,
        this.importLocalFonts()
    }
    addFont(e) {
        this.bySelector.set(e.selector, e)
    }
    getAvailableFonts() {
        return Array.from(this.bySelector.values())
    }
    importLocalFonts() {
        for (let e of this.local.importFonts())
            this.addFont(e),
            this.loadFont(e)
    }
    async importGoogleFonts() {
        return this.getGoogleFontsListPromise || (this.getGoogleFontsListPromise = Promise.resolve().then(async () => {
            let {staticFonts: e, variableFonts: t} = await pt.fetchGoogleFontsList()
              , n = await bm("google");
            for (let r of this.google.importFonts(e, t, n))
                this.addFont(r);
            return {
                staticFonts: e,
                variableFonts: t
            }
        }
        )),
        this.getGoogleFontsListPromise
    }
    async importFontshareFonts() {
        if (!this.getFontshareFontsListPromise) {
            this.getFontshareFontsListPromise = pt.fetchFontshareFontsList();
            let e = await this.getFontshareFontsListPromise
              , t = await bm("fontshare");
            for (let n of this.fontshare.importFonts(e, t))
                this.addFont(n)
        }
        return this.getFontshareFontsListPromise
    }
    importFramerFonts(e) {
        let t = bm("framer");
        this.framer.importFonts(e, t).forEach(n => {
            this.addFont(n)
        }
        )
    }
    importCustomFonts(e) {
        this.bySelector.forEach( (t, n) => {
            n.startsWith(Yo) && this.bySelector.delete(n)
        }
        );
        for (let t of this.custom.importFonts(e))
            this.addFont(t)
    }
    getFontFamily(e) {
        return this[e.source].getFontFamilyByName(e.name)
    }
    getFontBySelector(e, t=!0) {
        if (e)
            return e.startsWith(Yo) ? this.custom.getFontBySelector(e, t) : this.bySelector.get(e)
    }
    getDraftPropertiesBySelector(e) {
        let t = this.getFontBySelector(e);
        if (t)
            return {
                style: t.style,
                weight: t.weight,
                variant: t.variant,
                family: gm(t),
                source: t.family.source,
                category: t.category
            };
        let n = this.google.parseSelector(e);
        if (n) {
            let o = ji.parseVariant(n.variant);
            if (Vu(o))
                return {
                    style: o.style,
                    weight: o.weight,
                    variant: n.variant,
                    family: n.name,
                    source: "google",
                    category: void 0
                }
        }
        let r = this.fontshare.parseSelector(e);
        if (r) {
            let o = Ra.parseVariant(r.variant);
            if (Vu(o))
                return {
                    style: o.style,
                    weight: o.weight,
                    variant: r.variant,
                    family: r.name,
                    source: "fontshare",
                    category: void 0
                }
        }
        let i = Am.getDraftFontPropertiesBySelector(e);
        return i || null
    }
    isSelectorLoaded(e) {
        return this.loadedSelectors.has(e)
    }
    async loadFont(e) {
        if (this.isSelectorLoaded(e.selector))
            return 0;
        let t = e.family.source
          , n = pT(e);
        switch (t) {
        case "local":
            return this.loadedSelectors.add(e.selector),
            1;
        case "framer":
            if (iB.default.env.NODE_ENV !== "test" && await xT(e.family.name, e.style, e.weight),
            n) {
                if (!e.file)
                    return Promise.reject(`Unable to load font: ${e.selector}`);
                await Y1({
                    family: gm(e),
                    url: e.file,
                    weight: e.weight,
                    style: e.style,
                    isVariableFont: n
                }, document)
            }
            return this.loadedSelectors.add(e.selector),
            1;
        case "google":
        case "fontshare":
        case "custom":
            return e.file ? (await Y1({
                family: gm(e),
                url: e.file,
                weight: e.weight,
                style: e.style,
                isVariableFont: n
            }, document),
            this.loadedSelectors.add(e.selector),
            1) : Promise.reject(`Unable to load font: ${e.selector}`);
        default:
            ke(t)
        }
    }
    async loadFontsFromSelectors(e) {
        if (!this.enabled)
            return [];
        let t = e.some(i => i.startsWith(Ca))
          , n = e.some(i => i.startsWith(ka));
        if (t || n) {
            try {
                await this.importFontshareFonts()
            } catch (i) {
                Fa("Failed to load Fontshare fonts:", i)
            }
            try {
                await this.importGoogleFonts()
            } catch (i) {
                Fa("Failed to load Google fonts:", i)
            }
        }
        let r = e.map(i => this.bySelector.get(i)).filter(i => !!i);
        return Promise.allSettled(r.map(i => this.loadFont(i)))
    }
    async loadFonts(e) {
        return {
            newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(r => r.status === "fulfilled" && r.value === 1).length
        }
    }
    async loadMissingFonts(e, t) {
        let n = e.filter(i => !mu.isSelectorLoaded(i));
        if (n.length === 0)
            return;
        await mu.loadWebFontsFromSelectors(n),
        n.every(i => mu.isSelectorLoaded(i)) && t && t()
    }
    async loadWebFontsFromSelectors(e) {
        return this.loadFontsFromSelectors(e)
    }
    get defaultFont() {
        let e = this.getFontBySelector("Inter");
        return A(e, "Can\u2019t find Inter font"),
        e
    }
}
  , mu = new kB;
Promise.allSettled = Promise.allSettled || (e => Promise.all(e.map(t => t.then(n => ({
    status: "fulfilled",
    value: n
})).catch(n => ({
    status: "rejected",
    reason: n
})))));
var wT = (e => (e.Padding = "--framer-input-padding",
e.BorderRadiusTopLeft = "--framer-input-border-radius-top-left",
e.BorderRadiusTopRight = "--framer-input-border-radius-top-right",
e.BorderRadiusBottomRight = "--framer-input-border-radius-bottom-right",
e.BorderRadiusBottomLeft = "--framer-input-border-radius-bottom-left",
e.BorderColor = "--framer-input-border-color",
e.BorderTopWidth = "--framer-input-border-top-width",
e.BorderRightWidth = "--framer-input-border-right-width",
e.BorderBottomWidth = "--framer-input-border-bottom-width",
e.BorderLeftWidth = "--framer-input-border-left-width",
e.BorderStyle = "--framer-input-border-style",
e.Background = "--framer-input-background",
e.FontFamily = "--framer-input-font-family",
e.FontWeight = "--framer-input-font-weight",
e.FontSize = "--framer-input-font-size",
e.FontColor = "--framer-input-font-color",
e.FontStyle = "--framer-input-font-style",
e.FontLetterSpacing = "--framer-input-font-letter-spacing",
e.FontTextAlignment = "--framer-input-font-text-alignment",
e.FontLineHeight = "--framer-input-font-line-height",
e.FontOpenType = "--framer-input-font-open-type-features",
e.PlaceholderColor = "--framer-input-placeholder-color",
e.BoxShadow = "--framer-input-box-shadow",
e.FocusedBorderColor = "--framer-input-focused-border-color",
e.FocusedBorderWidth = "--framer-input-focused-border-width",
e.FocusedBorderStyle = "--framer-input-focused-border-style",
e.FocusedBackground = "--framer-input-focused-background",
e.FocusedBoxShadow = "--framer-input-focused-box-shadow",
e.FocusedTransition = "--framer-input-focused-transition",
e.BooleanCheckedBackground = "--framer-input-boolean-checked-background",
e.BooleanCheckedBorderColor = "--framer-input-boolean-checked-border-color",
e.BooleanCheckedBorderWidth = "--framer-input-boolean-checked-border-width",
e.BooleanCheckedBorderStyle = "--framer-input-boolean-checked-border-style",
e.BooleanCheckedBoxShadow = "--framer-input-boolean-checked-box-shadow",
e.BooleanCheckedTransition = "--framer-input-boolean-checked-transition",
e.InvalidTextColor = "--framer-input-invalid-text-color",
e.IconBackgroundImage = "--framer-input-icon-image",
e.IconMaskImage = "--framer-input-icon-mask-image",
e.IconColor = "--framer-input-icon-color",
e.WrapperHeight = "--framer-input-wrapper-height",
e))(wT || {})
  , Te = wT
  , Z1 = "framer-form-input"
  , CB = "framer-form-input-wrapper";
function TB(e) {
    return typeof e == "number" ? e : e.startsWith("--") ? dt.variable(e) : e === "" ? '""' : e
}
function dt(e, t) {
    let n = " ";
    for (let r in t) {
        let i = t[r];
        n += `${r.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${TB(i)}; `
    }
    return e + " {" + n + "}"
}
(e => {
    function t(...n) {
        let r = n[n.length - 1]
          , i = r.startsWith("--") ? `var(${r})` : r;
        for (let o = n.length - 2; o >= 0; o--)
            i = `var(${n[o]}, ${i})`;
        return i
    }
    e.variable = t
}
)(dt || (dt = {}));
var YW = [dt(`.${Z1}`, {
    padding: dt.variable(Te.Padding),
    background: "transparent",
    fontFamily: dt.variable(Te.FontFamily),
    fontWeight: dt.variable(Te.FontWeight),
    fontSize: dt.variable(Te.FontSize),
    fontStyle: dt.variable(Te.FontStyle),
    color: dt.variable(Te.FontColor),
    fontFeatureSettings: dt.variable(Te.FontOpenType),
    border: "none",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden",
    width: "100%",
    height: dt.variable(Te.WrapperHeight, "100%"),
    letterSpacing: dt.variable(Te.FontLetterSpacing),
    textAlign: dt.variable(Te.FontTextAlignment),
    lineHeight: dt.variable(Te.FontLineHeight)
}), dt(`.${Z1}:focus-visible`, {
    outline: "none"
})];
var KW = `var(${Te.BorderTopWidth}) var(${Te.BorderRightWidth}) var(${Te.BorderBottomWidth}) var(${Te.BorderLeftWidth})`
  , QW = [`.${CB}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${Te.BorderRadiusTopLeft});
        border-top-right-radius: var(${Te.BorderRadiusTopRight});
        border-bottom-right-radius: var(${Te.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${Te.BorderRadiusBottomLeft});
        border-color: var(${Te.BorderColor});
        border-top-width: var(${Te.BorderTopWidth});
        border-right-width: var(${Te.BorderRightWidth});
        border-bottom-width: var(${Te.BorderBottomWidth});
        border-left-width: var(${Te.BorderLeftWidth});
        border-style: var(${Te.BorderStyle});
        transition: var(${Te.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius;
    }`];
var xm = 16
  , ZW = {
    content: "",
    display: "block",
    position: "absolute",
    right: 0,
    top: 0,
    bottom: 0,
    width: `${xm}px`,
    boxSizing: "content-box",
    padding: dt.variable(Te.Padding),
    border: "none",
    pointerEvents: "none",
    backgroundRepeat: "no-repeat",
    backgroundSize: `${xm}px`,
    maskRepeat: "no-repeat",
    maskSize: `${xm}px`,
    backgroundColor: dt.variable(Te.IconColor)
};
var aU = x.forwardRef(function(t, n) {
    let {background: r, children: i, alt: o, draggable: s, ...a} = t
      , l = {
        ...a.style
    };
    r && delete l.background;
    let c = za(t.as);
    return he(c, {
        ...a,
        style: l,
        ref: n,
        children: [r && k(Gk, {
            image: r,
            alt: o,
            draggable: s
        }), i]
    })
});
function RB(e, t) {
    return e.length === t.length && e.every( (n, r) => n === t[r])
}
var EB = /[^\p{Letter}\p{Number}()]+/gu
  , FB = /^-+|-+$/gu;
function PB(e) {
    return e.toLowerCase().replace(EB, "-").replace(FB, "")
}
var _B = /[&<>'"]/gu
  , IB = e => e.replace(_B, t => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
})[t] || t)
  , OB = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
function MB(e, t, n, r) {
    return e.replace(OB, (i, o, s, a, l, c, u) => {
        var f, d;
        if (s.toLowerCase() !== "a")
            return i;
        let p = l || c
          , v = og(p.replace(/&amp;/gu, "&"));
        if (!v || !v.target)
            return i;
        let g = t(v.target);
        if (!YS(g) || !YS(n))
            return i;
        let b = g.path
          , m = n.path;
        if (!b || !m)
            return i;
        let h = ` data-framer-page-link-target="${v.target}"`
          , y = Du(g, v.element ?? void 0);
        y && (h += ` data-framer-page-link-element="${v.element}"`);
        let w = Ma(p);
        if (!w || xe(w))
            return i;
        MC(n, w, r) && (h += " data-framer-page-link-current");
        let C = b
          , S = Object.assign({}, r, (f = v.collectionItem) == null ? void 0 : f.pathVariables);
        if (Object.keys(S).length > 0 && (C = C.replace(IC, (T, E) => "" + S[E])),
        (d = v.collectionItem) != null && d.pathVariables) {
            let T = new URLSearchParams(v.collectionItem.pathVariables);
            h += ` data-framer-page-link-path-variables="${T}"`
        }
        return C = fk(m, C),
        o + a + `"${IB(C + (y ? `#${y}` : ""))}"` + h + u
    }
    )
}
var LB = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
}
  , ST = /[&<>"']/gu
  , VB = ( () => new RegExp(ST.source))();
function J1(e) {
    return e && VB.test(e) ? e.replace(ST, t => LB[t] ?? "") : e || ""
}
var ek = "{{ text-placeholder }}"
  , AB = "rich-text-wrapper"
  , DB = Ie(function(t, n) {
    let {id: r, name: i, html: o, htmlFromDesign: s, text: a, textFromDesign: l, fonts: c=[], width: u, height: f, left: d, right: p, top: v, bottom: g, center: b, className: m, stylesPresetsClassName: h, visible: y=!0, opacity: w, rotation: C=0, verticalAlignment: S="top", isEditable: T=!1, willChangeTransform: E, environment: I=ue.current, withExternalLayout: O=!1, positionSticky: B, positionStickyTop: z, positionStickyRight: j, positionStickyBottom: J, positionStickyLeft: H, __htmlStructure: fe, __fromCanvasComponent: ie=!1, _forwardedOverrideId: q, _forwardedOverrides: re, _usesDOMRect: U, children: pe, ...me} = t
      , ae = Aa()
      , X = Ba(t)
      , Ye = V(null)
      , Ce = n ?? Ye
      , {navigate: Ke, getRoute: Ee} = Ki()
      , dn = La();
    TL(t.preload ?? []),
    Hu(t, Ce);
    let St = D(ts)
      , Hn = ns()
      , ce = a
      , Yt = q ?? r;
    if (Yt && re) {
        let Qe = re[Yt];
        typeof Qe == "string" && (ce = Qe)
    }
    let lt = "";
    if (ce) {
        let Qe = J1(ce);
        lt = fe ? fe.replace(ek, Qe) : `<p>${Qe}</p>`
    } else if (o)
        lt = o;
    else if (l) {
        let Qe = J1(l);
        lt = fe ? fe.replace(ek, Qe) : `<p>${Qe}</p>`
    } else
        s && (lt = s);
    let hn = OC()
      , Na = se( () => Hn || !Ee || !dn ? lt : MB(lt, Ee, dn, hn), [Hn, lt, Ee, dn, hn]);
    if ($( () => {
        let Qe = Ce.current;
        if (Qe === null)
            return;
        function dr(Kt) {
            let mi = ig(Kt.target, Ce.current);
            if (Kt.metaKey || !Ke || !mi || mi.getAttribute("target") === "_blank")
                return;
            t5(Ke, mi, hn) && Kt.preventDefault()
        }
        return Qe.addEventListener("click", dr),
        () => {
            Qe.removeEventListener("click", dr)
        }
    }
    , [Ke, hn]),
    CT(c, ie, Ce),
    ct( () => {
        Da()
    }
    , []),
    !y)
        return null;
    let F = T && I() === ue.canvas
      , _ = {
        outline: "none",
        display: "flex",
        flexDirection: "column",
        justifyContent: kT(S),
        opacity: F ? 0 : w,
        flexShrink: 0
    }
      , L = ue.hasRestrictions()
      , G = Pa(t, ae || 0, !1)
      , ge = U && (u === "auto" || f === "auto")
      , gt = !!t.transformTemplate || !G || !L || ie || ge ? t.transformTemplate ?? Nu(b) : void 0;
    if (!O) {
        if (G && L && !ge) {
            let Qe = at.getNumber(C).toFixed(4);
            _.transform = `translate(${G.x}px, ${G.y}px) rotate(${Qe}deg)`,
            _.width = G.width,
            _.minWidth = G.width,
            _.height = G.height
        } else
            _.left = d,
            _.right = p,
            _.top = v,
            _.bottom = g,
            _.width = u,
            _.height = f,
            _.rotate = C;
        B ? (!Hn || St) && (_.position = "sticky",
        _.willChange = "transform",
        _.zIndex = 1,
        _.top = z,
        _.right = j,
        _.bottom = J,
        _.left = H) : Hn && (t.positionFixed || t.positionAbsolute) && (_.position = "absolute")
    }
    return tg(t, _),
    lC(t, _),
    E && Zm(_),
    Object.assign(_, t.style),
    k(Jt.div, {
        id: r,
        ref: Ce,
        ...me,
        style: _,
        layoutId: X,
        "data-framer-name": i,
        "data-framer-component-type": "DeprecatedRichText",
        "data-center": b,
        className: bu(m, h, AB),
        transformTemplate: gt,
        dangerouslySetInnerHTML: {
            __html: Na
        }
    })
});
function kT(e) {
    switch (e) {
    case "top":
        return "flex-start";
    case "center":
        return "center";
    case "bottom":
        return "flex-end"
    }
}
function CT(e, t, n) {
    let r = V([]);
    RB(r.current, e) || (r.current = e,
    mu.loadFonts(e).then( ({newlyLoadedFontCount: i}) => {
        !t || !n.current || ue.current() !== ue.canvas || i > 0 && nD(n.current)
    }
    ))
}
function Dm() {
    return {
        current: null
    }
}
async function TT(e, t) {
    let n = e.current;
    if (n)
        return n;
    let r, i = new Promise( (o, s) => {
        r = o,
        t.signal.addEventListener("abort", () => s())
    }
    );
    return Object.defineProperty(e, "current", {
        get() {
            return n
        },
        set(o) {
            if (n = o,
            o === null) {
                t.abort();
                return
            }
            r(o)
        },
        configurable: !0
    }),
    i
}
var RT = {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0,
    skewX: 0,
    skewY: 0,
    filter: "none"
};
function zB(e) {
    return e in RT
}
function BB(e) {
    let t = {};
    for (let n in e)
        !zB(n) || et(e[n]) || (t[n] = [e[n], RT[n]]);
    return t
}
var $B = /\p{Regional_Indicator}{2}|\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?(?:\u{200d}\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?)*|./gu;
function NB(e, t="character", n, r) {
    switch (t) {
    case "character":
    case "line":
        {
            let i = e.split(" ")
              , o = i.length - 1;
            return i.map( (s, a) => {
                var l;
                let c = a === o
                  , u = s.length <= 12;
                return he(gn, {
                    children: [k("span", {
                        style: {
                            whiteSpace: u ? "nowrap" : "unset"
                        },
                        children: (l = s.match($B)) == null ? void 0 : l.map( (f, d) => {
                            let p = Dm();
                            return n.add(p),
                            k("span", {
                                ref: p,
                                style: r,
                                children: f
                            }, f + d)
                        }
                        )
                    }), c ? null : " "]
                }, s + a + c)
            }
            )
        }
    case "word":
        {
            let i = e.split(" ")
              , o = i.length - 1;
            return i.map( (s, a) => {
                let l = a === o
                  , c = Dm();
                return n.add(c),
                he(gn, {
                    children: [k("span", {
                        ref: c,
                        style: r,
                        children: s
                    }), l ? null : " "]
                }, s + a + l)
            }
            )
        }
    case "element":
    default:
        return e
    }
}
function jB(e) {
    let t = e.type;
    switch (t) {
    case "appear":
        return e.tokenization ?? "character";
    default:
        ke(t)
    }
}
function tk(e) {
    let t = [];
    return He(e.x) && t.push(`translateX(${e.x}px)`),
    He(e.y) && t.push(`translateY(${e.y}px)`),
    He(e.scale) && t.push(`scale(${e.scale})`),
    He(e.rotate) && t.push(`rotate(${e.rotate}deg)`),
    He(e.rotateX) && t.push(`rotateX(${e.rotateX}deg)`),
    He(e.rotateY) && t.push(`rotateY(${e.rotateY}deg)`),
    He(e.skewX) && t.push(`skewX(${e.skewX}deg)`),
    He(e.skewY) && t.push(`skewY(${e.skewY}deg)`),
    t.join(" ")
}
function HB(e, t, n) {
    if (!n || !n.effect)
        return;
    let r = n.type;
    switch (r) {
    case "appear":
        switch (n.tokenization) {
        case "element":
            return !e || !t ? void 0 : {
                opacity: n.effect.opacity,
                filter: n.effect.filter,
                transform: tk(n.effect)
            };
        case "line":
        case "word":
        case "character":
        default:
            return !e || !t ? {
                display: "inline-block"
            } : {
                display: "inline-block",
                opacity: n.effect.opacity,
                filter: n.effect.filter,
                transform: tk(n.effect)
            }
        }
    default:
        ke(r)
    }
}
function WB(e, t, n) {
    let r = mt( () => new Set)
      , i = ns()
      , o = n || !i
      , s = V({
        hasMounted: !1,
        hasAnimatedOnce: !1,
        isAnimating: !1,
        effect: e
    });
    s.current.effect = e;
    let a = e?.trigger ?? "onMount"
      , l = e?.target
      , c = e?.threshold;
    $( () => {
        if (!o || n)
            return;
        s.current.hasMounted = !0;
        function d() {
            let {effect: p} = s.current;
            if (!o || !p || p?.repeat !== !0 && s.current.hasAnimatedOnce || p?.type === "appear" && s.current.isAnimating)
                return;
            Object.assign(s.current, {
                hasAnimatedOnce: !0,
                isAnimating: !0
            });
            let v = p.type;
            switch (v) {
            case "appear":
                {
                    let {transition: g, startDelay: b, repeat: m, tokenization: h} = p
                      , y = {
                        current: void 0
                    };
                    return nk(h, p.effect, r, g, b, m, () => {
                        Object.assign(s.current, {
                            isAnimating: !1
                        })
                    }
                    , y),
                    () => {
                        var w;
                        return (w = y.current) == null ? void 0 : w.call(y)
                    }
                }
            default:
                ke(v)
            }
        }
        switch (a) {
        case "onMount":
            d();
            return;
        case "onInView":
            {
                let p = t?.current;
                return p ? Ld(p, d, {
                    amount: c ?? 0
                }) : void 0
            }
        case "onScrollTarget":
            {
                let p = l?.ref.current;
                return p ? Ld(p, d, {
                    amount: c ?? 0,
                    root: document,
                    margin: l?.offset ? `${l.offset}px 0px 0px 0px` : void 0
                }) : void 0
            }
        default:
            ke(a)
        }
    }
    , [o, r, n, t, l, c, a]);
    let u = !!e
      , f = e ? jB(e) : void 0;
    return se( () => ({
        getTokenizer: () => {
            if (r.clear(),
            !u)
                return;
            let {hasMounted: d, hasAnimatedOnce: p, effect: v} = s.current
              , g = HB(o, n || UB(d, p, v), s.current.effect);
            return {
                text: b => NB(b, f, r, g),
                props: b => {
                    if (v?.tokenization !== "element")
                        return;
                    let m = Dm();
                    return r.add(m),
                    {
                        ref: m,
                        style: {
                            ...b,
                            ...g
                        }
                    }
                }
            }
        }
        ,
        play: () => {
            let {effect: d} = s.current;
            if (!d)
                return;
            let p = d.type;
            switch (p) {
            case "appear":
                {
                    let {transition: v, startDelay: g} = d;
                    nk(f, d.effect, r, v, g);
                    break
                }
            default:
                ke(p)
            }
        }
    }), [o, u, r, n, f])
}
function UB(e, t, n) {
    return !(e && n?.trigger === "onMount" || t && !n?.repeat && (n?.trigger === "onInView" || n?.trigger === "onScrollTarget"))
}
async function nk(e="character", t, n, r, i=0, o=!1, s, a) {
    let l = BB(t)
      , c = new AbortController;
    switch (a && (a.current = () => c.abort()),
    e) {
    case "character":
    case "element":
    case "word":
        {
            let u = await GB(n, c);
            if (u === null || (Zn(u, l, {
                ...r,
                restDelta: .001,
                delay: Dd(r?.delay ?? 0, {
                    startDelay: i
                })
            }).then( () => s?.()),
            !o || !a))
                return;
            a.current = () => void Zn(u, t, {
                ...r,
                restDelta: .001,
                delay: Dd(r?.delay ?? 0, {
                    startDelay: i
                })
            });
            return
        }
    case "line":
        {
            try {
                for (let f of n)
                    await TT(f, c)
            } catch {
                return
            }
            let u;
            if (Z.read( () => {
                u = qB(n),
                u.length !== 0 && Z.update( () => {
                    let f = u.map( (d, p) => Zn(d, l, {
                        ...r,
                        restDelta: .001,
                        delay: i + p * (r?.delay ?? 0)
                    }));
                    Promise.all(f).then( () => s?.())
                }
                )
            }
            ),
            !o || !a)
                return;
            a.current = () => {
                u.length !== 0 && u.forEach( (f, d) => {
                    Zn(f, t, {
                        ...r,
                        restDelta: .001,
                        delay: i + d * (r?.delay ?? 0)
                    })
                }
                )
            }
            ;
            return
        }
    default:
        ke(e)
    }
}
async function GB(e, t) {
    if (e.size === 0)
        return null;
    let n = [];
    for (let r of e)
        try {
            let i = await TT(r, t);
            i && n.push(i)
        } catch {
            return null
        }
    return n
}
function qB(e) {
    let t = []
      , n = []
      , r = null;
    for (let i of e) {
        if (!i.current)
            continue;
        let o = i.current.offsetTop
          , s = i.current.offsetHeight;
        !s || r === null || o === r ? n.push(i.current) : (t.push(n),
        n = [i.current]),
        s && (r = o)
    }
    return t.push(n),
    t
}
var rk = Ie( ({viewBoxScale: e, viewBox: t, children: n, ...r}, i) => k(Jt.svg, {
    ref: i,
    ...r,
    viewBox: t,
    children: k(Jt.foreignObject, {
        width: "100%",
        height: "100%",
        className: "framer-fit-text",
        transform: `scale(${e})`,
        style: {
            overflow: "visible",
            transformOrigin: "center center"
        },
        children: n
    })
}))
  , XB = Ie( (e, t) => {
    let {__fromCanvasComponent: n=!1, _forwardedOverrideId: r, _forwardedOverrides: i, _usesDOMRect: o, anchorLinkOffsetY: s, as: a, bottom: l, center: c, children: u, environment: f=ue.current, fonts: d=[], height: p, isEditable: v=!1, left: g, name: b, opacity: m, positionSticky: h, positionStickyBottom: y, positionStickyLeft: w, positionStickyRight: C, positionStickyTop: S, right: T, rotation: E=0, style: I, _initialStyle: O, stylesPresetsClassNames: B, text: z, top: j, verticalAlignment: J="top", visible: H=!0, width: fe, willChangeTransform: ie, withExternalLayout: q=!1, viewBox: re, viewBoxScale: U=1, effect: pe, ...me} = e
      , ae = Aa()
      , X = ns()
      , Ye = D(ts)
      , Ce = Ba(e)
      , Ke = V(null)
      , Ee = t ?? Ke;
    Hu(e, Ee),
    CT(d, n, Ee),
    ct( () => {
        Da()
    }
    , []);
    let dn = WB(pe, Ee)
      , St = se( () => {
        if (u)
            return ET(u, B, z, s, void 0, dn.getTokenizer())
    }
    , [u, B, z, s, dn]);
    if (!H)
        return null;
    let Hn = v && f() === ue.canvas
      , ce = {
        outline: "none",
        display: "flex",
        flexDirection: "column",
        justifyContent: kT(J),
        opacity: Hn ? 0 : m,
        flexShrink: 0
    }
      , Yt = ue.hasRestrictions()
      , lt = Pa(e, ae || 0, !1)
      , hn = o && (fe === "auto" || p === "auto")
      , F = !!e.transformTemplate || !lt || !Yt || n || hn ? e.transformTemplate ?? Nu(c) : void 0;
    q || (lt && Yt && !hn ? (ce.x = lt.x,
    ce.y = lt.y,
    ce.rotate = at.getNumber(E),
    ce.width = lt.width,
    ce.minWidth = lt.width,
    ce.height = lt.height) : (ce.left = g,
    ce.right = T,
    ce.top = j,
    ce.bottom = l,
    ce.width = fe,
    ce.height = p,
    ce.rotate = E),
    h ? (!X || Ye) && (ce.position = "sticky",
    ce.willChange = "transform",
    ce.zIndex = 1,
    ce.top = S,
    ce.right = C,
    ce.bottom = y,
    ce.left = w) : X && (e.positionFixed || e.positionAbsolute) && (ce.position = "absolute")),
    tg(e, ce),
    lC(e, ce),
    ie && Zm(ce),
    Object.assign(ce, O, I),
    Ce && (me.layout = "preserve-aspect");
    let _ = za(e.as);
    return xe(e.viewBox) ? e.as !== void 0 ? k(_, {
        ...me,
        ref: Ee,
        style: ce,
        layoutId: Ce,
        transformTemplate: F,
        "data-framer-name": b,
        "data-framer-component-type": "RichTextContainer",
        children: k(rk, {
            viewBox: re,
            viewBoxScale: U,
            style: {
                width: "100%",
                height: "100%"
            },
            children: St
        })
    }) : k(rk, {
        ...me,
        ref: Ee,
        style: ce,
        layoutId: Ce,
        viewBox: re,
        viewBoxScale: U,
        transformTemplate: F,
        "data-framer-name": b,
        "data-framer-component-type": "RichTextContainer",
        children: St
    }) : k(_, {
        ...me,
        ref: Ee,
        style: ce,
        layoutId: Ce,
        transformTemplate: F,
        "data-framer-name": b,
        "data-framer-component-type": "RichTextContainer",
        children: St
    })
}
);
function YB(e) {
    return e.type === gn
}
function KB(e) {
    return e.type === "br"
}
function ET(e, t, n, r, i={}, o, s=YB(e) ? -1 : 0) {
    let a = mn.toArray(e.props.children);
    xe(n) && (a = a.slice(0, 1));
    let l = !0;
    a = a.map(f => {
        if ((!Ot(f) || !KB(f)) && (l = !1),
        Ot(f))
            return ET(f, t, n, r, i, o, s + 1);
        let d = xe(n) ? n : f;
        return xe(d) && o ? o.text(d) : d
    }
    );
    let {["data-preset-tag"]: c, ...u} = e.props;
    if (xe(e.type) || Rl(e.type)) {
        let f = Vd(e.type) || e.type
          , d = c || f
          , p = xe(d) ? t?.[d] : void 0;
        u.className = bu("framer-text", u.className, p),
        o && s === 0 && !l && Object.assign(u, o.props(u.style));
        let v = f === "h1" || f === "h2" || f === "h3" || f === "h4" || f === "h5" || f === "h6"
          , g = t?.anchor;
        if (v && g) {
            let b = QB(a, i);
            u.id = b;
            let m = bu("framer-text", g)
              , h = k("a", {
                href: `#${b}`,
                className: m,
                children: a
            });
            u.style = {
                ...u.style ?? {},
                scrollMarginTop: r
            },
            a = [h]
        }
    }
    return mr(e, u, ...a)
}
function QB(e, t) {
    let n = e.map(zm).join("")
      , r = PB(n)
      , i = t[r] ?? 0;
    return i > 0 && (r += `-${i}`),
    t[r] = i + 1,
    r
}
function zm(e) {
    return xe(e) || He(e) ? e.toString() : Ot(e) ? zm(e.props.children) : Array.isArray(e) ? e.map(zm).join("") : ""
}
var hU = Ie( ({children: e, html: t, htmlFromDesign: n, ...r}, i) => {
    let o = t || e || n;
    if (xe(o)) {
        !r.stylesPresetsClassName && Re(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(" "));
        let s = {
            [xe(t) ? "html" : "htmlFromDesign"]: o
        };
        return k(DB, {
            ...r,
            ...s,
            ref: i
        })
    }
    if (!r.stylesPresetsClassNames && xe(r.stylesPresetsClassName)) {
        let[s,a,l,c,u] = r.stylesPresetsClassName.split(" ");
        s === void 0 || a === void 0 || l === void 0 || c === void 0 || u === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = {
            h1: s,
            h2: a,
            h3: l,
            p: c,
            a: u
        }
    }
    return k(XB, {
        ...r,
        ref: i,
        children: Ot(o) ? o : void 0
    })
}
);
function ZB(e) {
    var t, n;
    let r = e * Math.PI / 180
      , i = {
        x: -Math.sin(r) * 100,
        y: Math.cos(r) * 100
    }
      , o = un(i.x, i.y)
      , s = En(un(.5, .5), o)
      , a = te.points({
        x: 0,
        y: 0,
        width: 1,
        height: 1
    })
      , l = a.map(g => ({
        point: g,
        distance: un.distance(o, g)
    })).sort( (g, b) => g.distance - b.distance)
      , c = (t = l[0]) == null ? void 0 : t.point
      , u = (n = l[1]) == null ? void 0 : n.point;
    A(c && u, "linearGradientLine: Must have 2 closest points.");
    let[f,d] = a.filter(g => !un.isEqual(g, c) && !un.isEqual(g, u));
    A(f && d, "linearGradientLine: Must have 2 opposing points.");
    let p = En.intersection(s, En(c, u))
      , v = En.intersection(s, En(f, d));
    return A(p && v, "linearGradientLine: Must have a start and end point."),
    En(p, v)
}
function JB(e, t) {
    var n, r;
    let i = ZB(e.angle)
      , o = $a(e)
      , s = ((n = o[0]) == null ? void 0 : n.position) ?? 0
      , a = ((r = o[o.length - 1]) == null ? void 0 : r.position) ?? 1
      , l = En.pointAtPercentDistance(i, s)
      , c = En.pointAtPercentDistance(i, a)
      , u = ho([s, a], [0, 1]);
    return {
        id: `id${t}g${_a.hash(e)}`,
        x1: l.x,
        y1: l.y,
        x2: c.x,
        y2: c.y,
        stops: o.map(f => ({
            color: f.value,
            alpha: Jm.getAlpha(f.value) * e.alpha,
            position: u(f.position)
        }))
    }
}
function e$(e, t) {
    return {
        id: `id${t}g${Ia.hash(e)}`,
        widthFactor: e.widthFactor,
        heightFactor: e.heightFactor,
        centerAnchorX: e.centerAnchorX,
        centerAnchorY: e.centerAnchorY,
        stops: $a(e).map(n => ({
            color: n.value,
            alpha: Jm.getAlpha(n.value) * e.alpha,
            position: n.position
        }))
    }
}
function FT(e) {
    if (!xe(e) || e.charAt(e.length - 1) !== "%")
        return !1;
    let n = e.slice(0, -1)
      , r = parseFloat(n);
    return He(r)
}
function PT(e) {
    let t = e.slice(0, -1)
      , n = parseFloat(t);
    return He(n) ? n : 50
}
function ik(e) {
    return FT(e) ? PT(e) / 100 : e === "left" ? 0 : e === "right" ? 1 : .5
}
function ok(e) {
    return FT(e) ? PT(e) / 100 : e === "top" ? 0 : e === "bottom" ? 1 : .5
}
function t$(e, t, n, r) {
    if (e = at.get(e, "#09F"),
    !Hi.isImageObject(e) || !e.pixelWidth || !e.pixelHeight)
        return;
    let i = e.pixelWidth, o = e.pixelHeight, s, {fit: a} = e, l = 1, c = 1, u = 0, f = 0;
    if (a === "fill" || a === "fit" || a === "tile" || !a) {
        let p = 1
          , v = 1
          , g = i / o
          , b = t.height * g
          , m = t.width / g
          , h = b / t.width
          , y = m / t.height;
        if (a === "tile") {
            e.backgroundSize ?? (e.backgroundSize = 1),
            l = Math.round(e.backgroundSize * (i / 2)),
            c = Math.round(e.backgroundSize * (o / 2));
            let w = t.x ?? 0
              , C = t.y ?? 0
              , S = 0
              , T = 0;
            r && (S = w,
            T = C),
            u = (t.width - l) * ik(e.positionX) + S,
            f = (t.height - c) * ok(e.positionY) + T,
            s = `translate(${u + w}, ${f + C})`
        } else
            (a === "fill" || !a ? y > h : y < h) ? (v = y,
            f = (1 - y) * ok(e.positionY)) : (p = h,
            u = (1 - h) * ik(e.positionX)),
            s = `translate(${u}, ${f}) scale(${p}, ${v})`
    }
    return {
        id: `id${n}g-fillImage`,
        path: e.src ?? "",
        transform: s,
        width: l,
        height: c,
        offsetX: u,
        offsetY: f
    }
}
var n$ = "framer/asset-reference,";
function r$(e) {
    return e.startsWith(`data:${n$}`)
}
function i$(e, t) {
    if (/^\w+:/u.test(e) && !r$(e))
        return e;
    typeof t != "number" ? t = void 0 : t <= 512 ? t = 512 : t <= 1024 ? t = 1024 : t <= 2048 ? t = 2048 : t = 4096;
    let n = ue.current() === ue.export;
    return pt.assetResolver(e, {
        pixelSize: t,
        isExport: n
    }) ?? ""
}
var o$ = ({id: e, path: t, transform: n, repeat: r, width: i, height: o, offsetX: s, offsetY: a}) => {
    let l = i$(t);
    return k("pattern", {
        id: e,
        width: r ? i : "100%",
        height: r ? o : "100%",
        patternContentUnits: r ? void 0 : "objectBoundingBox",
        patternUnits: r ? "userSpaceOnUse" : void 0,
        x: r ? s : void 0,
        y: r ? a : void 0,
        children: k("image", {
            width: r ? i : 1,
            height: r ? o : 1,
            href: l,
            preserveAspectRatio: "none",
            transform: r ? void 0 : n,
            x: r ? 0 : void 0,
            y: r ? 0 : void 0
        }, l)
    })
}
;
var wm, s$ = ( () => !UA() && typeof Document < "u" && typeof Document.parseHTMLUnsafe == "function")();
function a$(e, t) {
    return s$ && !t ? Document.parseHTMLUnsafe(e) : (wm ?? (wm = new DOMParser),
    wm.parseFromString(e, t ?? "text/html"))
}
var sk = Vr()
  , l$ = class {
    constructor(e, t, n, r, i=0) {
        this.id = e,
        this.svg = t,
        this.innerHTML = n,
        this.viewBox = r,
        this.count = i
    }
}
  , ak = "position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict"
  , c$ = class {
    constructor() {
        R(this, "entries", new Map)
    }
    debugGetEntries() {
        return this.entries
    }
    subscribe(e, t, n) {
        if (!e || e === "")
            return "";
        let r = this.entries.get(e);
        if (!r) {
            n || (n = `svg${String(eC(e))}_${String(e.length)}`);
            let i = e, o, s = u$(e);
            s && (t && f$(s, n),
            s.id = n,
            o = m$(s),
            s.removeAttribute("xmlns"),
            s.removeAttribute("xlink"),
            s.removeAttribute("xmlns:xlink"),
            i = s.outerHTML),
            r = this.createDOMElementFor(i, n, o),
            this.entries.set(e, r)
        }
        return r.count += 1,
        r.innerHTML
    }
    getViewBox(e) {
        if (!e || e === "")
            return;
        let t = this.entries.get(e);
        return t?.viewBox
    }
    unsubscribe(e) {
        if (!e || e === "")
            return;
        let t = this.entries.get(e);
        t && (t.count -= 1,
        !(t.count > 0) && setTimeout( () => this.maybeRemoveEntry(e), 5e3))
    }
    maybeRemoveEntry(e) {
        let t = this.entries.get(e);
        t && (t.count > 0 || (this.entries.delete(e),
        this.removeDOMElement(t)))
    }
    removeDOMElement(e) {
        if (sk) {
            let t = document?.getElementById(e.id);
            t?.remove()
        }
    }
    createDOMElementFor(e, t, n) {
        if (sk) {
            let s = document.getElementById("svg-templates");
            if (s || (s = document.createElement("div"),
            s.id = "svg-templates",
            s.ariaHidden = "true",
            s.style.cssText = ak,
            document.body.appendChild(s)),
            !document.getElementById(t)) {
                let a = document.createElement("div");
                a.innerHTML = e;
                let l = a.firstElementChild;
                l && (l.id = t,
                s.appendChild(l))
            }
        }
        let r = n ? `0 0 ${n.width} ${n.height}` : void 0
          , o = `<svg style="width:100%;height:100%"${r ? ` viewBox="${r}"` : ""}><use href="#${t}"/></svg>`;
        return new l$(t,e,o,r)
    }
    clear() {
        this.entries.clear()
    }
    generateTemplates() {
        let e = [];
        return e.push(`<div id="svg-templates" style="${ak}" aria-hidden="true">`),
        this.entries.forEach(t => e.push(t.svg)),
        e.push("</div>"),
        e.join(`
`)
    }
}
  , qo = new c$;
function u$(e) {
    try {
        let n = a$(e).getElementsByTagName("svg")[0];
        if (!n)
            throw Error("no svg element found");
        return n
    } catch {
        return
    }
}
function f$(e, t) {
    let n = d$(t);
    _T(e, n)
}
function d$(e) {
    return e.replace(/[^\w\-:.]|^[^a-z]+/gi, "")
}
function _T(e, t) {
    h$(e, t),
    Array.from(e.children).forEach(r => {
        _T(r, t)
    }
    )
}
function h$(e, t) {
    e.getAttributeNames().forEach(r => {
        let i = e.getAttribute(r);
        if (!i)
            return;
        if (r === "id" && e.setAttribute(r, `${t}_${i}`),
        r === "href" || r === "xlink:href") {
            let[s,a] = i.split("#");
            if (s)
                return;
            e.setAttribute(r, `#${t}_${a}`);
            return
        }
        let o = "url(#";
        if (i.includes(o)) {
            let s = i.replace(o, `${o}${t}_`);
            e.setAttribute(r, s)
        }
    }
    )
}
var p$ = ( () => ({
    cm: 96 / 2.54,
    mm: 96 / 2.54 / 10,
    Q: 96 / 2.54 / 40,
    in: 96,
    pc: 96 / 6,
    pt: 96 / 72,
    px: 1,
    em: 16,
    ex: 8,
    ch: 8,
    rem: 16
}))();
function lk(e) {
    var t;
    if (!e)
        return;
    let n = /(-?[\d.]+)([a-z%]*)/u.exec(e);
    if (!(n?.[1] === void 0 || n?.[2] === void 0) && !((t = n[2]) != null && t.startsWith("%")))
        return Math.round(parseFloat(n[1]) * (p$[n[2]] || 1))
}
function m$(e) {
    let t = lk(e.getAttribute("width"))
      , n = lk(e.getAttribute("height"));
    if (!(typeof t != "number" || typeof n != "number") && !(t <= 0 || n <= 0))
        return {
            width: t,
            height: n
        }
}
function vU(e) {
    let t = Aa()
      , n = Ba(e)
      , r = x.useRef(null)
      , i = Z4();
    return Hu(e, r),
    k(w$, {
        ...e,
        innerRef: r,
        parentSize: t,
        layoutId: n,
        providedWindow: i
    })
}
var g$ = 5e4;
function v$(e) {
    return e.indexOf("image") >= 0
}
function y$(e) {
    return e.indexOf("var(--") >= 0
}
function b$(e) {
    return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius)
}
function ck(e, t) {
    var n, r;
    let i = e.current;
    if (!i)
        return;
    let o = t.providedWindow ?? nt
      , s = i.firstElementChild;
    if (!s || !(s instanceof o.SVGSVGElement))
        return;
    if (!s.getAttribute("viewBox")) {
        let p = qo.getViewBox(t.svg);
        p && s.setAttribute("viewBox", p)
    }
    let {withExternalLayout: a, parentSize: l} = t;
    if (!a && Va(t) && l !== 1 && l !== 2)
        return;
    let {intrinsicWidth: u, intrinsicHeight: f, _constraints: d} = t;
    ((n = s.viewBox.baseVal) == null ? void 0 : n.width) === 0 && ((r = s.viewBox.baseVal) == null ? void 0 : r.height) === 0 && ne(u) && ne(f) && s.setAttribute("viewBox", `0 0 ${u} ${f}`),
    d && d.aspectRatio ? s.setAttribute("preserveAspectRatio", "") : s.setAttribute("preserveAspectRatio", "none"),
    s.setAttribute("width", "100%"),
    s.setAttribute("height", "100%")
}
function x$() {
    return x.useInsertionEffect( () => {
        Da()
    }
    , []),
    null
}
var w$ = ( () => {
    var e;
    return e = class extends lu {
        constructor() {
            super(...arguments),
            R(this, "container", x.createRef()),
            R(this, "svgElement", null),
            R(this, "setSVGElement", t => {
                this.svgElement = t,
                this.setLayerElement(t)
            }
            ),
            R(this, "previouslyRenderedSVG", ""),
            R(this, "unmountedSVG", "")
        }
        static frame(t) {
            return Pa(t, t.parentSize || 0)
        }
        get frame() {
            return Pa(this.props, this.props.parentSize || 0)
        }
        componentDidMount() {
            if (this.unmountedSVG) {
                let {svgContentId: t} = this.props
                  , n = t ? `svg${t}` : null;
                qo.subscribe(this.unmountedSVG, !t, n),
                this.previouslyRenderedSVG = this.unmountedSVG
            }
            this.props.svgContentId || ck(this.container, this.props)
        }
        componentWillUnmount() {
            qo.unsubscribe(this.previouslyRenderedSVG),
            this.unmountedSVG = this.previouslyRenderedSVG,
            this.previouslyRenderedSVG = ""
        }
        componentDidUpdate(t) {
            if (super.componentDidUpdate(t),
            this.props.svgContentId)
                return;
            let {fill: n} = this.props;
            Hi.isImageObject(n) && Hi.isImageObject(t.fill) && n.src !== t.fill.src && Jk(this.svgElement, "fill", null, !1),
            ck(this.container, this.props)
        }
        collectLayout(t, n) {
            if (this.props.withExternalLayout) {
                n.width = "100%",
                n.height = "100%",
                n.aspectRatio = "inherit";
                return
            }
            let r = this.frame
              , {rotation: i, intrinsicWidth: o, intrinsicHeight: s, width: a, height: l} = this.props
              , c = at.getNumber(i);
            if (t.opacity = ne(this.props.opacity) ? this.props.opacity : 1,
            ue.hasRestrictions() && r) {
                Object.assign(t, {
                    transform: `translate(${r.x}px, ${r.y}px) rotate(${c.toFixed(4)}deg)`,
                    width: `${r.width}px`,
                    height: `${r.height}px`
                }),
                Va(this.props) && (t.position = "absolute");
                let v = r.width / (o || 1)
                  , g = r.height / (s || 1);
                n.transformOrigin = "top left";
                let {zoom: b, target: m} = Em;
                if (m === ue.export) {
                    let h = b > 1 ? b : 1;
                    n.transform = `scale(${v * h}, ${g * h})`,
                    n.zoom = 1 / h
                } else
                    n.transform = `scale(${v}, ${g})`;
                o && s && (n.width = o,
                n.height = s);
                return
            }
            let {left: u, right: f, top: d, bottom: p} = this.props;
            Object.assign(t, {
                left: u,
                right: f,
                top: d,
                bottom: p,
                width: a,
                height: l,
                rotate: c
            }),
            Object.assign(n, {
                left: 0,
                top: 0,
                bottom: 0,
                right: 0,
                position: "absolute"
            })
        }
        render() {
            let {id: t, visible: n, style: r, fill: i, svg: o, intrinsicHeight: s, intrinsicWidth: a, title: l, description: c, layoutId: u, className: f, variants: d, withExternalLayout: p, innerRef: v, svgContentId: g, height: b, opacity: m, width: h, ...y} = this.props;
            if (!p && (!n || !t))
                return null;
            let w = t ?? u ?? "svg"
              , C = this.frame
              , S = C || {
                width: a || 100,
                height: s || 100
            }
              , T = {
                ...r,
                imageRendering: "pixelated",
                flexShrink: 0
            }
              , E = {};
            this.collectLayout(T, E),
            ZD(this.props, T),
            tg(this.props, T),
            lu.applyWillChange(this.props, T, !1);
            let I = null;
            if (typeof i == "string" || Y.isColorObject(i)) {
                let U = Y.isColorObject(i) ? i.initialValue || Y.toRgbString(i) : i;
                T.fill = U,
                T.color = U
            } else if (_a.isLinearGradient(i)) {
                let U = i
                  , pe = `${encodeURI(t || "")}g${_a.hash(U)}`;
                T.fill = `url(#${pe})`;
                let {stops: me, x1: ae, x2: X, y1: Ye, y2: Ce} = JB(U, w);
                I = k("svg", {
                    ref: this.setSVGElement,
                    width: "100%",
                    height: "100%",
                    style: {
                        position: "absolute"
                    },
                    children: k("linearGradient", {
                        id: pe,
                        x1: ae,
                        x2: X,
                        y1: Ye,
                        y2: Ce,
                        children: me.map( (Ke, Ee) => k("stop", {
                            offset: Ke.position,
                            stopColor: Ke.color,
                            stopOpacity: Ke.alpha
                        }, Ee))
                    })
                })
            } else if (Ia.isRadialGradient(i)) {
                let U = i
                  , pe = `${encodeURI(t || "")}g${Ia.hash(U)}`;
                T.fill = `url(#${pe})`;
                let me = e$(U, w);
                I = k("svg", {
                    ref: this.setSVGElement,
                    width: "100%",
                    height: "100%",
                    style: {
                        position: "absolute"
                    },
                    children: k("radialGradient", {
                        id: pe,
                        cy: U.centerAnchorY,
                        cx: U.centerAnchorX,
                        r: U.widthFactor,
                        children: me.stops.map( (ae, X) => k("stop", {
                            offset: ae.position,
                            stopColor: ae.color,
                            stopOpacity: ae.alpha
                        }, X))
                    })
                })
            } else if (Hi.isImageObject(i)) {
                let U = t$(i, S, w);
                U && (T.fill = `url(#${U.id})`,
                I = k("svg", {
                    ref: this.setSVGElement,
                    width: "100%",
                    height: "100%",
                    style: {
                        position: "absolute"
                    },
                    children: k("defs", {
                        children: k(o$, {
                            ...U
                        })
                    })
                }))
            }
            let O = {
                "data-framer-component-type": "SVG"
            }
              , B = !C;
            B && Object.assign(O, qk(this.props.center));
            let z = !I && !T.fill && !T.background && !T.backgroundImage && o.length < g$ && !v$(o) && !y$(o)
              , j = null;
            if (z)
                T.backgroundSize = "100% 100%",
                T.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(o)}')`,
                qo.unsubscribe(this.previouslyRenderedSVG),
                this.previouslyRenderedSVG = "";
            else {
                let U = g ? `svg${g}` : null
                  , pe = qo.subscribe(o, !g, U);
                qo.unsubscribe(this.previouslyRenderedSVG),
                this.previouslyRenderedSVG = o,
                b$(T) && (T.overflow = "hidden"),
                j = he(it, {
                    children: [I, k("div", {
                        className: "svgContainer",
                        style: E,
                        ref: this.container,
                        dangerouslySetInnerHTML: {
                            __html: pe
                        }
                    }, Hi.isImageObject(i) ? i.src : "")]
                })
            }
            let J = za(this.props.as)
              , {href: H, target: fe, rel: ie, onClick: q} = this.props
              , re = l || c;
            return he(J, {
                ...O,
                ...y,
                layoutId: u,
                transformTemplate: B ? Nu(this.props.center) : void 0,
                id: t,
                ref: v,
                style: T,
                className: f,
                variants: d,
                tabIndex: this.props.tabIndex,
                role: re ? "img" : void 0,
                "aria-label": l,
                "aria-description": c,
                "aria-hidden": re ? void 0 : "true",
                href: H,
                target: fe,
                rel: ie,
                onClick: q,
                children: [j, k(x$, {})]
            })
        }
    }
    ,
    R(e, "supportsConstraints", !0),
    R(e, "defaultSVGProps", {
        left: void 0,
        right: void 0,
        top: void 0,
        bottom: void 0,
        style: void 0,
        _constraints: {
            enabled: !0,
            aspectRatio: null
        },
        parentSize: 0,
        rotation: 0,
        visible: !0,
        svg: "",
        shadows: []
    }),
    R(e, "defaultProps", {
        ...lu.defaultProps,
        ...e.defaultSVGProps
    }),
    e
}
)();
function EU(e, t, n) {
    let r = IT(t);
    !n?.supportsExplicitInterCodegen && !r.some(i => i.explicitInter === !1) && r.push({
        explicitInter: !1,
        fonts: []
    }),
    Object.assign(e, {
        fonts: r
    })
}
function FU(e) {
    return e.fonts ?? []
}
function PU(e) {
    return e.length === 0 ? [{
        explicitInter: !1,
        fonts: []
    }] : IT(e)
}
function IT(e) {
    let t = {
        explicitInter: !1,
        fonts: []
    }
      , n = [];
    for (let r of e)
        k$(r) ? n.push(r) : t.fonts.push(C$(r));
    return t.fonts.length > 0 && n.push(t),
    n
}
var S$ = "explicitInter";
function k$(e) {
    return S$ in e
}
function C$(e) {
    let t;
    return e.url.startsWith("https://fonts.gstatic.com/s/") ? t = "google" : e.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/") ? t = "fontshare" : t = "custom",
    {
        ...e,
        source: t
    }
}
function _U(e, t) {
    let n = `${e}-start`;
    performance.mark(n),
    t();
    let r = `${e}-end`;
    performance.mark(r),
    performance.measure(e, n, r)
}
gl.prototype.addChild = function({transformer: e=t => t}) {
    let t = Ge(e(this.get()));
    return this.onChange(n => t.set(e(n))),
    t
}
;
/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
export {x as a, gn as b, Ji as c, Ie as d, Mt as e, D as f, $ as g, gi as h, ct as i, se as j, V as k, Oe as l, kt as m, it as n, k as o, he as p, xr as q, Jt as r, j0 as s, CS as t, rM as u, X6 as v, Z6 as w, tj as x, rj as y, oj as z, Ki as A, Ek as B, Fk as C, wj as D, ue as E, Pj as F, yV as G, Lj as H, vA as I, Vj as J, bu as K, b8 as L, T8 as M, R8 as N, A8 as O, Wz as P, CC as Q, j8 as R, TC as S, X8 as T, r5 as U, J8 as V, sW as W, uW as X, dW as Y, hW as Z, D4 as _, gW as $, z4 as aa, B4 as ba, vW as ca, bW as da, SW as ea, kW as fa, PW as ga, VW as ha, mu as ia, aU as ja, hU as ka, qo as la, vU as ma, EU as na, FU as oa, PU as pa, _U as qa};
//# sourceMappingURL=chunk-S6IUZFYY.mjs.map
